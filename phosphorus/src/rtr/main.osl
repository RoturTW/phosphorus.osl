
class Module (
  def init(object ast) (
    void self.loadFromAst(ast)
    void self.initScope()
    void self.defScope()
    
    self.eventQueue @= []
    self.initTopDone = false
    
    // only used in bytecode
    self.returnVal = null
  )
  def loadFromAst(object ast) (
    self.ast @= ast
    
    self.events @= []
    self.eventList @= []
    for i self.ast.elements.len (
      local topLevel @= self.ast.elements[i]
      if topLevel.kind == "event" (
        if topLevel.target.kind == "global" (
          if self.eventList.contains(topLevel.target.target) (
            throw topLevel.target.target + "event already exists on module"
          )
          void self.eventList.append(topLevel.target.target)
        )
        void self.events.append([
          topLevel.target,
          topLevel
        ])
      )
    )
  )
  def initTop() (
    if self.initTopDone (
      return
    )
    self.initTopDone = true
    
    self.ast @= ast
    
    void self.newScope({})
    for i self.ast.elements.len (
      local topLevel @= self.ast.elements[i]
      if topLevel.kind == "global" (
        local val @= self.runExpression(topLevel.val)
        local meta = null
        if topLevel.auto (
          meta @= {
            type: val.getRtrType()
          }
        )
        void self.declScopeVar(topLevel.name, val, meta)
      )
    )
  )
  
  def initScope() (
    self.scope @= []
  )
  def newScope(object vars) (
    void self.scope.append(vars)
  )
  def popScope() (
    return self.scope.pop()
  )
  def defScope() (
    // helper funcs
    local cFunc @= def(name, content) -> (
      void self.setScopeVar(name, rtr.value.RTROslFuncValue(content))
    )
    
    void self.newScope({})
    
    void self.setScopeVar("true", rtr.value.RTRBoolValue(true))
    void self.setScopeVar("false", rtr.value.RTRBoolValue(false))
    
    cFunc("log", def(args, inst) -> (
      local txt = args.map(a -> a.stringify()).join(" ")
      log txt
      void inst.inst.console.append(["log", txt])
    ))
    cFunc("error", def(args, inst) -> (
      local txt = args.map(a -> a.stringify()).join(" ")
      void inst.inst.console.append(["err", txt])
      throw txt
    ))
    cFunc("return", def(args, inst) -> (
      local val @= args[1]
      val ??= rtr.value.RTRNullValue()
      void inst.setScopeVar("@return", val)
      inst.returnVal @= val
    ))
    cFunc("typeof", def(args) -> (
      local val @= args[1] ?? rtr.value.RTRNullValue()
      return val.getRtrType()
    ))
    cFunc("length", def(args) -> (
      return rtr.value.RTRNumValue(args[1].length())
    ))
    
    // mathematical
    cFunc("min", def(args) -> (
      local v = args[1].numbify()
      for i args.len - 1 (
        local a @= args[i + 1].numbify()
        v = min(v, a)
      )
      return rtr.value.RTRNumValue(v)
    ))
    cFunc("max", def(args) -> (
      local v = args[1].numbify()
      for i args.len - 1 (
        local a @= args[i + 1].numbify()
        v = max(v, a)
      )
      return rtr.value.RTRNumValue(v)
    ))
    
    cFunc("abs", def(args) -> (
      return rtr.value.RTRNumValue(args[1].numbify().abs())
    ))
    cFunc("sqrt", def(args) -> (
      return rtr.value.RTRNumValue(args[1].numbify().sqrt())
    ))
    
    cFunc("round", def(args) -> (
      return rtr.value.RTRNumValue(args[1].numbify().round())
    ))
    cFunc("floor", def(args) -> (
      return rtr.value.RTRNumValue(args[1].numbify().floor())
    ))
    cFunc("ceil", def(args) -> (
      return rtr.value.RTRNumValue(args[1].numbify().ceiling())
    ))
    
    // string
    cFunc("join", def(args) -> (
      local txt = ""
      for i args.len (
        txt ++= args[i].stringify()
      )
      return rtr.value.RTRStrValue(txt)
    ))
    cFunc("split", def(args) -> (
      return rtr.value.RTRArrValue(args[1]
        .stringify()
        .split(args[2].stringify())
        .map(e -> rtr.value.RTRStrValue(e)))
    ))
    
    cFunc("chr", def(args) -> (
      return rtr.value.RTRStrValue(args[1].numbify().chr())
    ))
    cFunc("ord", def(args) -> (
      return rtr.value.RTRNumValue(args[1].stringify().ord())
    ))
    
    // array
    cFunc("item", def(args) -> (
      return args[1].getItem(args[2])
    ))
    cFunc("range", def(args) -> (
      return rtr.value.RTRArrValue((args[1].numbify() to args[2].numbify()).map(e -> rtr.value.RTRNumValue(e)))
    ))
    
    // object
    cFunc("keys", def(args) -> (
      return rtr.value.RTRArrValue(args[1].keys().map(e -> rtr.value.RTRStrValue(e)))
    ))
    cFunc("values", def(args) -> (
      return rtr.value.RTRArrValue(args[1].values())
    ))
    cFunc("has", def(args) -> (
      return rtr.value.RTRBoolValue(args[1].has(args[2].stringify()))
    ))
    cFunc("obj", def() -> (
      return rtr.value.RTRObjValue({})
    ))
    
    // logical
    cFunc("all", def(args) -> (
      return rtr.value.RTRBoolValue(args.every(a -> a.boolify()))
    ))
    cFunc("any", def(args) -> (
      return rtr.value.RTRBoolValue(args.some(a -> a.boolify()))
    ))
    cFunc("not", def(args) -> (
      return rtr.value.RTRBoolValue(!args[1].boolify())
    ))
  )
  def getScopeVarRaw(string key) (
    for rawI self.scope.len (
      local layer @= self.scope[self.scope.len - rawI + 1]
      if layer[key] != null (
        return layer[key]
      )
    )
    return null
  )
  def getScopeVar(string key) (
    return self.getScopeVarRaw(key)[1]
  )
  def getScopeVarMeta(string key) (
    return self.getScopeVarRaw(key)[2]
  )
  def setScopeVar(string key, val, meta) (
    meta ??= {}
    for rawI self.scope.len (
      local layer @= self.scope[self.scope.len - rawI + 1]
      if layer[key] != null (
        layer[key] @= [val, layer[key][2] ++ meta]
        return
      )
    )
    void self.declScopeVar(key, val, meta)
  )
  def declScopeVar(string key, val, meta) (
    self.scope[self.scope.len][key] @= [val, meta]
  )
  
  def findEligible(object target) (
    local evs @= []
    
    for i self.events.len (
      local ev @= self.events[i][2]
      
      if target.element != null (
        if ev.target.kind == "property" and ev.target.eventName == target.name (
          if ev.target.target.kind == "id" (
            if ev.target.target.name == target.element.id (
              void evs.append(ev)
            )
          )
        )
      ) else if typeof(ev.target.target) == "string" (
        if ev.target.target == target.name (
          void evs.append(ev)
        )
      )
    )
    
    return evs
  )
  
  def runEvents(object target, object data) (
    void self.eventQueue.append([
      "events",
      target,
      data
    ])
  )
  def runEvent(object target, object data) (
    void self.eventQueue.append([
      "event",
      target,
      data
    ])
  )
  
  def runEventQueue() (
    for i self.eventQueue.len (
      local ev @= self.eventQueue.shift()
      
      if ev[1] == "events" (
        void self.runEventsRaw(ev[2], ev[3])
      )
      if ev[1] == "event" (
        void self.runEventRaw(ev[2], ev[3])
      )
    )
  )
  
  def runEventsRaw(object target, object data) (
    local evs @= self.findEligible(target)
    
    void self.initTop()
    for i evs.len (
      void self.runBlock(evs[i].body)
    )
  )
  def runEventRaw(object target, object data) (
    local ev @= self.findEligible(target)[1]
    
    if ev == null (
      return rtr.value.RTRNullValue()
    )
    
    void self.initTop()
    return self.runBlock(ev.body)
  )
  def runBlock(object block) (
    if shared.config.browser.phosphorus.useCompiler and block.compile == null (
      local compileOut @= rtr.compiler.compileBlock(block)
      if typeof(compileOut) != "array" and compileOut.isError (
        block.compile = false
      ) else (
        block.compile @= compileOut
      )
      self.inst.compiled ??= []
      void self.inst.compiled.append({
        body: compileOut,
        start: block.start,
        end: block.end,
        ast: block
      })
    )
    if block.compile != null (
      return self.runInstructions(block.compile)
    )
    
    local elements @= block.elements
    local outVal @= rtr.value.RTRNullValue()
    void self.newScope({})
    for i elements.len (
      local out @= self.runStatement(elements[i])
      if self.getScopeVar("@return") ?? 0 != 0 (
        outVal @= self.getScopeVar("@return")
        break
      )
    )
    void self.popScope()
    return outVal
  )
  def runStatement(object statement) (
    switch statement.kind (
      case "expression"
        return self.runExpression(statement.expr)
      case "block"
        return self.runBlock(statement.body)
      
      case "branch"
        if self.runExpression(statement.cond).boolify() (
          return self.runStatement(statement.body)
        )
        for i statement.elifs.len (
          local elif @= statement.elifs[i]
          if self.runExpression(elif.cond).boolify() (
            return self.runStatement(elif.body)
          )
        )
        if statement.elseBody != null (
          return self.runStatement(statement.elseBody)
        )
        return rtr.value.RTRNullValue()
      
      case "while"
        local iters = 0
        while self.runExpression(statement.cond).boolify() and self.getScopeVar("@return") ?? 0 == 0 and iters < 999999 (
          void self.runStatement(statement.body)
          iters ++
        )
        return rtr.value.RTRNullValue()
      case "until"
        local iters = 0
        while !self.runExpression(statement.cond).boolify() and self.getScopeVar("@return") ?? 0 == 0 and iters < 999999 (
          void self.runStatement(statement.body)
          iters ++
        )
        return rtr.value.RTRNullValue()
      case "repeat"
        loop self.runExpression(statement.amount).numbify() (
          void self.runStatement(statement.body)
        )
        return rtr.value.RTRNullValue()
      case "for"
        local arr @= self.runExpression(statement.arr).arrify()
        for i arr.len (
          void self.newScope({})
          void self.declScopeVar(statement.var, arr[i])
          void self.runStatement(statement.body)
          void self.popScope()
        )
        return rtr.value.RTRNullValue()
      
      default
        throw "unknown statement type" + statement.kind
    )
  )
  def runExpression(object expression) (
    switch expression.kind (
      case "call"
        local func @= self.runExpression(expression.func)
        local args @= []
        for i expression.args.len (
          void args.append(self.runExpression(expression.args[i]))
        )
        return func.callFunc(self, args) ?? rtr.value.RTRNullValue()
      case "decl"
        local val @= self.runExpression(expression.val)
        
        void self.declScopeVar(expression.tar, val, {
          type: val.getRtrType()
        })
        
        return val
      case "asi"
        local val @= self.runExpression(expression.val)
        
        local existingMeta = null
        local existing = null
        switch expression.tar.kind (
          case "var"
            existingMeta @= self.getScopeVarMeta(expression.tar.name)
            existing @= self.getScopeVar(expression.tar.name)
            break
          case "prop"
            existing @= self.runExpression(expression.tar)
            break
        )
        
        if expression.op != null (
          val @= self.runBinary(existing, expression.op, val)
        )
        
        switch expression.tar.kind (
          case "var"
            if existingMeta != null (
              local curType @= val.getRtrType()
              if existingMeta.type != null (
                if !existingMeta.type.isEqual(curType) (
                  throw "cannot assign" + curType.stringify() + "to" + existingMeta.type.stringify() + "variable" 
                )
              )
            )
            void self.setScopeVar(expression.tar.name, val)
            break
          case "prop"
            local obj @= self.runExpression(expression.tar.obj)
            local key @= expression.tar.key
            if typeof(key) == "string" (
              key @= rtr.value.RTRStrValue(key)
            ) else (
              key @= self.runExpression(key)
            )
            void obj.setItem(key, val)
            break
          default
            throw "cannot assign to" + expression.tar.kind
        )
        
        return val
      case "unary"
        local val @= self.runExpression(expression.expr)
        return self.runUnary(expression.type, val)
      case "binary"
        local left @= self.runExpression(expression.left)
        local right @= self.runExpression(expression.right)
        return self.runBinary(left, expression.op, right)
      
      case "var"
        local val @= self.getScopeVar(expression.name)
        return val ?? rtr.value.RTRNullValue()
      case "prop"
        local obj @= self.runExpression(expression.obj)
        local key @= expression.key
        if typeof(key) == "string" (
          key @= rtr.value.RTRStrValue(key)
        ) else (
          key @= self.runExpression(key)
        )
        return obj.getItem(key) ?? rtr.value.RTRNullValue()
      
      case "str"
        return rtr.value.RTRStrValue(expression.val)
      case "num"
        return rtr.value.RTRNumValue(expression.val)
      case "func"
        return rtr.value.RTRAstFuncValue(expression.args, expression.body)
      case "arr"
        return rtr.value.RTRArrValue(expression.elems.map(e -> self.runExpression(e)))
      case "obj"
        local val @= {}
        for i expression.pairs.len (
          local pair @= expression.pairs[i]
          val[pair.name] @= self.runExpression(pair.value)
        )
        return rtr.value.RTRObjValue(val)
      case "color"
        return rtr.value.RTRColorValue(expression.val)
      
      default
        throw "unknown expression type" + expression.kind
    )
  )
  def runUnary(string op, object val) (
    switch op (
      case "-"
        return rtr.value.RTRNumValue(-val.numbify())
      case "+"
        return rtr.value.RTRNumValue(val.numbify())
      case "!"
        return rtr.value.RTRBoolValue(!val.boolify())
      case "?"
        return rtr.value.RTRBoolValue(val.boolify())
    )
    return rtr.value.RTRNullValue()
  )
  def runBinary(object left, string op, object right) (
    local numT @= rtr.value.RTRNumValue.getRtrType()
    switch op (
      case "+"
        if left.getRtrType().isEqual(numT) and right.getRtrType().isEqual(numT) (
          return rtr.value.RTRNumValue(left.numbify() + right.numbify())
        )
        return rtr.value.RTRStrValue(left.stringify() ++ right.stringify())
      case "-"
        if left.getRtrType().isEqual(numT) and right.getRtrType().isEqual(numT) (
          return rtr.value.RTRNumValue(left.numbify() - right.numbify())
        )
        return rtr.value.RTRNumValue(NaN)
      case "*"
        if left.getRtrType().isEqual(numT) and right.getRtrType().isEqual(numT) (
          return rtr.value.RTRNumValue(left.numbify() * right.numbify())
        )
        return rtr.value.RTRNumValue(NaN)
      case "/"
        if left.getRtrType().isEqual(numT) and right.getRtrType().isEqual(numT) (
          return rtr.value.RTRNumValue(left.numbify() / right.numbify())
        )
        return rtr.value.RTRNumValue(NaN)
      case "%"
        if left.getRtrType().isEqual(numT) and right.getRtrType().isEqual(numT) (
          return rtr.value.RTRNumValue(left.numbify() % right.numbify())
        )
        return rtr.value.RTRNumValue(NaN)
      case "^"
        if left.getRtrType().isEqual(numT) and right.getRtrType().isEqual(numT) (
          return rtr.value.RTRNumValue(left.numbify() ^ right.numbify())
        )
        return rtr.value.RTRNumValue(NaN)
      
      case "=="
        return rtr.value.RTRBoolValue(left.isEqual(right))
      case "!="
        return rtr.value.RTRBoolValue(left.isEqual(right))
      
      case ">"
        return rtr.value.RTRBoolValue(left.numbify() > right.numbify())
      case "<"
        return rtr.value.RTRBoolValue(left.numbify() < right.numbify())
      case ">="
        return rtr.value.RTRBoolValue(left.numbify() >= right.numbify())
      case "<="
        return rtr.value.RTRBoolValue(left.numbify() <= right.numbify())
    
      case "??"
        return left.getRtrType().data.name == "null" ? right left
    )
    
    return rtr.value.RTRNullValue()
  )
  
  def runInstructions(array instructions) (
    self.stack ??= []
    
    local labels @= {}
    
    for i instructions.len (
      local instruction @= instructions[i]
      if instruction.kind == "label" (
        labels[instruction.name] = i
      )
    )
    
    local i = 0
    local iters = 0
    while i < instructions.len and iters < 1000 (
      i ++
      iters ++
      local instruction @= instructions[i]
      //log i iters instruction self.stack.map(s -> s.stringify())
      switch instruction.kind (
        case "label"; break
        case "jump"
          i = labels[instruction.label] ?? i
          break
        case "jumpIf"
          local val @= self.stack.pop() ?? rtr.value.RTRNullValue()
          if val.boolify() (
            i = labels[instruction.label] ?? i
          )
          break
        case "jumpNotIf"
          local val @= self.stack.pop() ?? rtr.value.RTRNullValue()
          if !val.boolify() (
            i = labels[instruction.label] ?? i
          )
          break
        
        case "call"
          local args @= []
          loop instruction.args (
            void args.prepend(self.stack.pop() ?? rtr.value.RTRNullValue())
          )
          local func @= self.stack.pop() ?? rtr.value.RTRNullValue()
          local out @= func.callFunc(self, args) ?? rtr.value.RTRNullValue()
          if self.returnVal != null (
            local out @= self.returnVal
            self.returnVal = null
          )
          void self.stack.append(out)
          break
        case "unary"
          local val @= self.stack.pop() ?? rtr.value.RTRNullValue()
          void self.stack.append(self.runUnary(instruction.op, val))
          break
        case "binary"
          local right @= self.stack.pop() ?? rtr.value.RTRNullValue()
          local left @= self.stack.pop() ?? rtr.value.RTRNullValue()
          void self.stack.append(self.runBinary(left, instruction.op, right))
          break
        case "prop"
          local key @= self.stack.pop() ?? rtr.value.RTRNullValue()
          local obj @= self.stack.pop() ?? rtr.value.RTRNullValue()
          void self.stack.append(obj.getItem(key))
          break
        case "len"
          local obj @= self.stack.pop() ?? rtr.value.RTRNullValue()
          void self.stack.append(rtr.value.RTRNumValue(obj.length()))
          break
          
        case "null"
          void self.stack.append(rtr.value.RTRNullValue())
          break
        case "str"
          void self.stack.append(rtr.value.RTRStrValue(instruction.data))
          break
        case "bool"
          void self.stack.append(rtr.value.RTRBoolValue(instruction.data))
          break
        case "num"
          void self.stack.append(rtr.value.RTRNumValue(instruction.data))
          break
        case "func"
          void self.stack.append(rtr.value.RTRBytecodeFuncValue(instruction.args, instruction.body))
          break
        case "arr"
          local elems @= []
          loop instruction.elems (
            void elems.prepend(self.stack.pop() ?? rtr.value.RTRNullValue())
          )
          void self.stack.append(rtr.value.RTRArrValue(elems))
          break
        case "obj"
          local values @= []
          loop instruction.keys.len (
            void values.prepend(self.stack.pop() ?? rtr.value.RTRNullValue())
          )
          
          local obj @= {}
          for obji values.len (
            obj[instruction.keys[obji]] @= values[obji]
          )
          void self.stack.append(rtr.value.RTRObjValue(obj))
          break
        case "color"
          void self.stack.append(rtr.value.RTRColorValue(instruction.data))
          break
        
        case "get"
          local val @= self.getScopeVar(instruction.name) ?? rtr.value.RTRNullValue()
          void self.stack.append(val)
          break
        case "decl"
          local val @= self.stack[-1] ?? rtr.value.RTRNullValue()
          void self.declScopeVar(instruction.name, val, {
            type: val.getRtrType()
          })
          break
        case "newScope"
          void self.newScope({})
          break
        case "popScope"
          void self.popScope()
          break
        
        case "asivar"
          local val @= self.stack[-1] ?? rtr.value.RTRNullValue()
          
          local existingMeta @= self.getScopeVarMeta(instruction.name)
          local existing @= self.getScopeVar(instruction.name)
          
          if instruction.op != null (
            val @= self.runBinary(existing, instruction.op, val)
          )
          
          local curType @= val.getRtrType()
          if existingMeta.type != null (
            if !existingMeta.type.isEqual(curType) (
              // replace with return err
              throw "cannot assign" + curType.stringify() + "to" + existingMeta.type.stringify() + "variable" 
            )
          )
          
          void self.setScopeVar(instruction.name, val)
          break
        case "asiprop"
          local key @= self.stack.pop() ?? rtr.value.RTRNullValue()
          local obj @= self.stack.pop() ?? rtr.value.RTRNullValue()
          
          local val @= self.stack[-1] ?? rtr.value.RTRNullValue()
          if instruction.op != null (
            val @= self.runBinary(obj.getItem(key), instruction.op, val)
          )
          
          void obj.setItem(key, val)
          break
        
        case "pop"
          void self.stack.pop()
          break
        case "dupe"
          void self.stack.append(self.stack[instruction.i])
          break
        
        default
          return rtr.error.Error("UnknownInstructionKind", { kind: instruction.kind })
      )
      
    )
    
    return rtr.value.RTRNullValue()
  )
)

class RTR (
  def init() (
    self.modules @= {}
    self.console @= []
    self.ouid = OuidNew()
    
    self.started = false
  )

  def addModule(object mod) (
    local key @= OuidNew()
    mod.inst @= self
    self.modules[key] @= mod
    return key
  )
  
  def startModules() (
    if !self.started (
      self.started = true
      void self.runEvent({
       name: "onload"
      }, {})
    )
  )
  
  def runEvent(object target, object data) (
    local mods @= self.modules.getValues()
    for i mods.len (
      void mods[i].runEvent(target, data)
    )
  )
  def runEvents(object target, object data) (
    local mods @= self.modules.getValues()
    for i mods.len (
      void mods[i].runEvents(target, data)
    )
  )
)

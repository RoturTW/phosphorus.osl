[".folder","phosphorus",[[".folder","archive",[[".osl","devtools","\ndef drawElement(object element) (\n  self.y -= 15\n  goto 0 self.y\n  square frame.width - 15 30 - 15 10 : c#shared.theme.back hover_c#shared.theme.prim\n  \n  element.dvt_open ??= false\n  \n  if element.children != null or element.kind == \"script\" (\n    goto frame.left + 15 + self.x self.y\n    square 20 20 0 0 1 : c#fff\n    if mouse_touching (\n      cursor \"pointer\"\n      if onclick (\n        element.dvt_open = !element.dvt_open\n      )\n    )\n    icon element.dvt_open ? \"down\" \"right\" .5 : c#shared.theme.text\n    \n    text element.blockName ?? element.name 10 : chx#15\n    \n    self.x += self.indent\n    self.y -= 15\n    \n    if element.dvt_open (\n      if element.kind == \"script\" (\n        local content = element.body\n        local lines @= content.split(\"\\n\")\n        local line_height = 15\n        local height = lines.len - 1 * line_height + 10\n        \n        self.y -= height / 2\n        goto 0 self.y\n        square frame.width - 15 height - 15 10 : c#shared.theme.back hover_c#shared.theme.prim\n        self.y += height / 2\n        \n        self.y -= 5\n        \n        for i lines.len (\n          self.y -= line_height / 2\n          goto frame.left + 15 + self.x self.y\n          text lines[i].trimText(frame.right - x_position - 17.5 / 8) 8 : c#shared.theme.text\n          self.y -= line_height / 2\n        )\n        \n        self.y -= height\n      ) else (\n        drawElements(element.children)\n      )\n    ) else (\n      // todo\n    )\n    \n    self.x -= self.indent\n  ) else (\n    self.y -= 15\n  )\n)",""],[".osl","url-old","\n  def parse(string text) (\n    local scheme = shared.config.url.defaults.scheme\n    local name = shared.config.url.defaults.name\n    local top = shared.config.url.defaults.top\n    local sub = null\n    local path = null\n    local resource = \"index.rwl\"\n    \n    local tokens = text.split(\"://\")\n    if tokens.len > 1 (\n      scheme = tokens.shift()\n      text = tokens.join(\"://\")\n    )\n    \n    if scheme == \"local\" (\n      self.scheme = scheme\n      self.domain_name = text\n      self.domain_top = null\n      self.domain_sub = null\n      self.path = null\n      self.params @= {}\n      self.resource = null\n      return\n    )\n    \n    tokens = text.split(\"/\")\n    if tokens.len == 0 (\n      tokens @= [text]\n    )\n    if tokens[-1].split(\".\").len > 1 (\n      resource = tokens.pop()\n    )\n    path = tokens.join(\"/\")\n    \n    text = tokens.shift() ?? \"\"\n    \n    tokens = text.split(\".\")\n    if tokens.len == 1 (\n      name = tokens[1]\n    )\n    if tokens.len == 2 (\n      top = tokens[2]\n      name = tokens[1]\n    )\n    if tokens.len >= 2 (\n      top = tokens.pop()\n      name = tokens.pop()\n      sub = tokens.join(\".\")\n    )\n    \n    self.scheme = scheme\n    self.domain_name = name\n    self.domain_top = top\n    self.domain_sub = sub\n    self.path = path\n    self.params @= {}\n    self.resource = resource\n  )",""],[".osl","rtrtest","\n// import overwrite\n__import @= import;import @= i -> (i.endsWith(\".osl\") ? __import(i) open(i))\n\nobject rtr @= {\n  main: import(\"./src/rtr/main.osl\"),\n  ast: import(\"./src/rtr/ast.osl\"),\n  error: import(\"./src/rtr/error.osl\"),\n  value: import(\"./src/rtr/value.osl\"),\n  compiler: import(\"./src/rtr/compiler.osl\"),\n  instruction: import(\"./src/rtr/instruction.osl\")\n}\n\nlocal ast @= rtr.ast.Parser(import(\"./compiletest.rtr\"))\n\nlocal out @= rtr.compiler.compileBlock(ast.parse().elements[1].body)\nif typeof(out) != \"array\" and out.isError (\n  log out.stringify()\n) else (\n  //log \"instructions\" out\n  \n  local inst @= rtr.main.RTR()\n  local mod @= rtr.main.Module({ elements: [] })\n  void inst.addModule(mod)\n  \n  local out @= mod.runInstructions(out) ?? rtr.value.RTRNullValue()\n  if typeof(out) != \"array\" and out.isError (\n    log out.stringify()\n  ) else (\n    if out.stringify() != \"<null>\" (\n      log \"out\" out.stringify()\n    )\n    log \"stack\" mod.stack\n  )\n)",""]],"c #303030 square 0 2 10 4 c #7a7a7a square -8 6 2 2 line -5 7 3 0 square 0 -1 10 5 w 8 square 0 -0.5 5 0"],[".folder","packages",[],"c #7a1212 square 0 2 10 4 c #f24b4b square -8 6 2 2 line -5 7 3 0 square 0 -1 10 5 w 8 square 0 -0.5 5 0"],[".folder","build",[[".osl","script-summit","build @= { built: true, package: {\"name\":\"summit\",\"version\":\"1.0.0a\",\"description\":\"rotur web engine\",\"main\":\"script.osl\",\"dependencies\":{},\"tags\":[],\"include\":[\"./main.rwl\",\"./test.rwl\",\"./sidebartest.rwl\"],\"phosphorus\":{\"layout\":\"summit\",\"hasDevtools\":true},\"scripts\":{\"opaljson-summit\":\"osl ./scripts/opal_summit.osl\",\"opaljson-chromeLike\":\"osl ./scripts/opal_chromeLike.osl\",\"opaljson-reset\":\"osl ./scripts/opal_reset.osl\",\"build-summit\":[\"fpp script opaljson-summit\",\"fpp build\",\"rm build/script-summit.osl\",\"mv build/script.osl build/script-summit.osl\",\"echo \\\"summit build complete!\\\"\"],\"build-chromeLike\":[\"fpp script opaljson-chromeLike\",\"fpp build\",\"rm build/script-chromeLike.osl\",\"mv build/script.osl build/script-chromeLike.osl\",\"echo \\\"chromeLike build complete!\\\"\"],\"build\":[\"fpp script build-summit\",\"fpp script build-chromeLike\",\"fpp script opaljson-reset\"]}} }\nopal_imports = {}\ndef import(path) (\n  switch path (\n\ncase \"./src/assets/settings.rwl\"\n  return \"  root {\\n    frame [Horizontal, color=theme:prim] {\\n      section [id=\\\"sidebar\\\", size=150] {\\n        \\n      },\\n      section {\\n        frame [Vertical] {\\n          section [size=40, padding=10] {\\n            \\\"loading...\\\" [\\n              id=\\\"location\\\",\\n              color=theme:text,\\n              size=12, anchor=\\\"l\\\"\\n            ]\\n          },\\n          section [color=theme:back, rounding_tl=10] {\\n            \\n          }\\n        }\\n      }\\n    },\\n    \\n    script {\\n      event(onload) {\\n        setLocation := (text) ~ {\\n          document.getElement(\\\"location\\\").text = text;\\n        };\\n        setLocation(\\\"bleh\\\");\\n        \\n        sidebar := document.getElement(\\\"sidebar\\\");\\n        \\n        categories := $$brwsr.settings.getCategories();\\n        i := 0;\\n        for (category, categories) {\\n          i += 1;\\n          buttonElem := document.createContainer(\\\"button\\\");\\n          \\n          buttonElem.margin = 7.5;\\n          if (i == 1) {\\n            buttonElem.anchor = \\\"tl\\\";\\n            buttonElem.margin_t = 10;\\n          } else {\\n            buttonElem.margin_t = 0;\\n          }\\n          buttonElem.height = 35;\\n          buttonElem.rounding = 10;\\n          buttonElem.hover_color = theme.seco;\\n          buttonElem.id = \\\"cat_\\\" + category;\\n          \\n          titleElem := document.createTextElement(toTitle(category));\\n          titleElem.color = theme.text;\\n          titleElem.size = 11;\\n          \\n          buttonElem.addChild(titleElem);\\n          script := document.createScript(join(\\n            \\\"setLocation := (text) ~ {document.getElement(\\\\\\\"location\\\\\\\").text = text;};\\\\n\\\",\\n            \\\"event(#\\\" + buttonElem.id + \\\":click) {\\\\n\\\",\\n            \\\"  setLocation(\\\\\\\"\\\" + buttonElem.id + \\\"\\\\\\\");\\\\n\\\",\\n            \\\"}\\\\n\\\"\\n          ));\\n          buttonElem.addChild(script);\\n          \\n          sidebar.addChild(buttonElem);\\n        }\\n      }\\n    }\\n  }\"\n\ncase \"./src/devtools/menus/compiled.osl\"\n  class __imports__c2496c7321897b9bfcdc4b07bd6e8f28 (\n    number offsetX = 0\n    boolean exit = false\n    selectedCode = null\n    \n    object highlighting = {\n      program_flow: {\n        color: #ff4b19,\n        names: [\n          \"label\",\n          \n          \"jump\",\n          \"jumpIf\",\n          \"jumpNotIf\"\n        ]\n      },\n      operations: {\n        color: #ff8119,\n        names: [\n          \"call\",\n          \"unary\",\n          \"binary\",\n          \"prop\",\n          \"len\",\n          \n          \"asivar\",\n          \"asiprop\"\n        ]\n      },\n      values: {\n        color: #52e342,\n        names: [\n          \"null\",\n          \"str\",\n          \"bool\",\n          \"num\",\n          \"func\",\n          \"arr\",\n          \"obj\",\n          \"color\"\n        ]\n      },\n      scope: {\n        color: #00edb6,\n        names: [\n          \"get\",\n          \"decl\",\n          \n          \"newScope\",\n          \"popScope\"\n        ]\n      },\n      stack: {\n        color: #cd27e3,\n        names: [\n          \"pop\",\n          \"dupe\"\n        ]\n      }\n    }\n    \n    object colors = {\n      label: #34eb9b,\n      str: #eba434,\n      num: #34eb3a,\n      bool: #537aed,\n      col: #73a7f0,\n      var: #cf8846\n    }\n    \n    def getInst() (\n      return layouts.shared.state.currentDocument.rtrInst\n    )\n    \n    def topbar() (\n      if self.selectedCode == null (\n        self.topbarHeight = -1\n      ) else (\n        self.topbarHeight = null\n        \n        goto frame.left + 10 0\n        square 15 15 0 0 1\n        if mouse_touching (\n          cursor \"pointer\"\n          if onclick (\n            self.exit = true\n            self.topbarHeight = -1\n          )\n        )\n        icon \"left\" .5 : c#shared.theme.text\n        \n        change_x 15\n        \n        c shared.theme.prim\n        pen \"size\" 2\n        change_y 11\n        pen \"down\"\n        change_y -22\n        pen \"up\"\n        change_y 11\n        \n        change_x 7.5\n        drawLoc(self.selectedCode)\n      )\n    )\n    \n    def update() (\n      if !shared.config.browser.phosphorus.useCompiler (\n        goto 0 0\n        centext \"compiler disabled\" 10 : c#shared.theme.prim\n        return\n      )\n      \n      local inst @= self.getInst()\n      \n      if self.selectedCode == null (\n        // selector screen\n        local y = frame.top\n        \n        if inst.compiled != null (\n          for i inst.compiled.len (\n            local comp @= inst.compiled[i]\n            \n            y -= 15\n            goto frame.left + 7.5 y\n            \n            drawLoc(comp)\n            \n            goto frame.right + 16 y\n            square 10 10 12 : chx#-30 c#shared.theme.prim hover_c#shared.theme.seco\n            if mouse_touching (\n              cursor \"pointer\"\n              if onclick (\n                self.selectedCode @= comp\n              )\n            )\n            icon \"open\" .6 : c#shared.theme.text\n            \n            y -= 15\n            goto 0 y\n            pen \"size\" 2\n            line frame.left 0 frame.right 0 : c#shared.theme.prim\n          )\n        ) else (\n          goto 0 0\n          centext \"nothing compiled\" 10 : c#shared.theme.prim\n        )\n      ) else (\n        self.y = frame.top + frame.scroll\n        local start = self.y\n        self.offsetX = 0\n        drawInstructions(self.selectedCode.body, frame.left + 15)\n        self.height = start - self.y - 10\n      )\n      if self.exit (\n        self.exit = false\n        self.selectedCode = null\n      )\n    )\n    \n    def drawLoc(object comp) (\n      local txt = comp.start.loc ?? \"unknown\"\n      txt += comp.start.ln\n      txt ++= \":\"\n      txt ++= comp.start.char\n      txt += \"-\"\n      txt += comp.end.ln\n      txt ++= \":\"\n      txt ++= comp.end.char\n      text txt 10 : c#shared.theme.text\n    )\n    \n    def drawInstructions(array instructions, number x) (\n      for i instructions.len (\n        if instructions[i] != null (\n          drawInstruction(instructions[i], x, instructions, i)\n        )\n      )\n    )\n    \n    def drawInstruction(object instruction, number x, array instructions, number i) (\n      local height = 25\n      instruction.editorX = x\n      \n      self.y -= height / 2\n      instruction.editorY = self.y\n      \n      if instruction.kind == \"popScope\" (\n        self.offsetX -= 10\n      )\n      \n      if !(self.y - height > frame.top or self.y < frame.bottom) (\n        local fromleft = x + self.offsetX - frame.left\n        goto fromleft / 2 self.y\n        square frame.width - fromleft height 0 0 1\n        if mouse_touching (\n          change_x -2.5\n          square frame.width - fromleft - 15 height - 15 10 : c#shared.theme.prim\n        \n          local corresponding = self.getCorresponding(instructions, i)\n          if corresponding != null (\n            // \"arrow\" | \"point\"\n            local look = \"arrow\"\n            c shared.theme.tert\n            goto x + self.offsetX self.y\n            if look == \"point\" (\n              pen \"size\" 7.5\n              pen \"down\"\n              pen \"up\"\n            )\n            pen \"size\" 2.5\n            pen \"down\"\n            goto x + self.offsetX - 7.5 self.y\n            goto x + self.offsetX - 7.5 corresponding.editorY\n            goto x + self.offsetX corresponding.editorY\n            pen \"up\"\n            if look == \"point\" (\n              pen \"size\" 7.5\n              pen \"down\"\n              pen \"up\"\n            )\n            if look == \"arrow\" (\n              change_x 2\n              pen \"down\"\n              change -4 4\n              change 4 -4\n              change -4 -4\n              pen \"up\"\n            )\n          )\n        )\n        \n        goto x + 5 + self.offsetX self.y\n        \n        c shared.theme.text\n        local categories @= self.highlighting.getValues()\n        for i categories.len (\n          if categories[i].names.contains(instruction.kind) (\n            c categories[i].color\n          )\n        )\n        \n        text instruction.kind 9\n        \n        void self.drawData(instruction)\n      )\n      \n      self.y -= height / 2\n      \n      if instruction.kind == \"func\" (\n        drawInstructions(instruction.body, x + 20)\n      )\n      \n      if instruction.kind == \"newScope\" (\n        self.offsetX += 10\n      )\n    )\n    \n    def drawData(object instruction) (\n      switch instruction.kind (\n        case \"label\"\n          drawLabel(instruction.name)\n          break\n        case \"jump\"; case \"jumpIf\"; case \"jumpNotIf\";\n          drawLabel(instruction.label)\n          break\n        \n        case \"call\"\n          drawArgName(\"args\")\n          drawNum(instruction.args)\n          break\n        case \"unary\"; case \"binary\"\n          drawStr(instruction.op)\n          break\n        \n        case \"str\"\n          drawStr(instruction.data)\n          break\n        case \"num\"\n          drawNum(instruction.data)\n          break\n        case \"bool\"\n          drawBool(instruction.data)\n          break\n        case \"func\"\n          drawArgs(instruction.args)\n          break\n        case \"arr\"\n          drawArgName(\"elems\")\n          drawNum(instruction.elems)\n          break\n        case \"obj\"\n          drawArr(instruction.keys)\n          break\n        case \"color\"\n          drawColor(instruction.data)\n          break\n        \n        case \"get\"\n          drawVar(instruction.name)\n          break\n        case \"decl\"\n          drawVar(instruction.name)\n          break\n        \n        case \"asivar\"\n          if instruction.op != null (\n            drawStr(instruction.op)\n          )\n          drawVar(instruction.name)\n          break\n        case \"asiprop\"\n          if instruction.op != null (\n            drawStr(instruction.op)\n          )\n          break\n        \n        case \"dupe\"\n          drawArgName(\"idx\")\n          drawNum(instruction.i)\n          break\n      )\n    )\n    \n    def drawArgName(string name) (\n      text name 9 : c#shared.theme.text chx#7.5\n      text \"=\" 9 : chx#5\n      change_x -2.5\n    )\n    \n    def drawStr(string str) (\n      text str.JsonStringify() 9 : c#self.colors.str chx#7.5\n    )\n    def drawNum(number num) (\n      text num 9 : c#self.colors.num chx#7.5\n    )\n    def drawBool(boolean bool) (\n      text bool.toStr() 9 : c#self.colors.bool chx#7.5\n    )\n    def drawColor(string col) (\n      text col 9 : c#self.colors.col chx#7.5\n    )\n    def drawArr(array arr) (\n      text arr.join(\" \") 9 : c#shared.theme.text chx#7.5\n    )\n    def drawArgs(array args) (\n      text args.map(a -> \"@\" ++ a.name).join(\" \") 9 : c#self.colors.var chx#7.5\n    )\n    def drawVar(string name) (\n      text \"@\" ++ name 9 : c#self.colors.var chx#7.5\n    )\n    def drawLabel(string name) (\n      text \"#\" ++ name 9 : c#self.colors.label chx#7.5\n    )\n    \n    def getCorresponding(array instructions, number i) (\n      local cur @= instructions[i]\n      \n      if cur.kind == \"newScope\" (\n        local depth = 0\n        while i < instructions.len (\n          i ++\n          local instruction @= instructions[i]\n          if instruction.kind == \"newScope\" (\n            depth ++\n          )\n          if instruction.kind == \"popScope\" (\n            if depth == 0 (\n              return instruction\n            )\n            depth --\n          )\n        )\n      )\n      if cur.kind == \"popScope\" (\n        local depth = 0\n        while i > 0 (\n          i --\n          local instruction @= instructions[i]\n          if instruction.kind == \"newScope\" (\n            if depth == 0 (\n              return instruction\n            )\n            depth ++\n          )\n          if instruction.kind == \"popScope\" (\n            depth --\n          )\n        )\n      )\n      \n      if [\"jump\",\"jumpIf\",\"jumpNotIf\"].contains(cur.kind) (\n        for i instructions.len (\n          local instruction @= instructions[i]\n          if instruction.kind == \"label\" (\n            if instruction.name == cur.label (\n              return instruction\n            )\n          )\n        )\n      )\n    )\n  )\n  return __imports__c2496c7321897b9bfcdc4b07bd6e8f28\ncase \"./src/devtools/menus/storage.osl\"\n  class __imports__968375a74382766e626cb371cd10b43a (\n    \n  )\n  return __imports__968375a74382766e626cb371cd10b43a\ncase \"./src/devtools/menus/network.osl\"\n  class __imports__b4ec205ca81f7630cd7f76511fd744fb (\n    \n  )\n  return __imports__b4ec205ca81f7630cd7f76511fd744fb\ncase \"./src/devtools/menus/console.osl\"\n  class __imports__ac7f1c744ff0d794c130cdf96196926d (\n    def getInst() (\n      return layouts.shared.state.currentDocument.rtrInst\n    )\n    \n    def topbar() (\n      local inst @= self.getInst()\n      \n      goto frame.left + 10 0\n      square 15 15 0 0 1\n      if inst != null (\n        if mouse_touching (\n          cursor \"pointer\"\n          if onclick (\n            inst.console @= []\n          )\n        )\n        c shared.theme.text\n      ) else (\n        if mouse_touching (\n          cursor \"not-allowed\"\n        )\n        c shared.theme.seco\n      )\n      icon \"w 2.5 cutcircle 0 0 10 0 180 line -6 -6 6 6\" .7\n    )\n    \n    def update() (\n      local inst @= self.getInst()\n      \n      local y = frame.top + frame.scroll\n      local start = y\n      \n      for ii inst.console.len (\n        local item @= inst.console[ii]\n        local lines @= item[2].wrapText(frame.width - 10 / 10).split(\"\\n\")\n        local height = lines.len * 20\n        \n        local col = null\n        if item[1] == \"err\" or item[1] == \"repl-err\" (\n          col = #f00\n        )\n        \n        local ly = y\n        local sy = y\n        \n        y -= 5\n        y -= height\n        y -= 5\n        \n        if col != null (\n          frame frame.left y frame.right ly (\n            c col\n            pen \"opacity\" 20\n            pen \"size\" 10000\n            pen \"down\"\n            pen \"up\"\n          )\n        )\n        \n        local offsetX = 5\n        \n        if item[1].startsWith(\"repl\") (\n          goto frame.left + offsetX + 5 ly - 15\n          \n          if item[1] == \"repl-in\" (\n            icon \"right\" .5 : c#shared.theme.text\n          )\n          if item[1] == \"repl-ret\" (\n            icon \"left\" .5 : c#shared.theme.text\n          )\n          if item[1] == \"repl-err\" (\n            icon \"left\" .5 : c#shared.theme.text\n          )\n          offsetX += 20\n        )\n        \n        c shared.theme.text\n        for i lines.len (\n          ly -= 10\n          goto frame.left + offsetX ly - 5\n          text lines[i] 10\n          ly -= 10\n        )\n        \n        pen \"size\" 2 : c#shared.theme.prim\n        \n        goto 0 sy\n        line frame.left 0 frame.right 0\n        \n        goto 0 y\n        line frame.left 0 frame.right 0\n      )\n      \n      // repl\n      y -= 15\n      goto frame.left + 12.5 y\n      icon \"right\" .5 : c#shared.theme.text\n      \n      local inputId = \"devtools_repl_\" ++ inst.ouid\n      goto 12.5 y\n      input frame.width - 35 30 inputId null 0 shared.theme.text : c#shared.theme.back\n      \n      if \"enter\".onKeyDown() and inputs.selected.id == inputId (\n        local inp = inputs[inputId]\n        \n        void inst.console.append([\"repl-in\", inp])\n        \n        promiseData = inp\n        promiseData2 @= inst\n        self.runPromise @= Promise.new(def() -> (\n          local parser @= rtr.ast.Parser(\"event(onload){return(\" ++ promiseData ++ \");}\")\n          self.ast @= parser.parse()\n          self.mod @= rtr.main.Module(self.ast)\n          void rtr.apis.main.addToMod(layouts.shared.state.currentDocument, self.mod)\n          void promiseData2.addModule(self.mod)\n          local ret @= mod.runEventRaw({\n            name: \"onload\"\n          }, {})\n          return ret\n        ))\n        \n        inputs[inputId] = \"\"\n      )\n      \n      if self.runPromise != null (\n        local ret @= self.runPromise.worker.return\n        if ret != null (\n          void inst.console.append([\"repl-ret\", ret.stringify(true)])\n          self.runPromise = null\n        )\n      )\n      \n      y -= 15\n      \n      self.height = start - y - 10\n    )\n  )\n  return __imports__ac7f1c744ff0d794c130cdf96196926d\ncase \"./src/devtools/menus/elements.osl\"\n  class __imports__7de0f89117b2e081473955ae82bcf430 (\n    number indent = 20\n    \n    number x = 0\n    number y = 0\n    \n    number maxX = 0\n    \n    def drawElements(array elements) (\n      for i elements.len (\n        if elements[i] != null (\n          drawElement(elements[i])\n        )\n        if i < elements.len (\n          text \",\" 10\n        )\n      )\n    )\n    \n    def drawElement(object element) (\n      if element.children != null or element.kind == \"script\" (\n        self.y -= 15\n        goto 0 self.y\n        \n        element.dvt_open ??= false or true\n        \n        goto self.x self.y\n        square 20 20 0 0 1 : c#fff\n        if mouse_touching (\n          cursor \"pointer\"\n          if onclick (\n            element.dvt_open = !element.dvt_open\n          )\n        )\n        icon element.dvt_open ? \"down\" \"right\" .5 : c#shared.theme.text\n        \n        text element.blockName ?? element.name 10 : chx#15\n        if mouse_touching (\n          cursor \"pointer\"\n          devtools.main.hoveredElement = element.elemI\n          if onclick (\n            element.dvt_open = !element.dvt_open\n          )\n        )\n        \n        drawHeader(element.header)\n        \n        self.y -= 15\n        \n        if element.dvt_open (\n          text \"{\" 10 : chx#10\n          self.maxX = max(self.maxX, x_position)\n          self.x += self.indent\n          \n          if element.kind == \"script\" (\n            local content = element.body\n            local lines @= content.split(\"\\n\")\n            local line_height = 25\n            local height = lines.len - 1 * line_height + 5\n            \n            local cy = self.y - 2.5\n            self.y -= height\n            \n            for i lines.len (\n              cy -= line_height / 2\n              \n              goto self.x cy\n              \n              //self.maxX = max(self.maxX, x_position + (lines[i].len * 10))\n              //text lines[i].trimText(frame.right - x_position - 17.5 / 8) 10 : c#shared.theme.text\n              text lines[i] 10 : c#shared.theme.text\n              \n              cy -= line_height / 2\n            )\n          ) else (\n            drawElements(element.children)\n          )\n          \n          self.x -= self.indent\n          \n          self.y -= 15\n          goto self.x - 5 self.y\n          text \"}\" 10\n          self.y -= 15\n        ) else (\n          if element.kind == \"script\" (\n            text \"{\" 10 : chx#10\n            drawTooLong() : chx#10\n            text \"}\" 10 : chx#10\n          ) else (\n            text \"{\" 10 : chx#10\n            drawMiniChildren(element.children) : chx#10\n            text \"}\" 10 : chx#10\n          )\n          self.maxX = max(self.maxX, x_position)\n        )\n      ) else if element.kind == \"element\" (\n        self.y -= 15\n        goto self.x self.y\n        drawValue(element.value)\n        drawHeader(element.header)\n        local s = x_position\n        self.maxX = max(self.maxX, x_position)\n        local w = x_position - self.x\n        goto x_position + self.x / 2 self.y\n        square w 20 0 0 1\n        if mouse_touching (\n          devtools.main.hoveredElement = element.elemI\n        )\n        goto s self.y\n        self.y -= 15\n      ) else if element.kind == \"icon\" (\n        self.y -= 15\n        goto self.x self.y\n        text \"Icon\" 10\n        drawHeader(element.header)\n        self.maxX = max(self.maxX, x_position)\n        self.y -= 15\n      )\n    )\n    \n    def drawHeader(object header) (\n      if header.flags.len == 0 and header.pairs.len == 0 (\n        return\n      )\n      \n      change_x 7.5\n      text \"[\" 10\n      for i header.flags.len (\n        local flag = header.flags[i]\n        text flag 8\n        if i < header.flags.len or header.pairs.len > 0 (\n          text \", \" 8\n        )\n      )\n      \n      for i header.pairs.len (\n        local pair @= header.pairs[i]\n        text pair[1] 10\n        text \"=\" 8\n        drawValue(pair[2])\n        if i < header.pairs.len (\n          text \", \" 8\n        )\n      )\n      text \"]\" 10\n    )\n    \n    def drawValue(object value) (\n      switch value.type (\n        case \"str\"\n          text value.value.JsonStringify() 10\n          break\n        case \"num\"; case \"color\"\n          text value.value 10\n          break\n        case \"percentage\"\n          text value.value.toStr() ++ \"%\" 10\n          break\n      )\n    )\n    \n    def drawMiniChildren(array children) (\n      if children.len == 0 (\n        change_x -20\n        return\n      )\n      \n      change_x 5\n      for i children.len (\n        drawMiniChild(children[i])\n        if i < children.len (\n          text \", \" 8\n        )\n      )\n      change_x 5\n      \n      change_x -20\n    )\n    \n    def drawMiniChild(object element) (\n      if element.children != null or element.kind == \"script\" (\n        text element.blockName ?? element.name 7\n        text \"{\" 7 : chx#10\n        drawTooLong()\n        text \"}\" 7 : chx#20\n      ) else (\n        text \"Element\" 7\n      )\n    )\n    \n    def drawTooLong() (\n      text \"...\" 8 : chx#5\n      change_x -15\n    )\n    \n    def update() (\n      local document @= layouts.shared.state.currentDocument\n      local elements @= document.rwlInst.elements\n      if typeof(elements) != \"array\" (\n        elements @= []\n      )\n      \n      local s = frame.scroll_h * -1\n      self.x = frame.left + s + 15\n      local startX = self.x\n      self.y = frame.top + frame.scroll\n      local startY = self.y\n      \n      self.width = 0\n      self.maxX = 0\n      \n      if elements != null (\n        drawElements(elements)\n      )\n      \n      //self.width = self.maxX - startX\n      self.width = self.maxX - startX\n      self.height = startY - self.y + 5\n    )\n  )\n  return __imports__7de0f89117b2e081473955ae82bcf430\ncase \"./src/devtools/rightclick.osl\"\n  class __imports__0598a8fc1c085cefe2171384b023fe8b (\n    array topbar_more = [\n      [\"Dock\",\n        {\"left\": def() -> (\n          void shared.settings.set(\"devtools\", \"dockside\", \"l\")\n        )},\n        {\"right\": def() -> (\n          void shared.settings.set(\"devtools\", \"dockside\", \"r\")\n        )}\n      ]\n    ]\n  )\n  return __imports__0598a8fc1c085cefe2171384b023fe8b\ncase \"./src/devtools/topbar.osl\"\n  class __imports__3261b0e52c0051dec0dc6394c943d033 (\n    tabs_scroll = 0\n    tabs_width = 0\n    \n    def update() (\n      square frame.width frame.height 0 0 1\n      if mouse_touching (\n        self.tabs_scroll += scroll.x.velocity + scroll.y.velocity * -1.5 * scroll.multiplier\n      )\n      \n      self.tabs_scroll = min(self.tabs_scroll, self.tabs_width - frame.width)\n      self.tabs_scroll = max(self.tabs_scroll, 0)\n      \n      local x = frame.left - self.tabs_scroll\n      local start = x\n      local menus @= devtools.menus.getEntries()\n      for i menus.len (\n        local menu @= menus[i]\n        \n        local title = menu[1].toTitle()\n        local w = title.len * 8 + 10\n        \n        x += w / 2\n        \n        goto x 0\n        square w - 10 10 10 0 1\n        c devtools.main.menu == menu[1] ? shared.theme.seco shared.theme.prim\n        if mouse_touching (\n          c shared.theme.tert\n          cursor \"pointer\"\n          if onclick (\n            void shared.settings.set(\"devtools\", \"menu\", menu[1])\n          )\n        )\n        pen \"size\" 2\n        line w / -2 -11 w / 2 -11\n        centext title 8 : c#shared.theme.text\n        \n        x += w / 2\n      )\n      self.tabs_width = x - start\n    )\n  )\n  return __imports__3261b0e52c0051dec0dc6394c943d033\ncase \"./src/devtools/main.osl\"\n  class __imports__87f5572a1b07abb6f61e525f0557da7a (\n    string anchor = \"r\"\n    number width = 350\n    boolean open = false\n    \n    number saveWidth = 350\n    number resizingEdge = 0\n    \n    hoveredElement = 0\n    \n    string menu = \"console\"\n    \n    def alwaysUpdate() (\n      self.hoveredElement = 0\n    )\n    \n    def update(array area, array rawArea) (\n      goto rwl.area.centerX(area) rwl.area.centerY(area)\n      square rwl.area.width(area) - 10 rwl.area.height(area) - 10 10 : c#shared.theme.back\n      \n      local h = 25\n      frame area[1] area[4] area[3] area[4] - h (\n        goto 0 -5\n        square frame.width - 10 frame.height 10 : c#shared.theme.prim\n        \n        goto frame.right - 12.5 0\n        icon \"more-vertical\" .5 : c#shared.theme.text\n        if mouse_touching (\n          cursor \"pointer\"\n          if onclick (\n            local p @= Promise.new(() -> (\n              while mouse_down (\n                defer\n              )\n              open_rightclick devtools.rightclick.topbar_more\n            ))\n          )\n        )\n      )\n      frame area[1] area[4] area[3] - 25 area[4] - h (\n        void devtools.topbar.update()\n      )\n      \n      if mouse_y > area[2] and mouse_y < area[4] (\n        if anchor == \"r\" and abs(mouse_x - area[1]) < 5 (\n          cursor \"col-resize\"\n          goto mouse_x mouse_y\n          square 100 100 0 0 1\n          if onclick (\n            self.resizingEdge = 1\n          )\n        )\n        if anchor == \"l\" and abs(mouse_x - area[3]) < 5 (\n          cursor \"col-resize\"\n          goto mouse_x mouse_y\n          square 100 100 0 0 1\n          if onclick (\n            self.resizingEdge = 3\n          )\n        )\n      )\n      \n      if !mouse_down (\n        self.resizingEdge = 0\n      )\n      \n      if self.resizingEdge != 0 (\n        self.width = abs(mouse_x - area[4 - self.resizingEdge])\n      )\n      self.width = min(self.width, rwl.area.width(rawArea) - 200)\n      self.width = max(self.width, 200)\n      \n      local menu @= devtools.menus[self.menu]\n      \n      c shared.theme.prim\n      local topbarH = 0\n      if menu.topbar != null (\n        topbarH = menu.topbarHeight ?? 25\n        frame area[1] area[4] - h area[3] area[4] - h - topbarH (\n          void menu.topbar()\n        )\n        local w = rwl.area.width(area)\n        goto rwl.area.centerX(area) area[4] - h - topbarH\n        pen \"size\" 2\n        line w / -2 -1 w / 2 -1 : c#shared.theme.prim\n        topbarH += 1\n      )\n      \n      c shared.theme.prim\n      local bottombarH = 0\n      if menu.bottombar != null (\n        bottombarH = menu.bottombarHeight ?? 25\n        frame area[1] area[4] - h area[3] area[4] - h - bottombarH (\n          void menu.bottombar()\n        )\n        local w = rwl.area.width(area)\n        goto rwl.area.centerX(area) area[2] + bottombarH\n        pen \"size\" 2\n        line w / -2 1 w / 2 1 : c#shared.theme.prim\n        bottombarH += 1\n      )\n      \n      c shared.theme.prim\n      frame area[1] area[4] - h - topbarH area[3] area[2] + bottombarH [menu.width,menu.height] \"devtools_\" ++ self.menu (\n        if menu != null (\n          if menu.update != null (\n            void menu.update()\n          )\n        ) else (\n          goto 0 0\n          centext \"no open devtools menu\" 9 : c#shared.theme.prim\n        )\n      )\n    )\n  )\n  return __imports__87f5572a1b07abb6f61e525f0557da7a\ncase \"./src/layouts/summit/topbar.osl\"\n  class __imports__6a477e7780a631dfc33d414269cd6008 (\n    def update(array area) (\n      goto rwl.area.centerX(area) rwl.area.centerY(area)\n      square rwl.area.width(area) - 10 rwl.area.height(area) - 10 10 : c#shared.theme.back\n      \n      local btns @= layouts.shared.topbar.defaultButtons\n      void layouts.shared.topbar.winButtons(btns, false)\n      \n      local titlebarX = max(area[1], window.left + 30)\n      goto titlebarX + 10 rwl.area.centerY(area)\n      if layouts.shared.state.currentDocument != null (\n        local icn = layouts.shared.state.currentDocument.getIcon()\n        if icn != null (\n          icon icn 1 : c#fff chx#7.5\n          change_x 17.5\n        )\n        text layouts.shared.state.currentDocument.getTitle() 10 : c#shared.theme.text\n      )\n      \n      frame area[1] area[4] titlebarX area[2] (\n        goto 0 0\n        square frame.width - 5 25 0 0 1\n        if mouse_touching (\n          cursor \"pointer\"\n          if onclick (\n            layouts.summit.sidebar.open = true\n          )\n        )\n        icon \"right\" .6 : c#shared.theme.text chx#5\n      )\n    )\n  )\n  return __imports__6a477e7780a631dfc33d414269cd6008\ncase \"./src/layouts/summit/sidebar.osl\"\n  class __imports__3dfd082eaa91cc9b8340f13c6baac410 (\n    open_width = 250\n    \n    width = 200\n    tar_width = open_width\n    open = true\n    \n    def update(array area) (\n      goto rwl.area.centerX(area) rwl.area.centerY(area)\n      square rwl.area.width(area) - 20 rwl.area.height(area) - 20 10 : c#shared.theme.back\n      \n      frame area[1] + 10 area[4] - 10 area[3] - 10 area[4] - 35 (\n        //square 1000 1000 1000 : c#fff\n        goto frame.right - 12.5 0\n        square 20 20 0 0 1 : c#fff\n        if mouse_touching (\n          cursor \"pointer\"\n          if onclick (\n            self.open = false\n          )\n        )\n        goto frame.right - 12.5 0\n        icon \"left\" .6 : c#shared.theme.text\n        \n        goto frame.left + 12.5 0\n        square 20 20 0 0 1 : c#fff\n        if mouse_touching (\n          cursor \"pointer\"\n          if onclick (\n            void layouts.shared.state.openEmptyTab()\n          )\n        )\n        icon \"add\" .6 : c#shared.theme.text\n      )\n      \n      void layouts.shared.urlbar.update([\n        area[1] + 10,\n        area[4] - 40 - 32.5,\n        area[3] - 10,\n        area[4] - 40 - 2.5\n      ])\n      \n      c shared.theme.prim\n      frame area[1] + 5 area[4] - 40 - 35 area[3] - 5 area[2] + 5 self.height \"browser_sidebar\" (\n        local y = frame.top + frame.scroll\n        local startY = y\n        \n        for i layouts.shared.state.tabs.len (\n          local tab @= layouts.shared.state.tabs[i]\n          \n          local title = tab.document.getTitle()\n          local icon = tab.document.getIcon()\n          y -= 20\n          \n          local close_touching = false\n          \n          goto frame.right - 22.5 y\n          square 15 15 0 0 1\n          local close_touching = mouse_touching\n          \n          goto 0 y\n          c layouts.shared.state.currentTab == i ? shared.theme.seco shared.theme.prim\n          square frame.width - 25 20 15 : hover_c#shared.theme.tert\n          if mouse_touching and !close_touching (\n            cursor \"pointer\"\n            if onclick (\n              void layouts.shared.state.selectTab(i)\n            )\n          )\n          square frame.width - 25 20 10 : c#shared.theme.back\n          \n          goto frame.left + 15 y\n          if icon != null (\n            icon icon .9 : c#user.theme.text chx#7.5\n            change_x 15\n          )\n          text title.trimText(frame.right - x_position / 9 - 4) 9 : c#shared.theme.text tooltip#title\n          \n          goto frame.right - 22.5 y\n          square 15 15 0 0 1\n          if mouse_touching (\n            cursor \"pointer\"\n            if onclick (\n              void layouts.shared.state.closeTab(i)\n              i --\n            )\n          )\n          icon \"close\" .5\n          \n          y -= 20\n        )\n      )\n      self.height = startY - y - 7.5\n      \n      // clicking on the left side of the window opens the sidebar\n      if self.width < 25 (\n        goto window.left 0\n        square 20 window.height 0 0 1\n        if mouse_touching (\n          cursor \"pointer\"\n          if onclick (\n            self.open = true\n          )\n        )\n      )\n      \n      self.tar_width = self.open ? self.open_width 5\n      self.width += self.tar_width - self.width * min(delta_time, 0.02) * 10\n    )\n  )\n  return __imports__3dfd082eaa91cc9b8340f13c6baac410\ncase \"./src/layouts/summit/main.osl\"\n  class __imports__70bd3fa18cef0c20ca734751135b82d8 (\n    def init() (\n      void shared.document.init()\n      void layouts.shared.state.init()\n    )\n    \n    def update() (\n      void shared.theme.load()\n      void shared.input.update()\n      \n      window.show()\n      window_colour = #000\n      \n      glass:frame window.left window.top window.right window.bottom; frame \"clear\"\n      \n      void layouts.shared.state.resetDragbox()\n      \n      layouts.shared.state.dragbox[1][3] = max(layouts.summit.sidebar.width, 30)\n      \n      void layouts.summit.sidebar.update([\n        window.left + layouts.summit.sidebar.width - layouts.summit.sidebar.open_width,\n        window.bottom,\n        window.left + layouts.summit.sidebar.width,\n        window.top\n      ])\n      \n      void layouts.summit.topbar.update([\n        window.left + layouts.summit.sidebar.width,\n        window.top - 37.5,\n        window.right - 5,\n        window.top - 5\n      ])\n      \n      void layouts.shared.view.render([\n        window.left + layouts.summit.sidebar.width,\n        window.bottom + 5,\n        window.right - 5,\n        window.top - 42.5\n      ])\n      \n      void layouts.shared.state.applyDragbox()\n    )\n  )\n  return __imports__70bd3fa18cef0c20ca734751135b82d8\ncase \"./src/layouts/chromeLike/topbar.osl\"\n  class __imports__0f6f8e5da8ad7dfb8f0386ba0c4b7fd4 (\n    def tabs() (\n      local space = window.width - 100 - 17.5 - 15\n      \n      local hovered = false\n      \n      local x = 0\n      local tabMax = space / layouts.shared.state.tabs.len - 5\n      for i layouts.shared.state.tabs.len (\n        local tab @= layouts.shared.state.tabs[i]\n        \n        local title = tab.document.getTitle()\n        local icon = tab.document.getIcon()\n        \n        local pad = 15 + 27.5\n        if icon != null (\n          pad += 20\n        )\n        //local width = title.len * 9 + pad\n        local width = 200\n        //width = max(width, 200)\n        width = min(width, tabMax)\n        \n        local lx = x\n        x += 2.5 + (width / 2)\n        \n        loc 2 2 x + (width / 2) - 17.5 -20\n        square 15 15 0 0 1\n        local close_touching = mouse_touching\n        \n        loc 2 2 x -20\n        \n        square width - 17.5 17.5 15 0 1\n        c mouse_touching ? shared.theme.seco shared.theme.prim\n        if layouts.shared.state.currentTab == i (\n          c shared.theme.tert\n        )\n        square width - 17.5 17.5 15\n        \n        if mouse_touching and !close_touching (\n          layouts.shared.state.dragbox @= [\n            [2, 2, lx, 0],\n            [2, 2, lx + width, -20]\n          ]\n          hovered = true\n          \n          cursor \"pointer\"\n          if onclick (\n            void layouts.shared.state.selectTab(i)\n          )\n        )\n        \n        square width - 17.5 17.5 10 : c#shared.theme.prim\n        \n        if icon != null (\n          lx += 20\n          loc 2 2 lx -20\n          icon icon .9 : c#user.theme.text\n          lx += 5\n        )\n        lx += 10\n        \n        loc 2 2 lx -20\n        text title.trimText(width - pad / 9) 9 : c#shared.theme.text tooltip#title\n        \n        lx += 5\n        loc 2 2 x + (width / 2) - 17.5 -20\n        square 15 15 0 0 1\n        if mouse_touching (\n          cursor \"pointer\"\n          if onclick (\n            void layouts.shared.state.closeTab(i)\n            i --\n          )\n        )\n        icon \"close\" .5\n        \n        x += 2.5 + (width / 2)\n      )\n      \n      x += 17.5\n      loc 2 2 x -20\n      square 17.5 17.5 15 : c#shared.theme.prim hover_c#shared.theme.seco\n      if mouse_touching (\n        cursor \"pointer\"\n        if onclick (\n          void layouts.shared.state.openEmptyTab()\n        )\n      )\n      icon \"add\" .6 : c#user.theme.text\n      x += 20\n      \n      loc -2 2 -90 -20\n      line 0 -20 0 20 : c#shared.theme.prim w#1\n      \n      if !hovered (\n        layouts.shared.state.dragbox[1][3] += x\n      )\n    )\n  )\n  return __imports__0f6f8e5da8ad7dfb8f0386ba0c4b7fd4\ncase \"./src/layouts/chromeLike/main.osl\"\n  class __imports__34355e72215dbff81e1963b1534949ee (\n    def init() (\n      void shared.document.init()\n      void layouts.shared.state.init()\n    )\n    \n    def update() (\n      void shared.theme.load()\n      void shared.input.update()\n    \n      window.show()\n      window_colour = shared.theme.back\n      \n      void layouts.shared.state.resetDragbox()\n    \n      local btns @= layouts.shared.topbar.defaultButtons\n      void layouts.shared.topbar.winButtons(btns, false)\n      \n      void layouts.chromeLike.topbar.tabs()\n      \n      void layouts.shared.urlbar.update([\n        window.left,\n        window.top - 45 - 30,\n        window.right,\n        window.top - 44\n      ])\n      \n      void layouts.shared.view.render([\n        window.left,\n        window.bottom,\n        window.right,\n        window.top - 45 - 32.5\n      ])\n      \n      void layouts.shared.state.applyDragbox()\n    )\n  )\n  return __imports__34355e72215dbff81e1963b1534949ee\ncase \"./src/layouts/shared/view.osl\"\n  class __imports__5228a5cd2bf6a46e3a340119920c2e17 (\n    def render(array area) (\n      local contentArea @= rwl.area.copy(area)\n      \n      if devtools.main.open (\n        local devtoolsData @= devtools.main ?? { width: 0, anchor: \"l\" }\n        \n        local devtoolsArea @= rwl.area.copy(area)\n        switch devtoolsData.anchor (\n          case \"l\"\n            contentArea[1] += devtoolsData.width\n            devtoolsArea[3] = contentArea[1]\n            break\n          case \"r\"\n            contentArea[3] -= devtoolsData.width\n            devtoolsArea[1] = contentArea[3]\n            break\n        )\n      \n        devtoolsArea[1] += 5\n      )\n      \n      if layouts.shared.state.currentDocument != null (\n        void layouts.shared.state.currentDocument.checkResp()\n        void layouts.shared.state.currentDocument.render(contentArea)\n      )\n      \n      if devtools.main != null (\n        void devtools.main.alwaysUpdate()\n      )\n      if devtools.main.open (\n        void devtools.main.update(devtoolsArea, area)\n      )\n    )\n  )\n  return __imports__5228a5cd2bf6a46e3a340119920c2e17\ncase \"./src/layouts/shared/urlbar.osl\"\n  class __imports__e1f3f683350eb46be2bb39ac4a8762b8 (\n    inputId = \"browser_url\"\n    \n    def update(array area) (\n      local defaultText = \"blehh\"\n      \n      goto rwl.area.centerX(area) rwl.area.centerY(area) + 2.5\n      \n      local w = rwl.area.width(area) - 15\n      local h = rwl.area.height(area) - 0\n      \n      square w - 5 h - 18 15 : c#shared.theme.prim\n      input w h - 5 self.inputId defaultText 0 shared.theme.text\n      \n      if inputs.selected.id == self.inputId (\n        if \"enter\".onKeyDown() (\n          void self.goto()\n        )\n      )\n      \n      //void shared.graphics.box(area, #f00)\n    )\n    \n    def goto() (\n      local url = inputs[self.inputId]\n      \n      url @= shared.url.Url(url)\n      \n      if layouts.shared.state.tabs.len == 0 (\n        void layouts.shared.state.openEmptyTab()\n      )\n      \n      local tab @= layouts.shared.state.tabs[layouts.shared.state.currentTab]\n      void tab.redirect(url)\n    )\n  )\n  return __imports__e1f3f683350eb46be2bb39ac4a8762b8\ncase \"./src/layouts/shared/topbar.osl\"\n  class __imports__bce8e403422ca1f602a36f77e9c471c6 (\n    array defaultButtons = [\n      {\n        icon: \"close\",\n        click: window.close\n      },\n      {\n        icon: \"down\",\n        click: window.minimise\n      },\n      {\n        icon: \"maximise\",\n        click: window.fullscreen\n      }\n    ]\n    \n    def winButtons(array buttons, boolean background) (\n      if background (\n        local w = buttons.len * 25\n        \n        loc -2 2 w / -2 - 7.5 -20\n        square w - 5 18 10 : c#shared.theme.prim\n      )\n      \n      loc -2 2 -20 -20\n      change_x 25\n      for i buttons.len (\n        local button @= buttons[i]\n        \n        c shared.theme.text\n        icon button.icon 0.6 * (button.icon_size ?? 1) : hover_size#1.1 chx#-25\n        if mouse_touching (\n          cursor \"pointer\"\n          if onclick (\n            void button.click()\n          )\n        )\n      )\n    )\n  )\n  return __imports__bce8e403422ca1f602a36f77e9c471c6\ncase \"./src/layouts/shared/utils.osl\"\n  class __imports__bd7a86c2700e28469496d9f67248c0b2 (\n    def getContentArea() (\n      return [\n        window.left,\n        window.bottom,\n        window.right,\n        window.top - 50\n      ]\n    )\n  )\n  return __imports__bd7a86c2700e28469496d9f67248c0b2\ncase \"./src/layouts/shared/state.osl\"\n  class __imports__d1763f06b30a5d5d9c10608cf0f00c3e (\n    debug = false\n    \n    def init() (\n      void self.updateTab()\n      void self.selectTab(1)\n      \n      self.tabs @= []\n    )\n    \n    def resetDragbox() (\n      self.dragbox @= [[2,2,0,0],[-2,2,-90,-40]]\n    )\n    \n    def applyDragbox() (\n      window.setDragbox(self.dragbox[1], self.dragbox[2])\n      \n      if self.debug (\n        c #fff\n        loc self.dragbox[1][1] self.dragbox[1][2] self.dragbox[1][3] self.dragbox[1][4]\n        pen \"down\"\n        loc self.dragbox[2][1] self.dragbox[2][2] self.dragbox[2][3] self.dragbox[2][4]\n        pen \"up\"\n      )\n    )\n    \n    def openTabDocument(object document) (\n      local tab @= shared.tab.Tab(document)\n      void self.tabs.append(tab)\n      void self.selectTab(self.tabs.len)\n    )\n    \n    def openEmptyTab() (\n      void self.openTabDocument(shared.document.Document())\n    )\n    \n    def closeTab(number index) (\n      void self.tabs[index].document.close()\n      void self.tabs.delete(index)\n      \n      if index < self.currentTab (\n        self.currentTab --\n      )\n      \n      void self.selectTab(self.currentTab)\n    )\n    \n    def selectTab(number index) (\n      self.currentTab @= index\n      void self.updateTab()\n    )\n    \n    def updateTab() (\n      if self.currentDocument != null (\n        self.currentDocument.focused = false\n      )\n      self.currentDocument @= self.tabs[self.currentTab].document\n      if self.currentDocument.url != null (\n        inputs[layouts.shared.urlbar.inputId] = self.currentDocument.url.format()\n      ) else (\n        inputs[layouts.shared.urlbar.inputId] = \"\"\n      )\n      if inputs.selected.id == layouts.shared.urlbar.inputId (\n       input \"unfocus\"\n      )\n      \n      if self.currentDocument != null (\n        self.currentDocument.focused = true\n        \n        // fix for while workers be goofy\n        void self.currentDocument.createWorker()\n      )\n      //self.currentDocument ??= shared.document.Document()\n    )\n  )\n  return __imports__d1763f06b30a5d5d9c10608cf0f00c3e\ncase \"./src/assets/home.rwl\"\n  return \"  root {\\n    \\\"hi\\\"\\n  }\"\n\ncase \"./src/assets/empty.rwl\"\n  return \"  root {\\n    \\\"grahhh\\\"\\n  }\"\n\ncase \"./src/net/response.osl\"\n  class __imports__f336b41d073413cbdabb122f71c530f0 (\n    class Response (\n      isValid = false\n      \n      def init(object url, string content) (\n        self.url @= url\n        self.content = content\n        \n        self.isFinished = true\n      )\n    )\n    \n    class NoResponse extends Response (\n      \n    )\n    \n    class ValidResponse extends Response (\n      isValid = true\n      \n      def init(object url) (\n        self.url @= url\n        \n        self.isFinished = false\n      )\n      \n      def update() (\n        if self.isFinished (\n          return\n        )\n        local out @= self.fetch()\n        if out != null (\n          self.isFinished = true\n          self.content @= out\n        )\n      )\n    )\n  )\n  return __imports__f336b41d073413cbdabb122f71c530f0\ncase \"./src/net/fetch.osl\"\n  class __imports__d974ce5692d372884f5c4f8f8bf1ab18 (\n    def url(object url) (\n      if url.scheme == \"local\" (\n        //local f @= open(url.domain_name).toStr()\n        // fpp import instead (goes into output)\n        local f @= import(url.domain_name).toStr()\n        local r @= net.response.ValidResponse(url)\n        r.fetch @= def() -> (\n          self.content = self.f\n          self.isFinished = true\n        )\n        r.f @= f\n        return r\n      )\n      if url.scheme == shared.config.url.browser_scheme (\n        local r @= net.response.ValidResponse(url)\n        local page @= browserPages[url.domain_name]\n        if typeof(page) == \"string\" (\n          r.fetch @= def() -> (\n            self.content = self.data\n            self.isFinished = true\n          )\n          r.data @= page\n        ) else (\n          r.fetch @= page ?? (() -> ())\n        )\n        return r\n      )\n    \n      local servers @= shared.config.net.servers\n      local server @= servers[url.scheme]\n      \n      if server == null (\n        local r @= net.response.NoResponse(url, \"scheme '\" ++ url.scheme ++ \"' not found\")\n        return r\n      )\n      \n      local resource = url.domain_top\n      resource ++= \"/\"\n      if url.domain_sub != null (\n        resource ++= url.domain_sub\n        resource ++= \".\"\n      )\n      resource ++= url.domain_name\n      if url.resource != null (\n        resource ++= \"/\"\n        resource ++= url.resource\n      )\n      \n      local tld = server.tlds[url.domain_top]\n      \n      if tld == null (\n        local r @= net.response.NoResponse(url, \"tld '\" ++ url.domain_top ++ \"' not found\")\n        return r\n      )\n      \n      local realUrl = tld ++ \"/\" ++ resource\n      \n      local r @= net.response.ValidResponse(url)\n      r.fetch @= def() -> (\n        local o = self.realUrl.getAsync()\n        if o != \"Loading\" and o != \"404: Not Found\" (\n          self.content = o\n          self.isFinished = true\n        )\n      )\n      r.realUrl = realUrl\n      \n      return r\n    )\n  )\n  return __imports__d974ce5692d372884f5c4f8f8bf1ab18\ncase \"./src/shared/save.osl\"\n  class __imports__adb9c40aa8851930265661f644c37fb1 (\n    def setName(string name) (\n      save name \"set_directory\"\n    )\n    \n    def exists(string fileName) (\n      return fileName.saveExists()\n    )\n    \n    def get(string fileName) (\n      if !self.exists(fileName) (\n        throw fileName ++ \"does not exist\"\n      )\n    \n      return fileName.saveGet().toStr()\n    )\n    \n    def set(string fileName, string data) (\n      save fileName \"set\" data\n    )\n  )\n  return __imports__adb9c40aa8851930265661f644c37fb1\ncase \"./src/shared/settings.osl\"\n  class __imports__b9d870002d9a38c65f33053e346a5da3 (\n    object entries = {\n      devtools: {\n        dockside: {\n          type: \"string\",\n          desc: \"what side devtools is anchored to\",\n          default: \"r\",\n          applySetting: def(string value) -> (\n            devtools.main.anchor = value\n          )\n        },\n        open: {\n          type: \"boolean\",\n          desc: \"if devtools is open or not\",\n          default: false,\n          applySetting: def(boolean value) -> (\n            devtools.main.open = value\n          )\n        },\n        menu: {\n          type: \"string\",\n          desc: \"current open devtools menu\",\n          default: \"console\",\n          applySetting: def(string value) -> (\n            devtools.main.menu = value\n          )\n        }\n      },\n      net: {\n        offline: {\n          type: \"boolean\",\n          desc: \"disables networking\",\n          default: false\n        }\n      }\n    }\n    \n    object _data = {}\n    \n    def load() (\n      local br @= shared.config.browser\n      void shared.save.setName(br.name ++ \"@\" ++ br.save_developer)\n      if !shared.save.exists(\"settings.json\") (\n        void self.write()\n      )\n      self._data @= self.deserialize(shared.save.get(\"settings.json\"))\n      void self.applySettings()\n      void self.write()\n    )\n    \n    def write() (\n      void shared.save.set(\"settings.json\", self.serialize())\n    )\n    \n    def get(string category, string entry) (\n      return self._data[category][entry]\n    )\n    def set(string category, string entry, value) (\n      local entryData @= self.entries[category][entry]\n      if entryData == null (\n        throw \"setting\" + category ++ \"/\" ++ entry + \"doesnt exist\"\n      )\n      \n      if entryData.type != typeof(value) (\n        throw \"expected\" + entry.type + \"for\" + category ++ \"/\" ++ entry + \"but got\" + typeof(value)\n      )\n      self._data[category][entry] @= value\n      void self.write()\n      void self.applySettings()\n    )\n    \n    def applySettings() (\n      local categoryData @= self.entries.getEntries()\n      for categoryI categoryData.len (\n        local category @= categoryData[categoryI]\n        local entryData @= category[2].getEntries()\n        for entryI entryData.len (\n          local entry @= entryData[entryI]\n          local value = self._data[category[1]][entry[1]] ?? entry[2].default\n          if entry[2].applySetting != null (\n            void entry[2].applySetting(value)\n          )\n        )\n      )\n    )\n    \n    def serialize() (\n      local out @= {}\n      local categoryData @= self.entries.getEntries()\n      for categoryI categoryData.len (\n        local category @= categoryData[categoryI]\n        out[category[1]] @= {}\n        local entryData @= category[2].getEntries()\n        for entryI entryData.len (\n          local entry @= entryData[entryI]\n          local value = self._data[category[1]][entry[1]] ?? entry[2].default\n          out[category[1]][entry[1]] @= value\n        )\n      )\n      return out.JsonStringify()\n    )\n    def deserialize(string data) (\n      local raw @= data.JsonParse()\n      \n      local out @= {}\n      local categoryData @= self.entries.getEntries()\n      for categoryI categoryData.len (\n        local category @= categoryData[categoryI]\n        out[category[1]] @= {}\n        local entryData @= category[2].getEntries()\n        for entryI entryData.len (\n          local entry @= entryData[entryI]\n          local value = raw[category[1]][entry[1]] ?? entry[2].default\n          out[category[1]][entry[1]] @= value\n        )\n      )\n      return out\n    )\n  )\n  return __imports__b9d870002d9a38c65f33053e346a5da3\ncase \"./src/shared/input.osl\"\n  class __imports__f477f9b400e164d253c3bfeb6a54c186 (\n    boolean rwlLeftClick = false\n    \n    def reset() (\n      self.rwlLeftClick = false\n    )\n    \n    def update() (\n      self.leftClick = mouse_left and !self.leftDown\n      self.leftDown = mouse_left\n      if self.leftClick (\n        self.rwlLeftClick = true\n      )\n      \n      // TODO: make a keybind system?\n      if \"`\".onKeyDown() (\n        void shared.settings.set(\"devtools\", \"open\", !shared.settings.get(\"devtools\", \"open\"))\n        //devtools.main.open = !devtools.main.open\n      )\n    )\n  )\n  return __imports__f477f9b400e164d253c3bfeb6a54c186\ncase \"./src/shared/tab_worker.osl\"\n  class __imports__ed11349f32bd7389fac05d89b56e016d (\n    def oncreate() (\n      self.ouid = OuidNew()\n    )\n    \n    def onframe() (\n      if self.parseText != null (\n        local parser @= rwl.ast.Parser(self.parseText)\n        if self != null (\n          //log self\n          void self.document.loadAst(parser.parse())\n          self.parseText = null\n        )\n      )\n      if self.document != null and self.document.focused (\n        void self.document.rwlInst.interactUpdate({\n          rtr: self.document.rtrInst\n        })\n        void self.document.rtrUpdate()\n        //void self.document.rwlInst.checkElemUpdate()\n        local mods @= self.document.rtrInst.modules.getValues()\n        for i mods.len (\n          void mods[i].runEventQueue()\n        )\n        void shared.input.reset()\n      )\n    )\n  )\n  return __imports__ed11349f32bd7389fac05d89b56e016d\ncase \"./src/shared/config.osl\"\n  class __imports__9f198a2aa8925b082e5f887a2bba9b67 (\n    class net (\n      servers = {\n        rtr: {\n          url: \"https://web.rotur.dev/\",\n          \n          // <server>/<command>\n          commands: {\n            tlds: \"tlds\"\n          }\n        }\n      }\n      \n      def refresh() (\n        if shared.settings.get(\"net\", \"offline\") (\n          self.servers @= []\n        )\n        \n        for i self.servers.len (\n          local s @= self.servers.getValues()[i]\n          s.tlds @= (s.url ++ s.commands.tlds).httpGet()\n        )\n      )\n    )\n    \n    class url (\n      string browser_scheme = build.package.phosphorus.browser_scheme ?? \"phos\"\n      \n      class defaults (\n        string scheme = \"rtr\"\n        string name = \"unknown\"\n        string top = \"web\"\n      )\n    )\n    \n    class browser (\n      string name = build.package.name ?? \"phosphorus\"\n      array developers = build.package.developers ?? [\"flufi\"]\n      string version = build.package.version ?? \"1.0.0a\"\n      \n      // browserName@developer\n      string save_developer = build.package.save_developer ?? \"rotur\"\n      \n      class phosphorus (\n        string version = \"1.0.0a\"\n        \n        boolean useCanvas = false\n        boolean useCompiler = true\n      )\n    )\n  )\n  return __imports__9f198a2aa8925b082e5f887a2bba9b67\ncase \"./src/shared/theme.osl\"\n  class __imports__5876b7f6fcd5ce7f0fafd1a44ec4bd74 (\n    def load() (\n      self.back = user.theme.background\n      self.prim = user.theme.primary\n      self.seco = user.theme.secondary\n      self.tert = user.theme.tertiary\n      self.text = user.theme.text\n      self.accent = global_accent\n    )\n    \n    load()\n  )\n  return __imports__5876b7f6fcd5ce7f0fafd1a44ec4bd74\ncase \"./src/shared/url.osl\"\n  class __imports__a1d00c2cd890aa6e92598446ff24f924 (\n    class Url (\n      def init(string text) (\n        void self.parse(text)\n      )\n      \n      def parse(string text) (\n        self.text = text\n        local s @= text.match(\"/^((\\\\w+):\\\\/\\\\/)/\")\n        local match @= text.match(\"/^((\\\\w+):\\\\/\\\\/)?(((\\\\w+)\\\\.)?(\\\\w+)(\\\\.(\\\\w+))?\\\\/?(([\\\\/w]+)?(\\\\/(\\\\w+\\\\.\\\\w+))?))\\\\/?/\")\n        \n        self.scheme = match[3] ?? s[3] ?? shared.config.url.defaults.scheme\n        \n        if self.scheme == \"local\" (\n          self.domain_name = text.trim(\"local://\".len + 1, -1)\n          local usrPath = \"origin/(c) users/\" ++ username\n          if self.domain_name.toLower().startsWith(usrPath.toLower()) (\n            self.domain_name = \"~\" ++ self.domain_name.trim(usrPath.len + 1, -1)\n          )\n          self.domain_top = null\n          self.domain_sub = null\n          self.path = null\n          self.params @= {}\n          self.resource = null\n          self.text = \"local://\" ++ self.domain_name\n          return\n        )\n        \n        if match[9] != null (\n          local domain_name = match[7]\n          local domain_top = match[9]\n          local domain_sub = match[6]\n        ) else (\n          if match[6] != null (\n            local domain_name = match[6]\n            local domain_top = match[7]\n            local domain_sub = null\n          ) else (\n            local domain_name = match[7]\n            local domain_top = null\n            local domain_sub = null\n          )\n        )\n        \n        self.domain_name = domain_name ?? shared.config.url.defaults.name\n        self.domain_top = domain_top ?? shared.config.url.defaults.top\n        self.domain_sub = domain_sub\n        self.path = match[13]\n        self.params @= {}\n        self.resource = match[10] ?? \"index.rwl\"\n        \n        if self.scheme == shared.config.url.browser_scheme (\n          self.domain_top = null\n        )\n      )\n      \n      def format() (\n        if self.scheme == \"local\" (\n          return self.text\n        )\n        local sub = self.domain_sub != null ? self.domain_sub ++ \".\" \"\"\n        local top = self.domain_top != null ? \".\" ++ self.domain_top \"\"\n        local txt = self.scheme ++ \"://\" ++ sub ++ domain_name ++ top\n        if self.path != null (\n          txt ++= \"/\" ++ self.path\n        )\n        if self.resource != \"index.rwl\" (\n          txt ++= \"/\" ++ self.resource\n        )\n        return txt\n      )\n      \n      def getTitle() (\n        if self.scheme == \"local\" (\n          return self.domain_name.split(\"/\")[-1].split(\".\")[1]\n        )\n        return self.domain_name\n      )\n    )\n  )\n  return __imports__a1d00c2cd890aa6e92598446ff24f924\ncase \"./src/shared/tab.osl\"\n  class __imports__0ffc38803b2c8e6e0623c0ea1ffbcc28 (\n    class Tab (\n      def init(object document) (\n        self.document @= document\n      )\n      \n      def redirect(object url) (\n        void self.document.loadUrl(url)\n        void layouts.shared.state.updateTab()\n      )\n    )\n  )\n  return __imports__0ffc38803b2c8e6e0623c0ea1ffbcc28\ncase \"./src/shared/document.osl\"\n  class __imports__af13446f70bd7836009892ffef4b5078 (\n    class Document (\n      def init() (\n        void self.createInsts()\n        \n        self.started = false\n        self.shouldBeAlive = false\n        self.focused = false\n      )\n      \n      def close() (\n        void self.killWorker()\n      )\n      \n      def createWorker() (\n        //log \"create worker\"\n        void self.killWorker()\n        self.worker @= worker(shared.tab_worker)\n        self.worker.document @= self\n        self.shouldBeAlive = true\n      )\n      \n      def killWorker() (\n        if self.worker != null (\n          //log \"kill worker\"\n          if self.worker.kill == null (\n            return\n          )\n          void self.worker.kill()\n          self.worker = null\n          self.shouldBeAlive = false\n        )\n      )\n      \n      def createInsts() (\n        self.title = \"New Tab\"\n        if self.url != null (\n          self.title = self.url.getTitle()\n        )\n        self.icon = null\n        \n        self.rtrInst @= rtr.main.RTR()\n        self.rwlInst @= rwl.main.RWL(shared.document.empty, self.rtrInst)\n      )\n      \n      def updateInsts() (\n        // inject apis\n        void rtr.apis.main.addToInst(self, self.rtrInst)\n      )\n      \n      def update(array area) (\n        void self.rwlInst.update(area)\n      )\n      \n      def rtrUpdate() (\n        if !self.started and self.rwlInst.hasUpdated (\n          void self.rtrInst.startModules()\n          self.started = true\n        )\n      )\n      \n      def render(array area) (\n        if self.worker != null (\n          self.worker.area @= area\n          if !self.worker.alive and self.shouldBeAlive (\n            //void self.createWorker()\n            //self.rwlInst.errored = true\n            //self.rwlInst.errormsg = \"tab worker died, check js console\"\n          )\n        )\n        \n        goto rwl.area.centerX(area) rwl.area.centerY(area)\n        square rwl.area.width(area) - 10 rwl.area.height(area) - 10 10 : c#shared.theme.back\n        \n        if self.loading (\n          goto rwl.area.centerX(area) rwl.area.centerY(area)\n          direction timer * 720\n          icon \"sync\" .75 : c#shared.theme.text\n          direction 90\n          return\n        )\n        \n        //log self.rwlInst\n        void self.rwlInst.render(area)\n      )\n      \n      def checkResp() (\n        if self.resp == null (\n          self.loading = false\n          return\n        )\n        \n        if self.resp.isFinished (\n          if self.resp.isValid (\n            self.loading = false\n            \n            void self.createInsts()\n            void self.loadText(self.resp.content)\n            \n            self.resp = null\n          )\n        ) else (\n          self.loading = true\n          void self.resp.update()\n        )\n      )\n      \n      def loadAst(object ast) (\n        void self.createInsts()\n        void self.rwlInst.loadFromAst(ast)\n        void self.updateInsts()\n        self.started = false\n      )\n      \n      def loadText(string text) (\n        void self.createWorker()\n        self.worker.parseText = text\n      )\n      \n      def loadUrl(object url) (\n        self.url @= url\n        void self.createInsts()\n        self.resp @= net.fetch.url(url)\n      )\n      \n      def getIcon() (\n        return self.icon\n      )\n      def getTitle() (\n        return self.title\n      )\n    )\n    \n    def init() (\n      local parser @= rwl.ast.Parser(import(\"./src/assets/empty.rwl\"))\n      self.empty @= parser.parse()\n    )\n  )\n  return __imports__af13446f70bd7836009892ffef4b5078\ncase \"./src/shared/utils.osl\"\n  class __imports__ace3e4fea1b83d3f4a6cf8da09fee544 (\n    def removeIndents(str) (\n      local lines @= str.split(\"\\n\")\n      local indent = null\n      for i lines.len (\n        local l2 = lines[i].match(\"/^( *)(.+)$/\")\n        if l2[2].len > 0 (\n          indent = min(indent ?? 9999, l2[2].len)\n        )\n      )\n      for i lines.len (\n        lines[i] = lines[i].trim(indent + 1, -1)\n      )\n      return lines.join(\"\\n\")\n    )\n    \n    def jsFunc(string js) (\n      local f @= js.eval()\n      local f2 @= () -> ()\n      f2.code @= f\n      return f2\n    )\n  )\n  return __imports__ace3e4fea1b83d3f4a6cf8da09fee544\ncase \"./src/shared/graphics.osl\"\n  class __imports__8840a5e065c53e817186a2216f863bca (\n    _canvasID = null\n    _canvas = null\n    \n    def init() (\n      if shared.config.browser.phosphorus.useCanvas (\n        self._canvasID = OuidNew()\n        self._canvas @= shared.canvas.createCanvas(self._canvasID, window.width, window.height)\n        log self\n      )\n    )\n    \n    // cursor\n    cursor_x = 0\n    cursor_y = 0\n    def goto(number x, number y) (\n      self.cursor_x = x\n      self.cursor_y = y\n    )\n    \n    def change_x(number x) (\n      self.cursor_x += x\n    )\n    def change_y(number y) (\n      self.cursor_y += y\n    )\n    def change(number x, number y) (\n      self.cursor_x += x\n      self.cursor_y += y\n    )\n    \n    // utils\n    def getTextWidth(string text) (\n      return text.len\n    )\n    \n    // rendering\n    def box(array area, string color) (\n      c color\n      pen \"size\" 1\n      goto area[1] area[2]\n      pen \"down\"\n      goto area[3] area[2]\n      goto area[3] area[4]\n      goto area[1] area[4]\n      goto area[1] area[2]\n      pen \"up\"\n    )\n    \n    def filledBox(array area, rounding, string color) (\n      local x = rwl.area.centerX(area)\n      local y = rwl.area.centerY(area)\n      local w = rwl.area.width(area)\n      local h = rwl.area.height(area)\n      \n      if typeof(rounding) == \"number\" (\n        rounding @= [rounding,rounding,rounding,rounding]\n      )\n      \n      c color\n      \n      if typeof(rounding) == \"number\" (\n        goto x y\n        frame area[1] area[4] area[3] area[2] (\n          local r = max(rounding * 2 - 10, 0)\n          square w - r h - r r\n        )\n      ) else if typeof(rounding) == \"array\" (\n        // could rework this to have it be corner - rounding for pos\n        // so it would have higher parity with canvas?\n        x = round(x)\n        y = round(y)\n        local hw = w / 2\n        local hh = h / 2\n        goto x y\n        //local r = min(rounding[1] * 2, min(w, h) / 2)\n        frame area[1] y x area[2] (\n          local r = max(rounding[1] * 2, 0)\n          goto frame.left + hw frame.bottom + hh\n          square frame.width * 2 - r frame.height * 2 - r r\n        )\n        frame x y area[3] area[2] (\n          local r = max(rounding[2] * 2, 0)\n          goto frame.right - hw frame.bottom + hh\n          square frame.width * 2 - r frame.height * 2 - r r\n        )\n        frame area[1] area[4] x y (\n          local r = max(rounding[3] * 2, 0)\n          goto frame.left + hw frame.top - hh\n          square frame.width * 2 - r frame.height * 2 - r r\n        )\n        frame x area[4] area[3] y (\n          local r = max(rounding[4] * 2, 0)\n          goto frame.right - hw frame.top - hh\n          square frame.width * 2 - r frame.height * 2 - r r\n        )\n      )\n    )\n    \n    def filledTransparentArea(array area, string color, number opacity) (\n      frame area[1] area[4] area[3] area[2] (\n        c color\n        pen \"opacity\" opacity\n        pen \"size\" 9999\n        goto 0 0\n        pen \"down\"\n        pen \"up\"\n      )\n    )\n    \n    def ctext(string text, number size, string color) (\n      void ptext(text, self.cursor_x, self.cursor_y, size, color)\n    )\n    def ptext(string text, number x, number y, number size, string color) (\n      goto x y\n      text text size : c#color\n    )\n    \n    def cicon(string src, number size, string color) (\n      void picon(text, self.cursor_x, self.cursor_y, size, color)\n    )\n    def picon(string src, number x, number y, number size, string color) (\n      goto x y\n      icon src size : c#color\n    )\n  )\n  return __imports__8840a5e065c53e817186a2216f863bca\ncase \"./src/rtr/apis/browser.osl\"\n  class __imports__7fe61a304bd2774f13f2fe6e50c50f2a (\n    def addToMod(object doc, object mod) (\n      void mod.declScopeVar(\"$$brwsr\", rtr.value.RTRObjValue({\n        settings: rtr.value.RTRObjValue({\n          getCategories: rtr.value.RTROslFuncValue(def() -> (\n            return rtr.value.RTRArrValue(shared.settings.entries.getKeys().map(c -> rtr.value.RTRStrValue(c)))\n          )),\n          getCategory: rtr.value.RTROslFuncValue(def() -> (\n          \n          ))\n        })\n      }))\n    )\n  )\n  return __imports__7fe61a304bd2774f13f2fe6e50c50f2a\ncase \"./src/rtr/apis/rwl.osl\"\n  class __imports__da08879ce20a927bf625b809217d8644 (\n    class RTRDocument extends rtr.value.RTRValue (\n      def init(object doc) (\n        self.doc @= doc\n      )\n    \n      def getRtrType() (\n        return rtr.value.RTRTypeValue({\n          name: \"document\"\n        })\n      )\n      \n      def getItem(key) (\n        switch key.stringify() (\n          // values\n          case \"title\"\n            return rtr.value.RTRStrValue(self.doc.title)\n          case \"icon\"\n            if self.doc.icon == null (\n              return rtr.value.RTRNullValue()\n            )\n            return rtr.value.RTRStrValue(self.doc.icon)\n          case \"root\"\n            local elems @= self.doc.rwlInst.elements\n            for i elems.len (\n              local elem @= elems[i]\n              if elem.name == \"RWLRoot\" (\n                return rtr.apis.rwl.RTRElement(elem)\n              )\n            )\n            return rtr.value.RTRNullValue()\n          \n          // methods\n          case \"redirect\"\n            return rtr.value.RTROslFuncValue(def(args, _inst, doc) -> (\n              void doc.doc.loadUrl(shared.url.Url(args[1].stringify()))\n              void layouts.shared.state.updateTab()\n            ), self)\n          case \"getElement\"\n            return rtr.value.RTROslFuncValue(def(args, _inst, doc) -> (\n              local elem @= doc.doc.rwlInst.getElement(args[1].stringify())\n              if elem == null (\n                return rtr.value.RTRNullValue()\n              )\n              return rtr.apis.rwl.RTRElement(elem)\n            ), self)\n          case \"createTextElement\"\n            return rtr.value.RTROslFuncValue(def(args, _inst) -> (\n              return rtr.apis.rwl.RTRElement(rwl.main.RWLElement(rtr.apis.rwl.rtrValueToRwlValue(args[1]), { flags: [], pairs: [] }))\n            ))\n          case \"createScript\"\n            return rtr.value.RTROslFuncValue(def(args, _inst, doc) -> (\n              local elem @= rwl.main.RWLScript(args[1].stringify(), { flags: [], pairs: [] }, doc.doc.rwlInst)\n              void rtr.apis.main.addToMod(doc.doc, elem.mod)\n              void elem.start()\n              return rtr.apis.rwl.RTRElement(elem)\n            ), self)\n          case \"createContainer\"\n            return rtr.value.RTROslFuncValue(def(args, _inst) -> (\n              local kind = args[1].stringify()\n              switch kind (\n                case \"frame\"\n                  return rtr.apis.rwl.RTRElement(rwl.main.RWLFrame([], { flags: [], pairs: [] }))\n                case \"section\"\n                  return rtr.apis.rwl.RTRElement(rwl.main.RWLSection([], { flags: [], pairs: [] }))\n                case \"button\"\n                  return rtr.apis.rwl.RTRElement(rwl.main.RWLButton([], { flags: [], pairs: [] }))\n                \n                default\n                  throw \"unknown container type\" + kind\n              )\n              return rtr.apis.rwl.RTRElement(rwl.main.RWLElement(rtr.apis.rwl.rtrValueToRwlValue(args[1]), { flags: [], pairs: [] }))\n            ))\n          \n          default\n            throw \"unknown property\" + key.stringify() + \"on document\"\n        )\n      )\n      \n      def setItem(key, value) (\n        switch key.stringify() (\n          case \"title\"\n            self.doc.title = value.stringify()\n            break\n          case \"icon\"\n            self.doc.icon = value.stringify()\n            break\n          default\n            throw \"cannot set property\" + key.stringify() + \"on document\"\n        )\n      )\n    )\n    \n    class RTRElement extends rtr.value.RTRValue (\n      isRwlElem = true\n      \n      def init(object elem) (\n        self.elem @= elem\n      )\n    \n      def getRtrType() (\n        return rtr.value.RTRTypeValue({\n          name: \"element\"\n        })\n      )\n      \n      def stringify() (\n        local txt = (self.elem.blockName ?? self.elem.kind).toStr()\n        if self.elem.id != null (\n          txt ++= \":\" ++ self.elem.id\n        )\n        return \"<\" ++ txt ++ \">\"\n      )\n      \n      def getItem(key) (\n        local k = key.stringify()\n        \n        switch k (\n          case \"toggleFlag\"\n            return rtr.value.RTROslFuncValue(def(args, _inst, elem) -> (\n              local flags @= elem.elem.header.flags\n              local name = args[1].stringify()\n              \n              if flags.contains(name) (\n                void flags.delete(flags.index(name))\n              ) else (\n                void flags.append(name)\n              )\n              \n              elem.elem.needsUpdate = true\n              void elem.elem.checkUpdate()\n            ), self)\n          case \"addFlag\"\n            return rtr.value.RTROslFuncValue(def(args, _inst, elem) -> (\n              local flags @= elem.elem.header.flags\n              local name = args[1].stringify()\n              \n              if !flags.contains(name) (\n                void flags.append(name)\n              )\n              \n              elem.elem.needsUpdate = true\n              void elem.elem.checkUpdate()\n            ), self)\n          case \"removeFlag\"\n            return rtr.value.RTROslFuncValue(def(args, _inst, elem) -> (\n              local flags @= elem.elem.header.flags\n              local name = args[1].stringify()\n              \n              if flags.contains(name) (\n                void flags.delete(flags.index(name))\n              )\n              \n              elem.elem.needsUpdate = true\n              void elem.elem.checkUpdate()\n            ), self)\n          case \"hasFlag\"\n            return rtr.value.RTROslFuncValue(def(args, _inst, elem) -> (\n              local flags @= elem.elem.header.flags\n              local name = args[1].stringify()\n              \n              return rtr.value.RTRBoolValue(flags.contains(name))\n            ), self)\n          \n          case \"addChild\"\n            return rtr.value.RTROslFuncValue(def(args, _inst, elem) -> (\n              if elem.elem.children == null (\n                throw elem.kind + \"cannot contain children\"\n              )\n              if !args[1].isRwlElem (\n                throw \"argument is not rwl element\"\n              )\n              void elem.elem.children.append(args[1].elem)\n              \n              void elem.elem.updateParentFromCache()\n            ), self)\n          case \"popChild\"\n            return rtr.value.RTROslFuncValue(def(args, _inst, elem) -> (\n              if elem.elem.children == null (\n                throw elem.kind + \"doesnt contain children\"\n              )\n              local idx = args.len > 0 ? args[1].numbify() 1\n              local out @= elem.elem.children[idx]\n              if out != null (\n                out @= rtr.apis.rwl.RTRElement(out)\n              ) else (\n                out @= rtr.value.RTRNullValue()\n              )\n              void elem.elem.children.delete(idx)\n              \n              void elem.elem.updateParentFromCache()\n              return out\n            ), self)\n        )\n        \n        for i self.elem.header.pairs.len (\n          local pair @= self.elem.header.pairs[i]\n          if pair[1] == k (\n            return rtr.apis.rwl.rwlValueToRtrValue(pair[2])\n          )\n        )\n        return rtr.value.RTRNullValue()\n      )\n      \n      def setItem(key, value) (\n        local k = key.stringify()\n        local v @= rtr.apis.rwl.rtrValueToRwlValue(value)\n        \n        if k == \"text\" and self.elem.name == \"RWLElement\" (\n          self.elem.value @= v\n          void self.elem.updateFromCache()\n          return\n        )\n        \n        for i self.elem.header.pairs.len (\n          local pair @= self.elem.header.pairs[i]\n          if pair[1] == k (\n            pair[2] @= v\n            void self.elem.updateParentFromCache()\n            return\n          )\n        )\n        \n        void self.elem.header.pairs.append([\n          k, v\n        ])\n        \n        void self.elem.updateParentFromCache()\n      )\n    )\n    \n    def rwlValueToRtrValue(object val) (\n      switch val.type (\n        case \"str\"\n          return rtr.value.RTRStrValue(val.value)\n        case \"num\"\n          return rtr.value.RTRNumValue(val.value)\n        // percentage\n        // color\n      )\n      \n      return rtr.value.RTRNullValue()\n    )\n    \n    def rtrValueToRwlValue(object val) (\n      local type @= val.getRtrType()\n      \n      switch type.data.name (\n        case \"str\"\n          return rwl.value.RWLStrValue(val.value)\n        case \"num\"\n          return rwl.value.RWLNumValue(val.value)\n        case \"color\"\n          return rwl.value.RWLColorValue(val.value)\n      )\n      \n      throw \"cannot set\" + type.stringify() + \"as rwl property\"\n    )\n    \n    // applies rwl related apis to rtr\n    def addToMod(object doc, object mod) (\n      void mod.declScopeVar(\"document\", RTRDocument(doc))\n      void mod.declScopeVar(\"theme\", rtr.value.RTRObjValue({\n        back: rtr.value.RTRColorValue(shared.theme.back),\n        prim: rtr.value.RTRColorValue(shared.theme.prim),\n        seco: rtr.value.RTRColorValue(shared.theme.seco),\n        tert: rtr.value.RTRColorValue(shared.theme.tert),\n        text: rtr.value.RTRColorValue(shared.theme.text),\n        accent: rtr.value.RTRColorValue(shared.theme.accent),\n      }))\n    )\n  )\n  return __imports__da08879ce20a927bf625b809217d8644\ncase \"./src/rtr/apis/main.osl\"\n  class __imports__60f47f43e26f20419434c17601b19cbc (\n    // applies apis to rtr\n    def addToInst(object doc, object rtrInst) (\n      local mods @= rtrInst.modules.getValues()\n      for i mods.len (\n        addToMod(doc, mods[i])\n      )\n    )\n    \n    def addToMod(object doc, object mod) (\n      void rtr.apis.rwl.addToMod(doc, mod)\n      void rtr.apis.browser.addToMod(doc, mod)\n    )\n  )\n  return __imports__60f47f43e26f20419434c17601b19cbc\ncase \"./src/rtr/instruction.osl\"\n  class __imports__63f619ecaeba64e54adfad70c460fe06 (\n    // program flow\n    def label(string name) (\n      return { kind: \"label\", name }\n    )\n    def jump(string label) (\n      return { kind: \"jump\", label }\n    )\n    def jumpIf(string label) (\n      return { kind: \"jumpIf\", label }\n    )\n    def jumpNotIf(string label) (\n      return { kind: \"jumpNotIf\", label }\n    )\n    \n    // operations\n    def callOp(number amount) (\n      return { kind: \"call\", args: amount }\n    )\n    def unary(string op) (\n      return { kind: \"unary\", op }\n    )\n    def binary(string op) (\n      return { kind: \"binary\", op }\n    )\n    def prop() (\n      return { kind: \"prop\" }\n    )\n    def len() (\n      return { kind: \"len\" }\n    )\n    \n    // values\n    def null() (\n      return { kind: \"null\" }\n    )\n    def str(string data) (\n      return { kind: \"str\", data }\n    )\n    def num(number data) (\n      return { kind: \"num\", data }\n    )\n    def bool(boolean data) (\n      return { kind: \"bool\", data }\n    )\n    def func(array body, array args) (\n      return { kind: \"func\", body, args }\n    )\n    def arr(number elems) (\n      return { kind: \"arr\", elems }\n    )\n    def obj(array keys) (\n      return { kind: \"obj\", keys }\n    )\n    def color(string data) (\n      return { kind: \"color\", data }\n    )\n    \n    // scope\n    def get(string name) (\n      return { kind: \"get\", name }\n    )\n    def decl(string name) (\n      return { kind: \"decl\", name }\n    )\n    def newScope() (\n      return { kind: \"newScope\" }\n    )\n    def popScope() (\n      return { kind: \"popScope\" }\n    )\n    \n    // assignments\n    def asivar(string name, op) (\n      return { kind: \"asivar\", name, op }\n    )\n    def asiprop(op) (\n      return { kind: \"asiprop\", op }\n    )\n    \n    // stack\n    def pop() (\n      return { kind: \"pop\" }\n    )\n    def dupe(number i) (\n      return { kind: \"dupe\", i }\n    )\n  )\n  return __imports__63f619ecaeba64e54adfad70c460fe06\ncase \"./src/rtr/compiler.osl\"\n  class __imports__bf40e68b061a1d99656fd4525ccf9d7b (\n    lbli = 0\n    \n    def getLabelName() (\n      self.lbli ++\n      return self.lbli.toStr()\n    )\n    \n    def compileBlock(object block) (\n      local instructions @= []\n      //log \"blk\" block\n      for i block.elements.len (\n        local out @= compileStatement(block.elements[i])\n        if typeof(out) != \"array\" and out.isError (\n          return out\n        )\n        \n        instructions ++= out\n      )\n      return instructions\n    )\n    \n    def compileStatement(object statement) (\n      //log \"stat\" statement\n      switch statement.kind (\n        case \"expression\"\n          local out @= compileExpression(statement.expr)\n          if typeof(out) != \"array\" and out.isError (\n            return out\n          )\n          \n          out += rtr.instruction.pop()\n          return out\n        case \"block\"\n          local body @= compileBlock(statement.body)\n          if typeof(body) != \"array\" and body.isError (\n            return body\n          )\n          \n          local out @= []\n          \n          out += rtr.instruction.newScope()\n          out ++= body\n          out += rtr.instruction.popScope()\n          \n          return out\n        \n        case \"branch\"\n          local out @= []\n          local hasElse = statement.elifs.len > 0 or statement.elseBody != null\n          \n          local endLbl = getLabelName()\n          local elseLbl = hasElse ? getLabelName() endLbl\n          \n          local cond @= compileExpression(statement.cond)\n          if typeof(cond) != \"array\" and cond.isError (\n            return cond\n          )\n          out ++= cond\n          out += rtr.instruction.jumpNotIf(elseLbl)\n          local body @= compileStatement(statement.body)\n          if typeof(body) != \"array\" and body.isError (\n            return body\n          )\n          out ++= body\n          if hasElse (\n            out += rtr.instruction.jump(endLbl)\n          )\n          \n          for i statement.elifs.len (\n            local elif @= statement.elifs[i]\n            local isLast = i == statement.elifs.len and statement.elseBody == null\n            out += rtr.instruction.label(elseLbl)\n            elseLbl = isLast ? endLbl getLabelName()\n            \n            local cond @= compileExpression(elif.cond)\n            if typeof(cond) != \"array\" and cond.isError (\n              return cond\n            )\n            out ++= cond\n            out += rtr.instruction.jumpNotIf(elseLbl)\n            local body @= compileStatement(elif.body)\n            if typeof(body) != \"array\" and body.isError (\n              return body\n            )\n            out ++= body\n            if !(i == statement.elifs.len and statement.elseBody == null) (\n              out += rtr.instruction.jump(endLbl)\n            )\n          )\n          \n          if statement.elseBody != null (\n            out += rtr.instruction.label(elseLbl)\n            local body @= compileStatement(statement.elseBody)\n            if typeof(body) != \"array\" and body.isError (\n              return body\n            )\n            out ++= body\n          )\n          out += rtr.instruction.label(endLbl)\n          return out\n        \n        case \"while\"\n          local out @= []\n          \n          local startLbl @= getLabelName()\n          local endLbl @= getLabelName()\n          \n          out += rtr.instruction.label(startLbl)\n          local cond @= compileExpression(statement.cond)\n          if typeof(cond) != \"array\" and cond.isError (\n            return cond\n          )\n          out ++= cond\n          out += rtr.instruction.jumpNotIf(endLbl)\n          \n          local body @= compileStatement(statement.body)\n          if typeof(body) != \"array\" and body.isError (\n            return body\n          )\n          out ++= body\n          \n          out += rtr.instruction.jump(startLbl)\n          out += rtr.instruction.label(endLbl)\n          return out\n        case \"until\"\n          local out @= []\n          \n          local startLbl @= getLabelName()\n          local endLbl @= getLabelName()\n          \n          out += rtr.instruction.label(startLbl)\n          local cond @= compileExpression(statement.cond)\n          if typeof(cond) != \"array\" and cond.isError (\n            return cond\n          )\n          out ++= cond\n          out += rtr.instruction.jumpIf(endLbl)\n          \n          local body @= compileStatement(statement.body)\n          if typeof(body) != \"array\" and body.isError (\n            return body\n          )\n          out ++= body\n          \n          out += rtr.instruction.jump(startLbl)\n          out += rtr.instruction.label(endLbl)\n          return out\n        case \"repeat\"\n          local out @= []\n          \n          local startLbl @= getLabelName()\n          local endLbl @= getLabelName()\n          \n          out += rtr.instruction.num(1)\n          out += rtr.instruction.label(startLbl)\n          out += rtr.instruction.dupe(-1)\n          local amt @= compileExpression(statement.amount)\n          if typeof(amt) != \"array\" and amt.isError (\n            return amt\n          )\n          out ++= amt\n          out += rtr.instruction.binary(\">\")\n          out += rtr.instruction.jumpIf(endLbl)\n          \n          out ++= compileStatement(statement.body)\n          \n          out += rtr.instruction.num(1)\n          out += rtr.instruction.binary(\"+\")\n          out += rtr.instruction.jump(startLbl)\n          out += rtr.instruction.label(endLbl)\n          out += rtr.instruction.pop()\n          return out\n        case \"for\"\n          local out @= []\n          \n          local startLbl @= getLabelName()\n          local endLbl @= getLabelName()\n          local arr @= compileExpression(statement.arr)\n          if typeof(arr) != \"array\" and arr.isError (\n            return arr\n          )\n          out ++= arr\n          out += rtr.instruction.num(0)\n          out += rtr.instruction.label(startLbl)\n          out += rtr.instruction.dupe(-2)\n          out += rtr.instruction.len()\n          out += rtr.instruction.dupe(-2)\n          out += rtr.instruction.binary(\"<=\")\n          out += rtr.instruction.jumpIf(endLbl)\n          out += rtr.instruction.dupe(-2)\n          out += rtr.instruction.dupe(-2)\n          out += rtr.instruction.prop()\n          out += rtr.instruction.newScope()\n          out += rtr.instruction.decl(statement.var)\n          out += rtr.instruction.pop()\n          \n          out ++= compileStatement(statement.body)\n          \n          out += rtr.instruction.popScope()\n          out += rtr.instruction.num(1)\n          out += rtr.instruction.binary(\"+\")\n          out += rtr.instruction.jump(startLbl)\n          out += rtr.instruction.label(endLbl)\n          out += rtr.instruction.pop()\n          out += rtr.instruction.pop()\n          return out\n        \n        default\n          return rtr.error.Error(\"UnknownStatementKind\", { kind: statement.kind })\n      )\n      \n      return []\n    )\n    \n    def compileExpression(object expression) (\n      //log \"expr\" expression\n      switch expression.kind (\n        case \"call\"\n          local func @= compileExpression(expression.func)\n          if typeof(func) != \"array\" and func.isError (\n            return func\n          )\n          \n          local args @= []\n          for i expression.args.len (\n            local out @= compileExpression(expression.args[i])\n            if typeof(out) != \"array\" and out.isError (\n              return out\n            )\n            \n            args ++= out\n          )\n          local out @= []\n          out ++= func\n          out ++= args\n          out += rtr.instruction.callOp(expression.args.len)\n          return out\n        case \"decl\"\n          local val @= compileExpression(expression.val)\n          if typeof(val) != \"array\" and val.isError (\n            return val\n          )\n          \n          local out @= val\n          out += rtr.instruction.decl(expression.tar)\n          return out\n        case \"asi\"\n          local val @= compileExpression(expression.val)\n          if typeof(val) != \"array\" and val.isError (\n            return val\n          )\n          local out @= val\n          switch expression.tar.kind (\n            case \"var\"\n              void out.append(rtr.instruction.asivar(expression.tar.name, expression.op))\n              return out\n            case \"prop\"\n              out ++= compileExpression(expression.tar.obj)\n              if typeof(expression.tar.key) == \"string\" (\n                out += rtr.instruction.str(expression.tar.key)\n              ) else (\n                out ++= compileExpression(expression.tar.key)\n              )\n              void out.append(rtr.instruction.asiprop(expression.op))\n              return out\n          )\n          \n          return [rtr.instruction.null()]\n        case \"unary\"\n          local val @= compileExpression(expression.expr)\n          \n          local out @= []\n          out ++= val\n          out += rtr.instruction.unary(expression.type)\n          \n          return out\n        case \"binary\"\n          local left @= compileExpression(expression.left)\n          if typeof(left) != \"array\" and left.isError (\n            return left\n          )\n          local right @= compileExpression(expression.right)\n          if typeof(right) != \"array\" and right.isError (\n            return right\n          )\n          \n          local out @= []\n          out ++= left\n          out ++= right\n          out += rtr.instruction.binary(expression.op)\n          \n          return out\n        case \"var\"\n          if [\"true\",\"false\"].contains(expression.name) (\n            return [rtr.instruction.bool(expression.name == \"true\")]\n          )\n          return [rtr.instruction.get(expression.name)]\n        case \"prop\"\n          local out @= []\n          out ++= compileExpression(expression.obj)\n          if typeof(expression.key) == \"string\" (\n            out += rtr.instruction.str(expression.key)\n          ) else (\n            out ++= compileExpression(expression.key)\n          )\n          out += rtr.instruction.prop()\n          return out\n        \n        case \"str\"\n          return [rtr.instruction.str(expression.val)]\n        case \"num\"\n          return [rtr.instruction.num(expression.val)]\n        case \"func\"\n          return [rtr.instruction.func(compileStatement(expression.body), expression.args)]\n        case \"arr\"\n          local out @= []\n          for i expression.elems.len (\n            out ++= compileExpression(expression.elems[i])\n          )\n          out += rtr.instruction.arr(expression.elems.len)\n          return out\n        case \"obj\"\n          local out @= []\n          local keys @= []\n          for i expression.pairs.len (\n            out ++= compileExpression(expression.pairs[i].value)\n            void keys.append(expression.pairs[i].name)\n          )\n          out += rtr.instruction.obj(keys)\n          return out\n        case \"color\"\n          return [rtr.instruction.color(expression.val)]\n        \n        default\n          log expression\n          return rtr.error.Error(\"UnknownExpressionKind\", { kind: expression.kind })\n      )\n      \n      return [rtr.instruction.null()]\n    )\n  )\n  return __imports__bf40e68b061a1d99656fd4525ccf9d7b\ncase \"./src/rtr/value.osl\"\n  class __imports__b2506e9c8a1f71d53780de64c11f25a1 (\n    class RTRValue (\n      def callFunc() (\n        throw \"cannot call\" + self.stringify(true) + \"as function\"\n      )\n    \n      def getRtrType() (\n        throw self.name + \"has not implemented getRtrType()\"\n        return rtr.value.RTRTypeValue({\n          name: \"?\"\n        })\n      )\n    \n      def stringify() (\n        return \"<\" ++ self.getRtrType().getName() ++ \">\"\n      )\n      def numbify() (\n        return NaN\n      )\n      def boolify() (\n        return true\n      )\n      def arrify() (\n        return []\n      )\n      def length() (\n        return 0\n      )\n      def getItem(key) (\n        return null\n      )\n      def setItem(key, value) (\n        throw \"cannot set items on\" + self.stringify(true)\n      )\n      def keys() (\n        return []\n      )\n      def values() (\n        return []\n      )\n      def has(key) (\n        return false\n      )\n      def isEqual(other) (\n        return self.getRtrType().isEqual(other.getRtrType())\n      )\n    )\n    \n    class RTRTypeValue (\n      def init(object data) (\n        self.data @= data\n      )\n      \n      def stringify() (\n        return self.getName()\n      )\n      def getName() (\n        if self.data.name != null (\n          return self.data.name\n        )\n        return \"?\"\n      )\n      def isEqual(object other) (\n        return self.data.name == other.data.name\n      )\n    )\n    \n    class RTRLiteralValue extends RTRValue (\n      boolean isLiteral = true\n    )\n    \n    class RTRStrValue extends RTRLiteralValue (\n      def init(string value) (\n        self.value @= value\n      )\n      \n      def getRtrType() (\n        return rtr.value.RTRTypeValue({\n          name: \"str\"\n        })\n      )\n      \n      def stringify(format) (\n        return format ? self.value.JsonStringify() self.value\n      )\n      def numbify() (\n        return self.value.toNum()\n      )\n      def boolify() (\n        return self.value.len > 0\n      )\n      def arrify() (\n        return self.value.split(\"\").map(e -> rtr.value.RTRStrValue(e))\n      )\n      def length() (\n        return self.value.len\n      )\n      def getItem(index) (\n        return rtr.value.RTRStrValue(self.value[index.numbify() + 1])\n      )\n      def isEqual(other) (\n        return self.getRtrType().isEqual(other.getRtrType()) and self.value === other.value\n      )\n    )\n    \n    class RTRNumValue extends RTRLiteralValue (\n      def init(number value) (\n        self.value @= value\n      )\n      \n      def getRtrType() (\n        return rtr.value.RTRTypeValue({\n          name: \"num\"\n        })\n      )\n      \n      def stringify() (\n        return self.value.toStr()\n      )\n      def numbify() (\n        return self.value\n      )\n      def boolify() (\n        return self.value > 0\n      )\n      def arrify() (\n        return self.value.toStr().split(\"\").map(e -> rtr.value.RTRStrValue(e))\n      )\n      def length() (\n        return self.value.toStr().length\n      )\n      def getItem(index) (\n        return self.value.toStr()[index.numbify() + 1]\n      )\n      def isEqual(other) (\n        return self.getRtrType().isEqual(other.getRtrType()) and self.value === other.value\n      )\n    )\n    \n    class RTRBoolValue extends RTRLiteralValue (\n      def init(boolean value) (\n        self.value @= value\n      )\n      \n      def getRtrType() (\n        return rtr.value.RTRTypeValue({\n          name: \"bool\"\n        })\n      )\n      \n      def stringify() (\n        return self.value.toStr()\n      )\n      def numbify() (\n        return self.value.toNum()\n      )\n      def boolify() (\n        return self.value\n      )\n      def isEqual(other) (\n        return self.getRtrType().isEqual(other.getRtrType()) and self.value === other.value\n      )\n    )\n    \n    class RTRColorValue extends RTRLiteralValue (\n      def init(string value) (\n        self.value @= value\n      )\n      \n      def getRtrType() (\n        return rtr.value.RTRTypeValue({\n          name: \"color\"\n        })\n      )\n      \n      def stringify() (\n        return self.value.toStr()\n      )\n      def boolify() (\n        return !!self.value\n      )\n      def isEqual(other) (\n        return self.getRtrType().isEqual(other.getRtrType()) and self.value === other.value\n      )\n    )\n    \n    class RTRFuncValue extends RTRValue (\n      def getRtrType() (\n        return rtr.value.RTRTypeValue({\n          name: \"func\"\n        })\n      )\n    )\n    \n    class RTROslFuncValue extends RTRFuncValue (\n      def init(func, extra) (\n        self.func @= func\n        self.extra @= extra\n      )\n      \n      def callFunc(object inst, array args) (\n        return self.func(args, inst, extra) ?? rtr.value.RTRNullValue()\n      )\n    )\n    class RTRAstFuncValue extends RTRFuncValue (\n      def init(array args, object body) (\n        self.args @= args\n        self.body @= body\n      )\n      \n      def callFunc(object inst, array args) (\n        local s @= {}\n        for i self.args.len (\n          local a @= self.args[i]\n          local v @= args[i] ?? rtr.value.RTRNullValue()\n          s[a.name] @= [v, {}]\n        )\n        \n        void inst.newScope(s)\n        void inst.declScopeVar(\"@return\", 0)\n        \n        local exprOut @= inst.runStatement(self.body)\n        \n        local ret @= inst.getScopeVar(\"@return\") ?? 0\n        if ret == 0 (\n          ret @= exprOut\n        )\n        \n        void inst.popScope()\n        \n        return ret\n      )\n    )\n    class RTRBytecodeFuncValue extends RTRFuncValue (\n      def init(array args, array body) (\n        self.args @= args\n        self.body @= body\n      )\n      \n      def callFunc(object inst, array args) (\n        local s @= {}\n        for i self.args.len (\n          local a @= self.args[i]\n          local v @= args[i] ?? rtr.value.RTRNullValue()\n          s[a.name] @= [v, {}]\n        )\n        \n        void inst.newScope(s)\n        \n        local exprOut @= inst.runInstructions(self.body)\n        \n        void inst.popScope()\n        \n        return exprOut\n      )\n    )\n    \n    class RTRNullValue extends RTRValue (\n      def getRtrType() (\n        return rtr.value.RTRTypeValue({\n          name: \"null\"\n        })\n      )\n      \n      def boolify() (\n        return false\n      )\n      def isEqual(other) (\n        return self.getRtrType().isEqual(other.getRtrType()) and self.value === other.value\n      )\n    )\n    \n    class RTRArrValue extends RTRValue (\n      def init(array elements) (\n        self.elements @= elements\n      )\n      \n      def getRtrType() (\n        return rtr.value.RTRTypeValue({\n          name: \"arr\"\n        })\n      )\n      \n      def stringify() (\n        local el @= self.elements.map(e -> e.stringify(true))\n        return \"[\" ++ el.join(\", \") ++ \"]\"\n      )\n      def boolify() (\n        return self.elements.len > 0\n      )\n      def arrify() (\n        return self.elements\n      )\n      def length() (\n        return self.elements.len\n      )\n      def keys() (\n        local arr2 @= []\n        for i self.elements.len (\n          void arr2.append(i - 1)\n        )\n        return arr2\n      )\n      def values() (\n        return self.elements\n      )\n      def getItem(index) (\n        return self.elements[index.numbify() + 1]\n      )\n      // setItem\n    )\n    \n    class RTRObjValue extends RTRValue (\n      def init(object value) (\n        self.value @= value\n      )\n      \n      def getRtrType() (\n        return rtr.value.RTRTypeValue({\n          name: \"obj\"\n        })\n      )\n      \n      def stringify() (\n        local el @= self.value.getEntries().map(e -> e[1] ++ \":\" + e[2].stringify(true))\n        return \"{\" ++ el.join(\", \") ++ \"}\"\n      )\n      def boolify() (\n        return self.value.getKeys().len > 0\n      )\n      def arrify() (\n        return self.value.getKeys().map(e -> rtr.value.RTRStrValue(e))\n      )\n      def length() (\n        return self.value.getKeys().len\n      )\n      def keys() (\n        return self.value.getKeys()\n      )\n      def values() (\n        return self.value.getValues()\n      )\n      def has(key) (\n        return self.value.getKeys().contains(key)\n      )\n      def getItem(key) (\n        return self.value[key.stringify()]\n      )\n      def setItem(key, value) (\n        self.value[key.stringify()] @= value\n      )\n    )\n  )\n  return __imports__b2506e9c8a1f71d53780de64c11f25a1\ncase \"./src/rtr/error.osl\"\n  class __imports__a51b04c580d521af176787ba84843c9a (\n    object Errors = {\n      CannotAssign: def(data) -> (\n        return \"cannot assign to\" + data.kind\n      ),\n    \n      // instructions\n      UnknownInstructionKind: def(data) -> (\n        return \"unknown instruction kind:\" + data.kind\n      ),\n      \n      // compiler\n      UnknownStatementKind: def(data) -> (\n        return \"unknown statement kind:\" + data.kind\n      ),\n      UnknownExpressionKind: def(data) -> (\n        return \"unknown expression kind:\" + data.kind\n      )\n    }\n    \n    class Error (\n      boolean isError = true\n      \n      def init(string type, object data) (\n        self.type = type\n        self.data @= data\n        \n        local err @= rtr.error.Errors[type]\n        if err == null (\n          self.type = \"UnknownErrorType\"\n          self.txt = \"unknown error type\" + type\n          return\n        )\n        self.txt = err(data)\n      )\n      \n      def stringify() (\n        return \"Error<\" ++ self.type ++ \">:\\n\" ++ self.txt.split(\"\\n\").map(l -> \"    \" ++ l).join(\"\\n\")\n      )\n    )\n  )\n  return __imports__a51b04c580d521af176787ba84843c9a\ncase \"./src/rtr/ast.osl\"\n  class __imports__2691a00e099698fa56c4748f2551eb65 (\n    class Parser (\n      def init(string text, scriptLocation) (\n        self.scriptLocation @= scriptLocation\n        void self.tokenise(text)\n      )\n      \n      def parse() (\n        self.pointer = 1\n        log self\n        local out @= self.blockContent(true)\n        \n        if !self.atEnd() (\n          throw \"unexpected token\" + self.peek()\n        )\n        \n        return { elements: out }\n      )\n      \n      def peek(amount) (\n        amount ??= 1\n        return self.tokens[self.pointer + amount - 1]\n      )\n      def consume() (\n        local tkn = self.peek()\n        self.pointer ++\n        return tkn\n      )\n      def consumeWhitespace() (\n        while self.peek().match(\"/^\\\\s$/\") != null (\n          void self.consume()\n        )\n      )\n      def atEnd() (\n        return self.pointer >= self.tokens.len\n      )\n      def expect(string token) (\n        local tkn @= self.consume()\n        if tkn != token (\n          throw \"expected '\" ++ token ++ \"' got '\" ++ tkn ++ \"'\"\n        )\n        return tkn\n      )\n      def expects(array tokens) (\n        local tkn @= self.consume()\n        if !tokens.contains(tkn) (\n          throw \"expected '\" ++ tokens.join(\" or \") ++ \"' got '\" ++ tkn ++ \"'\"\n        )\n        return tkn\n      )\n      def expectText() (\n        local tkn @= self.consume()\n        if !tkn.match(\"/^[a-zA-Z_0-9]+$/\") (\n          throw \"identifier must consist of letters or _\"\n        )\n        return tkn\n      )\n      def getPos() (\n        local ln = 1\n        local col = 0\n        local char = 0\n        local i = self.pointer\n        for t self.pointer (\n          col ++\n          char += self.tokens[t].len\n          if self.tokens[t] == \"\\n\" (\n            ln ++\n            col = 0\n            char = 0\n          )\n        )\n        return { ln, col, char, i, loc: self.scriptLocation }\n      )\n      \n      def tokenise(string text) (\n        self.tokens @= []\n        local splitChars @= [\n          \"(\",\")\",\n          \"[\",\"]\",\n          \"{\",\"}\",\n          \",\",\";\",\":\",\"=\",\".\",\"#\",\n          \"+\",\"-\",\"*\",\"/\",\"%\",\"^\",\n          \"\\\\\",\n          \"'\",\"\\\"\",\"`\",\n          \" \",\"\\n\",\n          \"!\",\"?\"\n        ]\n        local buf = \"\"\n        for i text.len (\n          if splitChars.contains(text[i]) (\n            if buf.len > 0 (\n              void self.tokens.append(buf)\n            )\n            void self.tokens.append(text[i])\n            buf = \"\"\n          ) else (\n            buf ++= text[i]\n          )\n        )\n        if buf.len > 0 (\n          self.tokens.append(buf)\n        )\n      )\n      \n      // statements\n      def blockContent(top) (\n        local statements @= []\n        local end = peek() == \"}\" or self.atEnd()\n        while !end (\n          if top (\n            local out @= self.topLevelStatement()\n          ) else (\n            local out @= self.statement()\n          )\n          if out != null (\n            void statements.append(out)\n          )\n          void self.consumeWhitespace()\n          if self.peek() == \";\" (\n            void self.consume()\n          )\n          if self.peek() == \"}\" or self.atEnd() (\n            end = true\n          )\n        )\n        return statements\n      )\n      \n      def topLevelStatement() (\n        void self.consumeWhitespace()\n        \n        if self.peek() == \"event\" (\n          return self.event()\n        )\n        \n        void self.consumeWhitespace()\n        \n        // global parsing\n        local ptr = self.pointer\n        \n        local start @= self.getPos()\n        local name = self.consume()\n        if name.match(\"/^[a-zA-Z_0-9]+$/\") != null (\n          void self.consumeWhitespace()\n          if self.peek() == \":\" (\n            void self.consume()\n            void self.expect(\"=\")\n            void self.consumeWhitespace()\n            local expr @= self.expression()\n            void self.expect(\";\")\n            return {\n              kind: \"global\",\n              name,\n              val: expr,\n              auto: true,\n              start, end: self.getPos()\n            }\n          )\n          if self.peek() == \"=\" (\n            void self.consume()\n            local expr @= self.expression()\n            void self.expect(\";\")\n            return {\n              kind: \"global\",\n              name,\n              val: expr,\n              start, end: self.getPos()\n            }\n          )\n        )\n        \n        self.pointer = ptr\n        \n        void self.consumeWhitespace()\n        \n        throw \"unexpected token '\" ++ self.peek() ++ \"'\"\n      )\n      \n      def event() (\n        local start @= self.getPos()\n        void self.expect(\"event\")\n        void self.consumeWhitespace()\n        void self.expect(\"(\")\n        void self.consumeWhitespace()\n        local target @= self.eventTarget()\n        void self.consumeWhitespace()\n        void self.expect(\")\")\n        void self.consumeWhitespace()\n        local body @= self.block()\n        \n        return {\n          kind: \"event\",\n          target,\n          body,\n          start, end: self.getPos()\n        }\n      )\n      \n      def statement(noSemicolon) (\n        void self.consumeWhitespace()\n        \n        // statements\n        if self.peek() == \"{\" (\n          local start @= self.getPos()\n          local body @= self.block()\n          return {\n            kind: \"block\",\n            body,\n            start, end: self.getPos()\n          }\n        )\n        \n        if self.peek() == \"if\" (\n          local start @= self.getPos()\n          void self.consume()\n          void self.consumeWhitespace()\n          void self.expect(\"(\")\n          local ifCond @= self.expression()\n          void self.expect(\")\")\n          void self.consumeWhitespace()\n          local ifBody @= self.statement()\n          \n          local elifs @= []\n          \n          void self.consumeWhitespace()\n          while self.peek() == \"elif\" (\n            void self.consume()\n            void self.consumeWhitespace()\n            void self.expect(\"(\")\n            local elifCond @= self.expression()\n            void self.expect(\")\")\n            void self.consumeWhitespace()\n            local elifBody @= self.statement()\n            \n            void elifs.append({\n              cond: elifCond,\n              body: elifBody\n            })\n            void self.consumeWhitespace()\n          )\n          \n          local elseBody = null\n          void self.consumeWhitespace()\n          if self.peek() == \"else\" (\n            void self.consume()\n            void self.consumeWhitespace()\n            local elseBody @= self.statement()\n          )\n          \n          return {\n            kind: \"branch\",\n            cond: ifCond,\n            body: ifBody,\n            elifs,\n            elseBody,\n            start, end: self.getPos()\n          }\n        )\n        \n        if [\"while\",\"until\"].contains(self.peek()) (\n          local start @= self.getPos()\n          local kind @= self.consume()\n          void self.consumeWhitespace()\n          void self.expect(\"(\")\n          local cond @= self.expression()\n          void self.expect(\")\")\n          void self.consumeWhitespace()\n          local body @= self.statement()\n          \n          return {\n            kind,\n            cond,\n            body,\n            start, end: self.getPos()\n          }\n        )\n        \n        if self.peek() == \"repeat\" (\n          local start @= self.getPos()\n          void self.consume()\n          void self.consumeWhitespace()\n          void self.expect(\"(\")\n          local amount @= self.expression()\n          void self.expect(\")\")\n          void self.consumeWhitespace()\n          local body @= self.statement()\n          \n          return {\n            kind: \"repeat\",\n            amount,\n            body,\n            start, end: self.getPos()\n          }\n        )\n        \n        if self.peek() == \"for\" (\n          local start @= self.getPos()\n          void self.consume()\n          void self.consumeWhitespace()\n          void self.expect(\"(\")\n          local var @= self.expectText()\n          void self.consumeWhitespace()\n          void self.expect(\",\")\n          void self.consumeWhitespace()\n          local arr @= self.expression()\n          void self.expect(\")\")\n          void self.consumeWhitespace()\n          local body @= self.statement()\n          return {\n            kind: \"for\",\n            var,\n            arr,\n            body,\n            start, end: self.getPos()\n          }\n        )\n        \n        local expr @= self.expression()\n        if expr != null (\n          void self.consumeWhitespace()\n          if !noSemicolon (\n            void self.expect(\";\")\n          )\n          \n          return {\n            kind: \"expression\",\n            expr\n          }\n        ) else (\n          throw \"unexpected token '\" ++ self.peek() ++ \"'\"\n        )\n      )\n      \n      def block() (\n        local start @= self.getPos()\n        void self.expect(\"{\")\n        void self.consumeWhitespace()\n        local elements @= self.blockContent()\n        void self.consumeWhitespace()\n        void self.expect(\"}\")\n        return { elements, start, end: self.getPos() }\n      )\n      \n      // event targets\n      def eventTarget() (\n        local start @= self.getPos()\n        \n        local target @= self.target()\n        \n        void self.consumeWhitespace()\n        \n        if self.peek() == \":\" (\n          void self.consume()\n          local eventName = self.expectText()\n          return {\n            kind: \"property\",\n            target,\n            eventName,\n            start, end: self.getPos()\n          }\n        )\n        \n        self.pointer = start.i\n        \n        return {\n          kind: \"global\",\n          target: self.expectText(),\n          start, end: self.getPos()\n        }\n      )\n      \n      // targets\n      def target() (\n        local start @= self.getPos()\n        \n        if self.peek() == \"*\" (\n          void self.consume()\n          return {\n            kind: \"any\"\n          }\n        )\n        \n        local kind = \"element\"\n        \n        if self.peek() == \"#\" (\n          void self.consume()\n          void self.consumeWhitespace()\n          kind = \"id\"\n        )\n        \n        local name = self.expectText()\n        \n        return {\n          kind,\n          name\n        }\n      )\n      \n      // expressions\n      def expression() (\n        return self.declare()\n      )\n      \n      def declare() (\n        if self.peek().match(\"/^[a-zA-Z_]\\\\w*$/\") != null (\n          local start @= self.getPos()\n          local ptr = self.pointer\n          local tar = self.consume()\n          void self.consumeWhitespace()\n          if self.peek() == \":\" and self.peek(2) == \"=\" (\n            void self.consume()\n            void self.consume()\n            void self.consumeWhitespace()\n            \n            local val @= self.expression()\n            \n            return {\n              kind: \"decl\",\n              tar,\n              val,\n              start, end: self.getPos()\n            }\n          )\n          self.pointer = ptr\n        )\n        \n        return self.assignment()\n      )\n      \n      def assignment() (\n        local start @= self.getPos()\n        local expr @= self.equality()\n        void self.consumeWhitespace()\n        \n        local op = null\n        \n        if self.peek() ++ self.peek(2) == \"??\" and self.peek(3) == \"=\" (\n          op = self.peek() ++ self.peek(2)\n        )\n        \n        if self.peek(2) == \"=\" and [\"+\",\"-\",\"*\",\"/\",\"%\",\"^\"].contains(self.peek()) (\n          op = self.peek()\n        )\n        \n        if op != null or self.peek() == \"=\" (\n          if op != null (\n            loop op.len (\n              void self.consume()\n            )\n          )\n          void self.consume()\n          void self.consumeWhitespace()\n          \n          local val @= self.expression()\n          \n          return {\n            kind: \"asi\",\n            op,\n            tar: expr,\n            val,\n            start, end: self.getPos()\n          }\n        )\n        \n        return expr\n      )\n      \n      def equality() (\n        local expr @= self.comparison()\n        void self.consumeWhitespace()\n        \n        while [\"==\",\"!=\"].contains(self.peek() ++ self.peek(2)) (\n          local op @= self.consume() ++ self.consume()\n          local right @= self.comparison()\n          expr @= {\n            kind: \"binary\",\n            op,\n            left: expr,\n            right\n          }\n        )\n        \n        return expr\n      )\n      \n      def comparison() (\n        local expr @= self.term()\n        \n        local end = false\n        while !end (\n          void self.consumeWhitespace()\n          if [\">\",\"<\"].contains(self.peek()) (\n            local op @= self.consume()\n            local isEql = self.peek() == \"=\"\n            if isEql (\n              op ++= self.consume()\n            )\n            \n            local right @= self.factor()\n            \n            expr @= {\n              kind: \"binary\",\n              op,\n              left: expr,\n              right\n            }\n          ) else (\n            end = true\n          )\n        )\n        \n        return expr\n      )\n      \n      def term() (\n        local expr @= self.factor()\n        void self.consumeWhitespace()\n        \n        while [\"+\",\"-\"].contains(self.peek()) and self.peek(2) != \"=\" (\n          local op @= self.consume()\n          local right @= self.factor()\n          expr @= {\n            kind: \"binary\",\n            op,\n            left: expr,\n            right\n          }\n          void self.consumeWhitespace()\n        )\n        \n        return expr\n      )\n      \n      def factor() (\n        local expr @= self.otherBinary()\n        void self.consumeWhitespace()\n        \n        while [\"*\",\"/\"].contains(self.peek()) and self.peek(2) != \"=\" (\n          local op @= self.consume()\n          local right @= self.otherBinary()\n          expr @= {\n            kind: \"binary\",\n            op,\n            left: expr,\n            right\n          }\n          void self.consumeWhitespace()\n        )\n        \n        return expr\n      )\n      \n      def otherBinary() (\n        local expr @= self.coalescence()\n        void self.consumeWhitespace()\n        \n        while [\"%\",\"^\"].contains(self.peek()) and self.peek(2) != \"=\" (\n          local op @= self.consume()\n          local right @= self.coalescence()\n          expr @= {\n            kind: \"binary\",\n            op,\n            left: expr,\n            right\n          }\n          void self.consumeWhitespace()\n        )\n        \n        return expr\n      )\n      \n      def coalescence() (\n        local expr @= self.unary()\n        void self.consumeWhitespace()\n        \n        while self.peek() ++ self.peek(2) == \"??\" and self.peek(3) != \"=\" (\n          local op @= self.consume() ++ self.consume()\n          local right @= self.unary()\n          expr @= {\n            kind: \"binary\",\n            op,\n            left: expr,\n            right\n          }\n          void self.consumeWhitespace()\n        )\n        \n        return expr\n      )\n      \n      def unary() (\n        if self.peek(2) != \"=\" (\n          switch self.peek() (\n            case \"-\"; case \"+\"; case \"!\"; case \"?\"\n              return {\n                kind: \"unary\",\n                type: self.consume(),\n                expr: self.callExpr()\n              }\n          )\n        )\n        \n        return self.callExpr()\n      )\n      \n      def callExpr() (\n        local start @= self.getPos()\n        local expr @= self.func()\n        \n        if self.peek() == \"(\" (\n          void self.consume()\n          \n          local args @= []\n          local end = self.peek() == \")\"\n          while !end (\n            local out @= self.expression()\n            if out != null (\n              void args.append(out)\n            )\n            void self.consumeWhitespace()\n            if self.peek() == \",\" (\n              void self.consume()\n            )\n            void self.consumeWhitespace()\n            if self.peek() == \")\" or self.atEnd() (\n              end = true\n            )\n          )\n          void self.expect(\")\")\n          \n          return {\n            kind: \"call\",\n            args,\n            func: expr,\n            start, end: self.getPos()\n          }\n        )\n        \n        return expr\n      )\n      \n      def func() (\n        local start @= self.getPos()\n        \n        local is = false\n        if self.peek() == \"(\" (\n          local end = false\n          local depth = 0\n          while !end (\n            local tkn @= self.consume()\n            if tkn == \"(\" (\n              depth ++\n            )\n            if tkn == \")\" (\n              depth --\n            )\n            \n            if tkn == \")\" and depth == 0 (\n              end = true\n              is = true\n            )\n            if self.atEnd() (\n              end = true\n            )\n          )\n        )\n        void self.consumeWhitespace()\n        if is and self.peek() == \"~\" (\n          self.pointer = start.i\n          \n          local args @= []\n          void self.consume()\n          void self.consumeWhitespace()\n          local end = self.peek() == \")\"\n          if self.peek() == \")\" (\n            void self.consume()\n          )\n          while !end (\n            local tkn @= self.expectText()\n            void args.append({\n              name: tkn\n            })\n            \n            void self.consumeWhitespace()\n            local ntkn = self.expects([\",\",\")\"])\n            void self.consumeWhitespace()\n            if ntkn == \")\" or self.atEnd() (\n              end = true\n            )\n          )\n          void self.consumeWhitespace()\n          void self.expect(\"~\")\n          void self.consumeWhitespace()\n          local body @= self.statement(true)\n          return {\n            kind: \"func\",\n            args,\n            body,\n            start, end: self.getPos()\n          }\n        )\n        self.pointer = start.i\n        \n        return self.objProperty()\n      )\n      \n      def objProperty() (\n        local expr @= self.primary()\n        void self.consumeWhitespace()\n        \n        while (self.peek() == \"[\" or self.peek() == \".\") and !self.atEnd() (\n          if self.peek() == \"[\" (\n            void self.consume()\n            local key @= self.expression()\n            void self.expect(\"]\")\n          ) else if self.peek() == \".\" (\n            void self.consume()\n            local key @= self.expectText()\n          ) else (\n            throw \"unexpected token '\" ++ self.peek() ++ \"'\"\n          )\n          expr @= {\n            kind: \"prop\",\n            obj: expr,\n            key\n          }\n          if self.peek() == \"(\" (\n            void self.consume()\n            \n            local args @= []\n            local end = self.peek() == \")\"\n            while !end (\n              local out @= self.expression()\n              if out != null (\n                void args.append(out)\n              )\n              void self.consumeWhitespace()\n              if self.peek() == \",\" (\n                void self.consume()\n              )\n              void self.consumeWhitespace()\n              if self.peek() == \")\" or self.atEnd() (\n                end = true\n              )\n            )\n            void self.expect(\")\")\n            \n            expr @= {\n              kind: \"call\",\n              args,\n              func: expr\n            }\n          )\n          void self.consumeWhitespace()\n        )\n        \n        return expr\n      )\n      \n      def primary() (\n        void self.consumeWhitespace()\n        \n        if self.peek() == \"(\" (\n          void self.consume()\n          local expr @= self.expression()\n          void self.expect(\")\")\n          return expr\n        )\n        \n        if self.peek() == \"[\" (\n          return self.arr()\n        )\n        \n        if self.peek() == \"{\" (\n          return self.obj()\n        )\n        \n        if self.peek() == \"#\" (\n          return self.color()\n        )\n        \n        if [\"'\",\"\\\"\",\"`\"].contains(self.peek()) (\n          return self.str()\n        )\n        \n        if self.peek().match(\"/^[0-9]+$/\") != null (\n          return self.num()\n        )\n        \n        if self.peek().match(\"/^[a-zA-Z_\\\\$][\\\\w\\\\s\\\\$]*$/\") != null (\n          local start @= self.getPos()\n          return {\n            kind: \"var\",\n            name: self.consume(),\n            start, end: self.getPos()\n          }\n        )\n        \n        throw \"unexpected token '\" ++ self.peek() ++ \"'\"\n      )\n      \n      def arr() (\n        void self.expect(\"[\")\n        void self.consumeWhitespace()\n        \n        local elems @= []\n        \n        local end = self.peek() == \"]\"\n        while !end (\n          local expr @= self.expression()\n          void elems.append(expr)\n          \n          void self.consumeWhitespace()\n          if self.peek() == \"]\" or self.atEnd() (\n            end = true\n          ) else (\n            void self.expect(\",\")\n          )\n          void self.consumeWhitespace()\n        )\n        \n        void self.expect(\"]\")\n        \n        return {\n          kind: \"arr\",\n          elems\n        }\n      )\n      \n      def obj() (\n        void self.expect(\"{\")\n        void self.consumeWhitespace()\n        \n        local pairs @= []\n        \n        local end = self.peek() == \"}\"\n        while !end (\n          void self.consumeWhitespace()\n          local name @= self.expectText()\n          void self.consumeWhitespace()\n          void self.expect(\":\")\n          void self.consumeWhitespace()\n          local value @= self.expression()\n          \n          void pairs.append({ name, value })\n          \n          void self.consumeWhitespace()\n          if self.peek() == \"}\" (\n            end = true\n          ) else (\n            void self.expect(\",\")\n          )\n        )\n        void self.expect(\"}\")\n        \n        return {\n          kind: \"obj\",\n          pairs\n        }\n      )\n      \n      def color() (\n        local start @= self.getPos()\n        void self.expect(\"#\")\n        local value = self.consume()\n        if ![3,6].contains(value.len) (\n          throw \"hex values can only be 3 or 6 characters long\"\n        )\n        return {\n          kind: \"color\",\n          val: \"#\" ++ value,\n          start, end: self.getPos()\n        }\n      )\n      \n      def str() (\n        local start @= self.getPos()\n        local q @= self.expects([\"'\",\"\\\"\",\"`\"])\n        local content = \"\"\n        local end = false\n        while (!end) (\n          local tkn @= self.peek()\n          if tkn == \"\\\\\" (\n            void self.consume()\n            local tkn = self.consume()\n            local char = tkn[1]\n            switch char (\n              case \"n\"\n                char = \"\\n\"\n                break\n            )\n            content ++= char ++ tkn.trim(2,-1)\n            continue\n          )\n          \n          if q == tkn (\n            end = true\n          ) else (\n            content ++= self.consume()\n          )\n          if self.atEnd() (\n            end = true\n          )\n        )\n        void self.expect(q)\n        return {\n          kind: \"str\",\n          val: content,\n          start, end: self.getPos()\n        }\n      )\n      \n      def num() (\n        if self.peek().match(\"/^[0-9]+$/\") == null (\n          throw \"unexpected token '\" ++ self.peek() ++ \"'\"\n        )\n        \n        local start @= self.getPos()\n        local val @= self.consume()\n        \n        if self.peek() == \".\" (\n          val ++= self.consume()\n          if self.peek().match(\"/^[0-9]+$/\") == null (\n            throw \"unexpected token '\" ++ self.peek() ++ \"'\"\n          )\n          val ++= self.consume()\n        )\n        \n        val @= val.toNum()\n        \n        return {\n          kind: \"num\",\n          val,\n          start, end: self.getPos()\n        }\n      )\n    )\n  )\n  return __imports__2691a00e099698fa56c4748f2551eb65\ncase \"./src/rtr/main.osl\"\n  class __imports__954b63a69b7120a02fa83923726ef587 (\n    class Module (\n      def init(object ast) (\n        void self.loadFromAst(ast)\n        void self.initScope()\n        void self.defScope()\n        \n        self.eventQueue @= []\n        self.initTopDone = false\n        \n        // only used in bytecode\n        self.returnVal = null\n      )\n      def loadFromAst(object ast) (\n        self.ast @= ast\n        \n        self.events @= []\n        self.eventList @= []\n        for i self.ast.elements.len (\n          local topLevel @= self.ast.elements[i]\n          if topLevel.kind == \"event\" (\n            if topLevel.target.kind == \"global\" (\n              if self.eventList.contains(topLevel.target.target) (\n                throw topLevel.target.target + \"event already exists on module\"\n              )\n              void self.eventList.append(topLevel.target.target)\n            )\n            void self.events.append([\n              topLevel.target,\n              topLevel\n            ])\n          )\n        )\n      )\n      def initTop() (\n        if self.initTopDone (\n          return\n        )\n        self.initTopDone = true\n        \n        self.ast @= ast\n        \n        void self.newScope({})\n        for i self.ast.elements.len (\n          local topLevel @= self.ast.elements[i]\n          if topLevel.kind == \"global\" (\n            local val @= self.runExpression(topLevel.val)\n            local meta = null\n            if topLevel.auto (\n              meta @= {\n                type: val.getRtrType()\n              }\n            )\n            void self.declScopeVar(topLevel.name, val, meta)\n          )\n        )\n      )\n      \n      def initScope() (\n        self.scope @= []\n      )\n      def newScope(object vars) (\n        void self.scope.append(vars)\n      )\n      def popScope() (\n        return self.scope.pop()\n      )\n      def defScope() (\n        // helper funcs\n        local cFunc @= def(name, content) -> (\n          void self.setScopeVar(name, rtr.value.RTROslFuncValue(content))\n        )\n        \n        void self.newScope({})\n        \n        void self.setScopeVar(\"true\", rtr.value.RTRBoolValue(true))\n        void self.setScopeVar(\"false\", rtr.value.RTRBoolValue(false))\n        \n        cFunc(\"log\", def(args, inst) -> (\n          local txt = args.map(a -> a.stringify()).join(\" \")\n          log txt\n          void inst.inst.console.append([\"log\", txt])\n        ))\n        cFunc(\"error\", def(args, inst) -> (\n          local txt = args.map(a -> a.stringify()).join(\" \")\n          void inst.inst.console.append([\"err\", txt])\n          throw txt\n        ))\n        cFunc(\"return\", def(args, inst) -> (\n          local val @= args[1]\n          val ??= rtr.value.RTRNullValue()\n          void inst.setScopeVar(\"@return\", val)\n          inst.returnVal @= val\n        ))\n        cFunc(\"typeof\", def(args) -> (\n          local val @= args[1] ?? rtr.value.RTRNullValue()\n          return val.getRtrType()\n        ))\n        cFunc(\"length\", def(args) -> (\n          return rtr.value.RTRNumValue(args[1].length())\n        ))\n        \n        // mathematical\n        cFunc(\"min\", def(args) -> (\n          local v = args[1].numbify()\n          for i args.len - 1 (\n            local a @= args[i + 1].numbify()\n            v = min(v, a)\n          )\n          return rtr.value.RTRNumValue(v)\n        ))\n        cFunc(\"max\", def(args) -> (\n          local v = args[1].numbify()\n          for i args.len - 1 (\n            local a @= args[i + 1].numbify()\n            v = max(v, a)\n          )\n          return rtr.value.RTRNumValue(v)\n        ))\n        \n        cFunc(\"abs\", def(args) -> (\n          return rtr.value.RTRNumValue(args[1].numbify().abs())\n        ))\n        cFunc(\"sqrt\", def(args) -> (\n          return rtr.value.RTRNumValue(args[1].numbify().sqrt())\n        ))\n        \n        cFunc(\"round\", def(args) -> (\n          return rtr.value.RTRNumValue(args[1].numbify().round())\n        ))\n        cFunc(\"floor\", def(args) -> (\n          return rtr.value.RTRNumValue(args[1].numbify().floor())\n        ))\n        cFunc(\"ceil\", def(args) -> (\n          return rtr.value.RTRNumValue(args[1].numbify().ceiling())\n        ))\n        \n        // string\n        cFunc(\"join\", def(args) -> (\n          local txt = \"\"\n          for i args.len (\n            txt ++= args[i].stringify()\n          )\n          return rtr.value.RTRStrValue(txt)\n        ))\n        cFunc(\"split\", def(args) -> (\n          return rtr.value.RTRArrValue(args[1]\n            .stringify()\n            .split(args[2].stringify())\n            .map(e -> rtr.value.RTRStrValue(e)))\n        ))\n        \n        cFunc(\"chr\", def(args) -> (\n          return rtr.value.RTRStrValue(args[1].numbify().chr())\n        ))\n        cFunc(\"ord\", def(args) -> (\n          return rtr.value.RTRNumValue(args[1].stringify().ord())\n        ))\n        \n        cFunc(\"toUpper\", def(args) -> (\n          return rtr.value.RTRStrValue(args[1].stringify().toUpper())\n        ))\n        cFunc(\"toLower\", def(args) -> (\n          return rtr.value.RTRStrValue(args[1].stringify().toLower())\n        ))\n        cFunc(\"toTitle\", def(args) -> (\n          return rtr.value.RTRStrValue(args[1].stringify().toTitle())\n        ))\n        \n        // array\n        cFunc(\"item\", def(args) -> (\n          return args[1].getItem(args[2])\n        ))\n        cFunc(\"range\", def(args) -> (\n          return rtr.value.RTRArrValue((args[1].numbify() to args[2].numbify()).map(e -> rtr.value.RTRNumValue(e)))\n        ))\n        \n        // object\n        cFunc(\"keys\", def(args) -> (\n          return rtr.value.RTRArrValue(args[1].keys().map(e -> rtr.value.RTRStrValue(e)))\n        ))\n        cFunc(\"values\", def(args) -> (\n          return rtr.value.RTRArrValue(args[1].values())\n        ))\n        cFunc(\"has\", def(args) -> (\n          return rtr.value.RTRBoolValue(args[1].has(args[2].stringify()))\n        ))\n        cFunc(\"obj\", def() -> (\n          return rtr.value.RTRObjValue({})\n        ))\n        \n        // logical\n        cFunc(\"all\", def(args) -> (\n          return rtr.value.RTRBoolValue(args.every(a -> a.boolify()))\n        ))\n        cFunc(\"any\", def(args) -> (\n          return rtr.value.RTRBoolValue(args.some(a -> a.boolify()))\n        ))\n        cFunc(\"not\", def(args) -> (\n          return rtr.value.RTRBoolValue(!args[1].boolify())\n        ))\n      )\n      def getScopeVarRaw(string key) (\n        for rawI self.scope.len (\n          local layer @= self.scope[self.scope.len - rawI + 1]\n          if layer[key] != null (\n            return layer[key]\n          )\n        )\n        return null\n      )\n      def getScopeVar(string key) (\n        return self.getScopeVarRaw(key)[1]\n      )\n      def getScopeVarMeta(string key) (\n        return self.getScopeVarRaw(key)[2]\n      )\n      def setScopeVar(string key, val, meta) (\n        meta ??= {}\n        for rawI self.scope.len (\n          local layer @= self.scope[self.scope.len - rawI + 1]\n          if layer[key] != null (\n            layer[key] @= [val, layer[key][2] ++ meta]\n            return\n          )\n        )\n        void self.declScopeVar(key, val, meta)\n      )\n      def declScopeVar(string key, val, meta) (\n        self.scope[self.scope.len][key] @= [val, meta]\n      )\n      \n      def findEligible(object target) (\n        local evs @= []\n        \n        for i self.events.len (\n          local ev @= self.events[i][2]\n          \n          if target.element != null (\n            if ev.target.kind == \"property\" and ev.target.eventName == target.name (\n              if ev.target.target.kind == \"id\" (\n                if ev.target.target.name == target.element.id (\n                  void evs.append(ev)\n                )\n              )\n            )\n          ) else if typeof(ev.target.target) == \"string\" (\n            if ev.target.target == target.name (\n              void evs.append(ev)\n            )\n          )\n        )\n        \n        return evs\n      )\n      \n      def runEvents(object target, object data) (\n        void self.eventQueue.append([\n          \"events\",\n          target,\n          data\n        ])\n      )\n      def runEvent(object target, object data) (\n        void self.eventQueue.append([\n          \"event\",\n          target,\n          data\n        ])\n      )\n      \n      def runEventQueue() (\n        for i self.eventQueue.len (\n          local ev @= self.eventQueue.shift()\n          \n          if ev[1] == \"events\" (\n            void self.runEventsRaw(ev[2], ev[3])\n          )\n          if ev[1] == \"event\" (\n            void self.runEventRaw(ev[2], ev[3])\n          )\n        )\n      )\n      \n      def runEventsRaw(object target, object data) (\n        local evs @= self.findEligible(target)\n        \n        void self.initTop()\n        for i evs.len (\n          void self.runBlock(evs[i].body)\n        )\n      )\n      def runEventRaw(object target, object data) (\n        local ev @= self.findEligible(target)[1]\n        \n        if ev == null (\n          return rtr.value.RTRNullValue()\n        )\n        \n        void self.initTop()\n        return self.runBlock(ev.body)\n      )\n      def runBlock(object block) (\n        if shared.config.browser.phosphorus.useCompiler and block.compile == null (\n          local start = performance\n          local compileOut @= rtr.compiler.compileBlock(block)\n          if typeof(compileOut) != \"array\" and compileOut.isError (\n            block.compile = false\n          ) else (\n            block.compile @= compileOut\n          )\n          self.inst.compiled ??= []\n          void self.inst.compiled.append({\n            body: compileOut,\n            start: block.start,\n            end: block.end,\n            ast: block,\n            time: start - performance\n          })\n        )\n        if block.compile != null (\n          return self.runInstructions(block.compile)\n        )\n        \n        local elements @= block.elements\n        local outVal @= rtr.value.RTRNullValue()\n        void self.newScope({})\n        for i elements.len (\n          local out @= self.runStatement(elements[i])\n          if self.getScopeVar(\"@return\") ?? 0 != 0 (\n            outVal @= self.getScopeVar(\"@return\")\n            break\n          )\n        )\n        void self.popScope()\n        return outVal\n      )\n      def runStatement(object statement) (\n        switch statement.kind (\n          case \"expression\"\n            return self.runExpression(statement.expr)\n          case \"block\"\n            return self.runBlock(statement.body)\n          \n          case \"branch\"\n            if self.runExpression(statement.cond).boolify() (\n              return self.runStatement(statement.body)\n            )\n            for i statement.elifs.len (\n              local elif @= statement.elifs[i]\n              if self.runExpression(elif.cond).boolify() (\n                return self.runStatement(elif.body)\n              )\n            )\n            if statement.elseBody != null (\n              return self.runStatement(statement.elseBody)\n            )\n            return rtr.value.RTRNullValue()\n          \n          case \"while\"\n            local iters = 0\n            while self.runExpression(statement.cond).boolify() and self.getScopeVar(\"@return\") ?? 0 == 0 and iters < 999999 (\n              void self.runStatement(statement.body)\n              iters ++\n            )\n            return rtr.value.RTRNullValue()\n          case \"until\"\n            local iters = 0\n            while !self.runExpression(statement.cond).boolify() and self.getScopeVar(\"@return\") ?? 0 == 0 and iters < 999999 (\n              void self.runStatement(statement.body)\n              iters ++\n            )\n            return rtr.value.RTRNullValue()\n          case \"repeat\"\n            loop self.runExpression(statement.amount).numbify() (\n              void self.runStatement(statement.body)\n            )\n            return rtr.value.RTRNullValue()\n          case \"for\"\n            local arr @= self.runExpression(statement.arr).arrify()\n            for i arr.len (\n              void self.newScope({})\n              void self.declScopeVar(statement.var, arr[i])\n              void self.runStatement(statement.body)\n              void self.popScope()\n            )\n            return rtr.value.RTRNullValue()\n          \n          default\n            throw \"unknown statement type\" + statement.kind\n        )\n      )\n      def runExpression(object expression) (\n        switch expression.kind (\n          case \"call\"\n            local func @= self.runExpression(expression.func)\n            local args @= []\n            for i expression.args.len (\n              void args.append(self.runExpression(expression.args[i]))\n            )\n            return func.callFunc(self, args) ?? rtr.value.RTRNullValue()\n          case \"decl\"\n            local val @= self.runExpression(expression.val)\n            \n            void self.declScopeVar(expression.tar, val, {\n              type: val.getRtrType()\n            })\n            \n            return val\n          case \"asi\"\n            local val @= self.runExpression(expression.val)\n            \n            local existingMeta = null\n            local existing = null\n            switch expression.tar.kind (\n              case \"var\"\n                existingMeta @= self.getScopeVarMeta(expression.tar.name)\n                existing @= self.getScopeVar(expression.tar.name)\n                break\n              case \"prop\"\n                existing @= self.runExpression(expression.tar)\n                break\n            )\n            \n            if expression.op != null (\n              val @= self.runBinary(existing, expression.op, val)\n            )\n            \n            switch expression.tar.kind (\n              case \"var\"\n                if existingMeta != null (\n                  local curType @= val.getRtrType()\n                  if existingMeta.type != null (\n                    if !existingMeta.type.isEqual(curType) (\n                      throw \"cannot assign\" + curType.stringify() + \"to\" + existingMeta.type.stringify() + \"variable\" \n                    )\n                  )\n                )\n                void self.setScopeVar(expression.tar.name, val)\n                break\n              case \"prop\"\n                local obj @= self.runExpression(expression.tar.obj)\n                local key @= expression.tar.key\n                if typeof(key) == \"string\" (\n                  key @= rtr.value.RTRStrValue(key)\n                ) else (\n                  key @= self.runExpression(key)\n                )\n                void obj.setItem(key, val)\n                break\n              default\n                throw \"cannot assign to\" + expression.tar.kind\n            )\n            \n            return val\n          case \"unary\"\n            local val @= self.runExpression(expression.expr)\n            return self.runUnary(expression.type, val)\n          case \"binary\"\n            local left @= self.runExpression(expression.left)\n            local right @= self.runExpression(expression.right)\n            return self.runBinary(left, expression.op, right)\n          \n          case \"var\"\n            local val @= self.getScopeVar(expression.name)\n            return val ?? rtr.value.RTRNullValue()\n          case \"prop\"\n            local obj @= self.runExpression(expression.obj)\n            local key @= expression.key\n            if typeof(key) == \"string\" (\n              key @= rtr.value.RTRStrValue(key)\n            ) else (\n              key @= self.runExpression(key)\n            )\n            return obj.getItem(key) ?? rtr.value.RTRNullValue()\n          \n          case \"str\"\n            return rtr.value.RTRStrValue(expression.val)\n          case \"num\"\n            return rtr.value.RTRNumValue(expression.val)\n          case \"func\"\n            return rtr.value.RTRAstFuncValue(expression.args, expression.body)\n          case \"arr\"\n            return rtr.value.RTRArrValue(expression.elems.map(e -> self.runExpression(e)))\n          case \"obj\"\n            local val @= {}\n            for i expression.pairs.len (\n              local pair @= expression.pairs[i]\n              val[pair.name] @= self.runExpression(pair.value)\n            )\n            return rtr.value.RTRObjValue(val)\n          case \"color\"\n            return rtr.value.RTRColorValue(expression.val)\n          \n          default\n            throw \"unknown expression type\" + expression.kind\n        )\n      )\n      def runUnary(string op, object val) (\n        switch op (\n          case \"-\"\n            return rtr.value.RTRNumValue(-val.numbify())\n          case \"+\"\n            return rtr.value.RTRNumValue(val.numbify())\n          case \"!\"\n            return rtr.value.RTRBoolValue(!val.boolify())\n          case \"?\"\n            return rtr.value.RTRBoolValue(val.boolify())\n        )\n        return rtr.value.RTRNullValue()\n      )\n      def runBinary(object left, string op, object right) (\n        local numT @= rtr.value.RTRNumValue.getRtrType()\n        switch op (\n          case \"+\"\n            if left.getRtrType().isEqual(numT) and right.getRtrType().isEqual(numT) (\n              return rtr.value.RTRNumValue(left.numbify() + right.numbify())\n            )\n            return rtr.value.RTRStrValue(left.stringify() ++ right.stringify())\n          case \"-\"\n            if left.getRtrType().isEqual(numT) and right.getRtrType().isEqual(numT) (\n              return rtr.value.RTRNumValue(left.numbify() - right.numbify())\n            )\n            return rtr.value.RTRNumValue(NaN)\n          case \"*\"\n            if left.getRtrType().isEqual(numT) and right.getRtrType().isEqual(numT) (\n              return rtr.value.RTRNumValue(left.numbify() * right.numbify())\n            )\n            return rtr.value.RTRNumValue(NaN)\n          case \"/\"\n            if left.getRtrType().isEqual(numT) and right.getRtrType().isEqual(numT) (\n              return rtr.value.RTRNumValue(left.numbify() / right.numbify())\n            )\n            return rtr.value.RTRNumValue(NaN)\n          case \"%\"\n            if left.getRtrType().isEqual(numT) and right.getRtrType().isEqual(numT) (\n              return rtr.value.RTRNumValue(left.numbify() % right.numbify())\n            )\n            return rtr.value.RTRNumValue(NaN)\n          case \"^\"\n            if left.getRtrType().isEqual(numT) and right.getRtrType().isEqual(numT) (\n              return rtr.value.RTRNumValue(left.numbify() ^ right.numbify())\n            )\n            return rtr.value.RTRNumValue(NaN)\n          \n          case \"==\"\n            return rtr.value.RTRBoolValue(left.isEqual(right))\n          case \"!=\"\n            return rtr.value.RTRBoolValue(left.isEqual(right))\n          \n          case \">\"\n            return rtr.value.RTRBoolValue(left.numbify() > right.numbify())\n          case \"<\"\n            return rtr.value.RTRBoolValue(left.numbify() < right.numbify())\n          case \">=\"\n            return rtr.value.RTRBoolValue(left.numbify() >= right.numbify())\n          case \"<=\"\n            return rtr.value.RTRBoolValue(left.numbify() <= right.numbify())\n        \n          case \"??\"\n            return left.getRtrType().data.name == \"null\" ? right left\n        )\n        \n        return rtr.value.RTRNullValue()\n      )\n      \n      def runInstructions(array instructions) (\n        self.stack ??= []\n        \n        local labels @= {}\n        \n        for i instructions.len (\n          local instruction @= instructions[i]\n          if instruction.kind == \"label\" (\n            labels[instruction.name] = i\n          )\n        )\n        \n        local i = 0\n        local iters = 0\n        while i < instructions.len and iters < 1000 (\n          i ++\n          iters ++\n          local instruction @= instructions[i]\n          //log i iters instruction self.stack.map(s -> s.stringify())\n          switch instruction.kind (\n            case \"label\"; break\n            case \"jump\"\n              i = labels[instruction.label] ?? i\n              break\n            case \"jumpIf\"\n              local val @= self.stack.pop() ?? rtr.value.RTRNullValue()\n              if val.boolify() (\n                i = labels[instruction.label] ?? i\n              )\n              break\n            case \"jumpNotIf\"\n              local val @= self.stack.pop() ?? rtr.value.RTRNullValue()\n              if !val.boolify() (\n                i = labels[instruction.label] ?? i\n              )\n              break\n            \n            case \"call\"\n              local args @= []\n              loop instruction.args (\n                void args.prepend(self.stack.pop() ?? rtr.value.RTRNullValue())\n              )\n              local func @= self.stack.pop() ?? rtr.value.RTRNullValue()\n              local out @= func.callFunc(self, args) ?? rtr.value.RTRNullValue()\n              if self.returnVal != null (\n                local out @= self.returnVal\n                self.returnVal = null\n                return out\n              )\n              void self.stack.append(out)\n              break\n            case \"unary\"\n              local val @= self.stack.pop() ?? rtr.value.RTRNullValue()\n              void self.stack.append(self.runUnary(instruction.op, val))\n              break\n            case \"binary\"\n              local right @= self.stack.pop() ?? rtr.value.RTRNullValue()\n              local left @= self.stack.pop() ?? rtr.value.RTRNullValue()\n              void self.stack.append(self.runBinary(left, instruction.op, right))\n              break\n            case \"prop\"\n              local key @= self.stack.pop() ?? rtr.value.RTRNullValue()\n              local obj @= self.stack.pop() ?? rtr.value.RTRNullValue()\n              void self.stack.append(obj.getItem(key))\n              break\n            case \"len\"\n              local obj @= self.stack.pop() ?? rtr.value.RTRNullValue()\n              void self.stack.append(rtr.value.RTRNumValue(obj.length()))\n              break\n              \n            case \"null\"\n              void self.stack.append(rtr.value.RTRNullValue())\n              break\n            case \"str\"\n              void self.stack.append(rtr.value.RTRStrValue(instruction.data))\n              break\n            case \"bool\"\n              void self.stack.append(rtr.value.RTRBoolValue(instruction.data))\n              break\n            case \"num\"\n              void self.stack.append(rtr.value.RTRNumValue(instruction.data))\n              break\n            case \"func\"\n              void self.stack.append(rtr.value.RTRBytecodeFuncValue(instruction.args, instruction.body))\n              break\n            case \"arr\"\n              local elems @= []\n              loop instruction.elems (\n                void elems.prepend(self.stack.pop() ?? rtr.value.RTRNullValue())\n              )\n              void self.stack.append(rtr.value.RTRArrValue(elems))\n              break\n            case \"obj\"\n              local values @= []\n              loop instruction.keys.len (\n                void values.prepend(self.stack.pop() ?? rtr.value.RTRNullValue())\n              )\n              \n              local obj @= {}\n              for obji values.len (\n                obj[instruction.keys[obji]] @= values[obji]\n              )\n              void self.stack.append(rtr.value.RTRObjValue(obj))\n              break\n            case \"color\"\n              void self.stack.append(rtr.value.RTRColorValue(instruction.data))\n              break\n            \n            case \"get\"\n              local val @= self.getScopeVar(instruction.name) ?? rtr.value.RTRNullValue()\n              void self.stack.append(val)\n              break\n            case \"decl\"\n              local val @= self.stack[-1] ?? rtr.value.RTRNullValue()\n              void self.declScopeVar(instruction.name, val, {\n                type: val.getRtrType()\n              })\n              break\n            case \"newScope\"\n              void self.newScope({})\n              break\n            case \"popScope\"\n              void self.popScope()\n              break\n            \n            case \"asivar\"\n              local val @= self.stack[-1] ?? rtr.value.RTRNullValue()\n              \n              local existingMeta @= self.getScopeVarMeta(instruction.name)\n              local existing @= self.getScopeVar(instruction.name)\n              \n              if instruction.op != null (\n                val @= self.runBinary(existing, instruction.op, val)\n              )\n              \n              local curType @= val.getRtrType()\n              if existingMeta.type != null (\n                if !existingMeta.type.isEqual(curType) (\n                  // replace with return err\n                  throw \"cannot assign\" + curType.stringify() + \"to\" + existingMeta.type.stringify() + \"variable\" \n                )\n              )\n              \n              void self.setScopeVar(instruction.name, val)\n              break\n            case \"asiprop\"\n              local key @= self.stack.pop() ?? rtr.value.RTRNullValue()\n              local obj @= self.stack.pop() ?? rtr.value.RTRNullValue()\n              \n              local val @= self.stack[-1] ?? rtr.value.RTRNullValue()\n              if instruction.op != null (\n                val @= self.runBinary(obj.getItem(key), instruction.op, val)\n              )\n              \n              void obj.setItem(key, val)\n              break\n            \n            case \"pop\"\n              void self.stack.pop()\n              break\n            case \"dupe\"\n              void self.stack.append(self.stack[instruction.i])\n              break\n            \n            default\n              return rtr.error.Error(\"UnknownInstructionKind\", { kind: instruction.kind })\n          )\n          \n        )\n        \n        return rtr.value.RTRNullValue()\n      )\n    )\n    \n    class RTR (\n      def init() (\n        self.modules @= {}\n        self.console @= []\n        self.ouid = OuidNew()\n        \n        self.started = false\n      )\n    \n      def addModule(object mod) (\n        local key @= OuidNew()\n        mod.inst @= self\n        self.modules[key] @= mod\n        return key\n      )\n      \n      def startModules() (\n        if !self.started (\n          self.started = true\n          void self.runEvent({\n           name: \"onload\"\n          }, {})\n        )\n      )\n      \n      def runEvent(object target, object data) (\n        local mods @= self.modules.getValues()\n        for i mods.len (\n          void mods[i].runEvent(target, data)\n        )\n      )\n      def runEvents(object target, object data) (\n        local mods @= self.modules.getValues()\n        for i mods.len (\n          void mods[i].runEvents(target, data)\n        )\n      )\n    )\n  )\n  return __imports__954b63a69b7120a02fa83923726ef587\ncase \"./src/rwl/ast.osl\"\n  class __imports__823191bbaeb9397e6eaf51c446a37c4c (\n    class Parser (\n      def init(string text) (\n        void self.tokenise(text)\n      )\n      \n      def parse() (\n        self.pointer = 1\n        \n        local out @= {\n          elements: self.blockContent()\n        }\n        \n        if !self.atEnd() (\n          throw \"unexpected token '\" ++ self.peek() ++ \"'\"\n        )\n        \n        return out\n      )\n      \n      def peek() (\n        return self.tokens[self.pointer]\n      )\n      def consume() (\n        local tkn = self.peek()\n        self.pointer ++\n        return tkn\n      )\n      def consumeWhitespace() (\n        while self.peek().match(\"/^\\\\s$/\") != null (\n          void self.consume()\n        )\n      )\n      def consumeSpaces() (\n        local txt = \"\"\n        while self.peek() == \" \" (\n          txt ++= self.consume()\n        )\n        return txt\n      )\n      def atEnd() (\n        return self.pointer >= self.tokens.len\n      )\n      def expect(string token) (\n        local tkn @= self.consume()\n        if tkn != token (\n          throw \"expected '\" ++ token ++ \"' got '\" ++ tkn ++ \"'\"\n        )\n        return tkn\n      )\n      def expects(array tokens) (\n        local tkn @= self.consume()\n        if !tokens.contains(tkn) (\n          throw \"expected '\" ++ tokens.join(\" or \") ++ \"' got '\" ++ tkn ++ \"'\"\n        )\n        return tkn\n      )\n      def expectText() (\n        local tkn @= self.consume()\n        if !tkn.match(\"/^[a-zA-Z_0-9]+$/\") (\n          throw \"identifier must consist of letters or _\"\n        )\n        return tkn\n      )\n      def getPos() (\n        local ln = 1\n        local col = 0\n        local i = self.pointer\n        for t self.pointer (\n          col ++\n          if self.tokens[t] == \"\\n\" (\n            ln ++\n            col = 0\n          )\n        )\n        return { ln, col, i }\n      )\n      \n      def tokenise(string text) (\n        self.tokens @= []\n        local splitChars @= [\n          // rwl\n          \"{\",\"}\",\n          \"[\",\"]\",\n          \",\",\n          \" \",\n          \"\\n\",\n          \"/\",\"\\\\\",\"*\",\n          \"'\",\"\\\"\",\"`\",\n          \":\",\"#\",\"%\",\"=\",\n          // rtr\n          \"(\",\")\",\n          \"[\",\"]\",\n          \"{\",\"}\",\n          \",\",\";\",\":\",\"=\",\".\",\n          \"+\",\"-\",\"*\",\"/\",\"%\",\"^\",\n          \"\\\\\",\n          \"'\",\"\\\"\",\"`\",\n          \" \",\"\\n\",\n          \"!\",\"?\"\n        ]\n        local buf = \"\"\n        for i text.len (\n          if splitChars.contains(text[i]) (\n            if buf.len > 0 (\n              void self.tokens.append(buf)\n            )\n            void self.tokens.append(text[i])\n            buf = \"\"\n          ) else (\n            buf ++= text[i]\n          )\n        )\n        if buf.len > 0 (\n          self.tokens.append(buf)\n        )\n      )\n      \n      // statements\n      def blockContent() (\n        local statements @= []\n        local end = false\n        while !end (\n          local out @= self.statement()\n          if out != null (\n            void statements.append(out)\n          )\n          void self.consumeWhitespace()\n          log self.atEnd()\n          if self.peek() == \"}\" or self.atEnd() (\n            end = true\n          ) else (\n            void self.expect(\",\")\n          )\n        )\n        return statements\n      )\n      \n      def statement() (\n        void self.consumeWhitespace()\n        \n        local start @= self.getPos()\n        local tkn @= self.peek()\n        \n        // void elements\n        if [\"icon\",\"image\"].contains(tkn) (\n          void self.consume()\n          void self.consumeWhitespace()\n          local header @= self.header()\n          \n          return {\n            data: {\n              header\n            },\n            kind: tkn,\n            start, end: self.getPos()\n          }\n        )\n        \n        // block\n        if tkn.match(\"/^[a-zA-Z]+$/\") != null (\n          return self.blockStatement()\n        )\n        \n        // element\n        local value @= self.value()\n        if value != null (\n          void self.consumeWhitespace()\n          local header @= self.header()\n          \n          return {\n            data: {\n              value,\n              header\n            },\n            kind: \"element\",\n            start, end: self.getPos()\n          }\n        )\n      )\n      \n      def blockStatement() (\n        local start @= self.getPos()\n        local key @= self.consume()\n        \n        void self.consumeWhitespace()\n        \n        local header @= self.header()\n        header.key = key\n        \n        void self.consumeWhitespace()\n        \n        if key == \"script\" (\n          local content = \"\"\n          local spaceContent = \"\"\n          void self.expect(\"{\")\n          local end = false\n          local depth = 1\n          local stringType = null\n          while !end (\n            local tkn @= self.peek()\n            \n            if tkn == \"'\" (\n              if stringType == \"'\" (\n                stringType = null\n              ) else if stringType == null (\n                stringType = \"'\"\n              )\n            )\n            \n            if tkn == \"\\\"\" (\n              if stringType == \"\\\"\" (\n                stringType = null\n              ) else if stringType == null (\n                stringType = \"\\\"\"\n              )\n            )\n            \n            if tkn == \"`\" (\n              if stringType == \"`\" (\n                stringType = null\n              ) else if stringType == null (\n                stringType = \"`\"\n              )\n            )\n            \n            if stringType == null (\n              if tkn == \"{\" (\n                depth ++\n              )\n              if tkn == \"}\" (\n                depth --\n              )\n            )\n            \n            if self.atEnd() or (tkn == \"}\" and depth == 0 and stringType == null) (\n              end = true\n            ) else (\n              if tkn == \"\\n\" (\n                spaceContent = \"\"\n                void self.consume()\n                if content != \"\" (\n                  content ++= \"\\n\"\n                )\n              ) else if tkn == \" \" (\n                spaceContent ++= self.consume()\n              ) else (\n                content ++= spaceContent\n                content ++= self.consume()\n                spaceContent = \"\"\n              )\n            )\n          )\n          void self.expect(\"}\")\n        ) else (\n          local content @= self.block()\n        )\n        \n        return {\n          kind: \"block\",\n          data: {\n            header,\n            content\n          },\n          start, end: self.getPos()\n        }\n      )\n      \n      def block() (\n        local start @= self.getPos()\n        void self.expect(\"{\")\n        void self.consumeWhitespace()\n        local elements @= self.blockContent()\n        void self.consumeWhitespace()\n        void self.expect(\"}\")\n        return { elements, start, end: self.getPos() }\n      )\n      \n      // header stuff\n      def header() (\n        local start @= self.getPos()\n        local attributes @= []\n        if self.peek() == \"[\" (\n          void self.expect(\"[\")\n          local end = self.peek() == \"]\"\n          while !end (\n            local out @= self.headerItem()\n            if out != null (\n              void attributes.append(out)\n            )\n            void self.consumeWhitespace()\n            if self.peek() == \",\" (\n              void self.consume()\n            )\n            if self.peek() == \"]\" or self.atEnd() (\n              end = true\n            )\n          )\n          void self.expect(\"]\")\n        )\n        \n        return { attributes, start, end: self.getPos() }\n      )\n      def headerItem() (\n        void self.consumeWhitespace()\n        local start @= self.getPos()\n        local tkn @= self.consume()\n        void self.consumeWhitespace()\n        if self.peek() == \"=\" (\n          if tkn.match(\"/^[a-zA-Z_]+$/\") == null (\n            throw \"attribute key must consist of letters or _\"\n          )\n          void self.consume()\n          local value @= self.value()\n          return {\n            kind: \"key\",\n            key: tkn,\n            value,\n            start, end: self.getPos()\n          }\n        )\n        if tkn.match(\"/^[a-zA-Z_]+$/\") != null (\n          return {\n            kind: \"flag\",\n            data: tkn,\n            start, end: self.getPos()\n          }\n        )\n      )\n      \n      // values\n      def value() (\n        log self.peek()\n        if [\"'\",\"\\\"\",\"`\"].contains(self.peek()) (\n          return self.str()\n        )\n        \n        if self.peek().match(\"/^[0-9]+$/\") != null (\n          return self.num()\n        )\n        \n        if self.peek() == \"#\" (\n          return self.color()\n        )\n        \n        if self.peek().match(\"/^\\\\w+$/\") != null (\n          return self.property()\n        )\n      )\n      \n      def str() (\n        local start @= self.getPos()\n        local q @= self.expects([\"'\",\"\\\"\",\"`\"])\n        local content = \"\"\n        local end = false\n        while !end (\n          local tkn @= self.peek()\n          if tkn == \"\\\\\" (\n            void self.consume()\n            local tkn = self.consume()\n            local char = tkn[1]\n            switch char (\n              case \"n\"\n                char = \"\\n\"\n                break\n            )\n            content ++= char ++ tkn.trim(2,-1)\n            continue\n          )\n          \n          if q == tkn (\n            end = true\n          ) else (\n            content ++= self.consume()\n          )\n          if self.atEnd() (\n            end = true\n          )\n        )\n        void self.expect(q)\n        return {\n          type: \"str\",\n          value: content,\n          start, end: self.getPos()\n        }\n      )\n      \n      // and percentage\n      def num() (\n        if self.peek().match(\"/^[0-9]+$/\") == null (\n          throw \"unexpected token '\" ++ self.peek() ++ \"'\"\n        )\n        \n        local start @= self.getPos()\n        \n        local value @= self.consume().toNum()\n        \n        local type = \"num\"\n        \n        if self.peek() == \"%\" (\n          void self.consume()\n          type = \"percentage\"\n        )\n        \n        return {\n          type,\n          value,\n          start, end: self.getPos()\n        }\n      )\n      \n      def color() (\n        local start @= self.getPos()\n        void self.expect(\"#\")\n        local value = self.consume()\n        if ![3,6].contains(value.len) (\n          throw \"hex values can only be 3 or 6 characters long\"\n        )\n        return {\n          type: \"color\",\n          value: \"#\" ++ value,\n          start, end: self.getPos()\n        }\n      )\n      \n      def property() (\n        local start @= self.getPos()\n        local source = self.consume()\n        if source.match(\"/^[a-zA-Z_]+$/\") == null (\n          throw \"source must consist of letters or _\"\n        )\n        \n        void self.consumeWhitespace()\n        void self.expect(\":\")\n        void self.consumeWhitespace()\n        \n        local name = self.consume()\n        if name.match(\"/^[a-zA-Z_]+$/\") == null (\n          throw \"name must consist of letters or _\"\n        )\n        \n        return {\n          type: \"property\",\n          source,\n          name,\n          start, end: self.getPos()\n        }\n      )\n    )\n  )\n  return __imports__823191bbaeb9397e6eaf51c446a37c4c\ncase \"./src/rwl/debug.osl\"\n  class __imports__a02a29842cf0d752bb9291888afe9568 (\n    def box(array area, color) (\n      if !rwl.main.debug (\n        return\n      )\n      void shared.graphics.box(area, color ?? #f00)\n    )\n  )\n  return __imports__a02a29842cf0d752bb9291888afe9568\ncase \"./src/rwl/value.osl\"\n  class __imports__b6b9b465fcf5c8c4f9d5fe786e8bce9c (\n    class RWLValue (\n      \n    )\n    \n    class RWLStrValue extends RWLValue (\n      type = \"str\"\n      def init(string value) (\n        self.value @= value\n      )\n    )\n    \n    class RWLNumValue extends RWLValue (\n      type = \"num\"\n      def init(number value) (\n        self.value @= value\n      )\n    )\n    \n    class RWLPercentageValue extends RWLValue (\n      type = \"percentage\"\n      def init(number value) (\n        self.value @= value\n      )\n    )\n    \n    class RWLColorValue extends RWLValue (\n      type = \"color\"\n      def init(string value) (\n        self.value @= value\n      )\n    )\n    \n    def AstToValue(ast) (\n      switch ast.type (\n        case \"str\"\n          return rwl.value.RWLStrValue(ast.value)\n        case \"num\"\n          return rwl.value.RWLNumValue(ast.value)\n        case \"percentage\"\n          return rwl.value.RWLPercentageValue(ast.value)\n        case \"color\"\n          return rwl.value.RWLColorValue(ast.value)\n        case \"property\"\n          switch ast.source (\n            case \"theme\"\n              local col = shared.theme[ast.name]\n              if typeof(col) == \"string\" (\n                return rwl.value.RWLColorValue(col)\n              )\n              break\n            default\n              return rwl.error.Error(\"UnknownPropertySource\", {\n                source: ast.source\n              })\n          )\n          return rwl.error.Error(\"UnknownProperty\", {\n            property: ast.name,\n            source: ast.source\n          })\n        default\n          return rwl.error.Error(\"UnknownValueType\", {\n            valueType: ast.type\n          })\n      )\n    )\n  )\n  return __imports__b6b9b465fcf5c8c4f9d5fe786e8bce9c\ncase \"./src/rwl/error.osl\"\n  class __imports__c17b91d805bd65a760423a0b948a2c09 (\n    object Errors = {\n      UnknownElementKind: def(data) -> (\n        return \"unknown element kind:\" + data.elementKind\n      ),\n      UnknownAttributeKind: def(data) -> (\n        return \"unknown attribute kind:\" + data.attributeKind\n      ),\n      \n      UnknownValueType: def(data) -> (\n        return \"unknown value type:\" + data.valueType\n      ),\n      UnknownBlockType: def(data) -> (\n        return \"unknown block type:\" + data.blockType\n      ),\n      \n      InvalidAnchorName: def(data) -> (\n        return \"unknown anchor name\" + data.name\n      ),\n      InvalidAlignmentName: def(data) -> (\n        return \"unknown anchor name\" + data.name\n      ),\n      \n      InvalidElemType: def(data) -> (\n        return \"cannot have\" + data.valueType + \"as element\"\n      ),\n      \n      ValueTypeMismatch: def(data) -> (\n        if typeof(data.wanted) == \"string\" (\n          data.wanted @= [data.wanted]\n        )\n        local forCtx = \"\"\n        if data.attr != null (\n          forCtx += \"for\" + data.attr\n        )\n        return \"wanted\" + data.wanted.join(\" or \") + \"got\" + data.got ++ forCtx\n      ),\n      \n      UnknownProperty: def(data) -> (\n        return \"unknown property\" + data.property + \"on\" + data.source\n      ),\n      UnknownPropertySource: def(data) -> (\n        return \"unknown source\" + data.source\n      ),\n      \n      ElemInFrame: def(data) -> (\n        return \"element in a frame, only sections are allowed directly in frames\"\n      ),\n      \n      NoScriptType: def(data) -> (\n        return \"no script type attribute\"\n      ),\n      InvalidScriptType: def(data) -> (\n        return \"unknown script type\" + data.type\n      ),\n      InvalidScriptAttrType: def(data) -> (\n        return \"unknown script type attribute type\" + data.type\n      ),\n      \n      NoIconSrc: def(data) -> (\n        return \"icon has no src\"\n      )\n    }\n    \n    class Error (\n      boolean isError = true\n      \n      def init(string type, object data) (\n        self.type = type\n        self.data @= data\n        \n        local err @= rwl.error.Errors[type]\n        if err == null (\n          self.type = \"UnknownErrorType\"\n          self.txt = \"unknown error type\" + type\n          return\n        )\n        self.txt = err(data)\n      )\n      \n      def stringify() (\n        return \"Error<\" ++ self.type ++ \">:\\n\" ++ self.txt.split(\"\\n\").map(l -> \"    \" ++ l).join(\"\\n\")\n      )\n    )\n  )\n  return __imports__c17b91d805bd65a760423a0b948a2c09\ncase \"./src/rwl/area.osl\"\n  class __imports__51b19cf190821eee598f3dc8fa9be944 (\n    def copy(area) (\n      return [area[1], area[2], area[3], area[4]]\n    )\n    \n    def centerX(area) (\n      return area[1] + area[3] / 2\n    )\n    \n    def centerY(area) (\n      return area[2] + area[4] / 2\n    )\n    \n    def width(area) (\n      return area[3] - area[1]\n    )\n    \n    def height(area) (\n      return area[4] - area[2]\n    )\n    \n    def pad(area, pad) (\n      return [\n        area[1] + pad[1],\n        area[2] + pad[2],\n        area[3] - pad[3],\n        area[4] - pad[4]\n      ]\n    )\n    \n    def margin(area, mar) (\n      return [\n        area[1] - mar[1],\n        area[2] - mar[2],\n        area[3] + mar[3],\n        area[4] + mar[4]\n      ]\n    )\n  )\n  return __imports__51b19cf190821eee598f3dc8fa9be944\ncase \"./src/rwl/config.osl\"\n  class __imports__997006161a7103fcb97a4e4d8f4a25b1 (\n    goob = \"hi\"\n  )\n  return __imports__997006161a7103fcb97a4e4d8f4a25b1\ncase \"./src/rwl/main.osl\"\n  class __imports__b471b13f60903428337025313115b852 (\n    debug = false\n    \n    class RWLNode (\n      // global attributes\n      def initGlobal() (\n        self.elemI = rwl.main.elemI\n        rwl.main.elemI ++\n        self.updateGlobal()\n      )\n      def updateGlobal(area, context) (\n        self.id = null\n        \n        local id @= self.expectOnHeader(\"id\", \"str\")\n        if id.isError (\n          return id\n        )\n        if id != null (\n          self.id = id.value\n        )\n        \n        self.cu_area @= area\n        self.cu_context @= context\n        void self.checkUpdate()\n      )\n      \n      def updateFromCache() (\n        if self.cu_area != null (\n          void self.update(self.cu_area, self.cu_context)\n        )\n      )\n      \n      def updateParentFromCache() (\n        if self.parent != null and self.parent.name != null (\n          void self.parent.updateFromCache()\n        ) else (\n          void self.updateFromCache()\n        )\n      )\n      \n      def checkUpdate() (\n        if self.needsUpdate (\n          self.needsUpdate = false\n          void self.updateFromCache()\n        )\n        \n        // used when this was a branch like system\n        //if self.children != null (\n        //  for i self.children.len (\n        //    void self.children[i].checkUpdate()\n        //  )\n        //)\n      )\n      \n      def update() (\n        \n      )\n      \n      def topUpdate() (\n        \n      )\n      \n      def interactUpdate() (\n        \n      )\n      \n      def render() (\n        \n      )\n      \n      def renderDevtools() (\n        \n      )\n      \n      def expectOnHeader(string key, string type) (\n        for attrI self.header.pairs.len (\n          local attr @= self.header.pairs[attrI]\n          if attr[2].isError (\n            return attr[2]\n          )\n          if attr[1] == key (\n            if attr[2].type != type (\n              return rwl.error.Error(\"ValueTypeMismatch\", {\n                wanted: type,\n                got: attr[2].type\n              })\n            ) else (\n              return attr[2]\n            )\n          )\n        )\n        return null\n      )\n      \n      def getAreaKeys(string name, pairs) (\n        local l = 0\n        local r = 0\n        local b = 0\n        local t = 0\n        \n        pairs ??= self.header.pairs\n        for pairI pairs.len (\n          local pair @= pairs[pairI]\n          local n = pair[1]\n          local value @= pair[2]\n          \n          if n == name (\n            l = value.value\n            r = value.value\n            b = value.value\n            t = value.value\n          ) else if n == name ++ \"_x\" (\n            l = value.value\n            r = value.value\n          ) else if n == name ++ \"_y\" (\n            b = value.value\n            t = value.value\n          ) else if n == name ++ \"_l\" or n == name ++ \"_left\" (\n            l = value.value\n          ) else if n == name ++ \"_r\" or n == name ++ \"_right\" (\n            r = value.value\n          ) else if n == name ++ \"_b\" or n == name ++ \"_bottom\" (\n            b = value.value\n          ) else if n == name ++ \"_t\" or n == name ++ \"_top\" (\n            t = value.value\n          )\n        )\n        \n        return [l, b, r, t]\n      )\n      \n      def getPadding(pairs) (\n        return self.getAreaKeys(\"padding\", pairs)\n      )\n      def getMargin(pairs) (\n        return self.getAreaKeys(\"margin\", pairs)\n      )\n    )\n    \n    class RWLContainer extends RWLNode (\n      kind = \"block\"\n      def init(array children, object header) (\n        self.children @= children\n        self.header @= header\n        void self.initGlobal()\n      )\n      \n      def update(array area, object context) (\n        void self.updateBackgroundColor()\n        void self.updateBackground(area)\n        void self.updateGlobal(area, context)\n        \n        local childArea @= rwl.area.pad(area, self.getPadding())\n        \n        self.area @= area\n        self.childArea @= childArea\n        \n        return rwl.main.UpdateElements(self.children, childArea, {\n          anchorX: \"c\",\n          anchorY: \"c\",\n          color: \"#fff\",\n          inst: context.inst\n        }, self)\n      )\n      \n      def interactUpdate(object context) (\n        for i self.children.len (\n          void self.children[i].interactUpdate(context)\n        )\n      )\n      \n      def updateBackgroundColor() (\n        local color @= self.expectOnHeader(\"color\", \"color\")\n        \n        if color != null (\n          self.color @= color.value\n        )\n      )\n      \n      def updateBackground(array area) (\n        self.area @= area\n        \n        local allRounding @= self.expectOnHeader(\"rounding\", \"num\")\n        \n        local rounding @= allRounding.value ?? 0\n        \n        local corners @= [\"bl\",\"br\",\"tl\",\"tr\"]\n        for i corners.len (\n          local corner @= self.expectOnHeader(\"rounding_\" ++ corners[i], \"num\")\n          if corner != null (\n            if typeof(rounding) != \"array\" (\n              rounding @= []\n              loop i - 1 (\n                void rounding.append(allRounding.value ?? 0)\n              )\n            )\n            void rounding.append(corner.value ?? 0)\n          ) else (\n            void rounding.append(allRounding.value ?? 0)\n          )\n        )\n        self.rounding @= rounding\n        \n        void self.updateBackgroundColor()\n      )\n      \n      def render() (\n        if self.header.flags.contains(\"Hidden\") (\n          void self.renderDevtools()\n          return\n        )\n        \n        void self.renderBackground()\n        if rwl.main.debug (\n          void rwl.debug.box(self.area, #f00)\n          void rwl.debug.box(self.childArea, #0f0)\n        )\n        void rwl.main.RenderElements(self.children)\n        void self.renderDevtools()\n      )\n      \n      def renderDevtools() (\n        if self.elemI == devtools.main.hoveredElement (\n          self.childArea ??= self.area\n          \n          // left\n          void shared.graphics.filledTransparentArea([\n            self.area[1],\n            self.area[2],\n            self.childArea[1],\n            self.area[4]\n          ], #f0f, 20)\n          // right\n          void shared.graphics.filledTransparentArea([\n            self.childArea[3],\n            self.area[2],\n            self.area[3],\n            self.area[4]\n          ], #f0f, 20)\n          // top\n          void shared.graphics.filledTransparentArea([\n            self.childArea[1],\n            self.childArea[4],\n            self.childArea[3],\n            self.area[4]\n          ], #f0f, 20)\n          // bottom\n          void shared.graphics.filledTransparentArea([\n            self.childArea[1],\n            self.area[2],\n            self.childArea[3],\n            self.childArea[2]\n          ], #f0f, 20)\n          \n          if self.fullArea != null (\n            // left\n            void shared.graphics.filledTransparentArea([\n              self.fullArea[1],\n              self.fullArea[2],\n              self.area[1],\n              self.fullArea[4]\n            ], #0f0, 20)\n            // right\n            void shared.graphics.filledTransparentArea([\n              self.area[3],\n              self.fullArea[2],\n              self.fullArea[3],\n              self.fullArea[4]\n            ], #0f0, 20)\n            // top\n            void shared.graphics.filledTransparentArea([\n              self.area[1],\n              self.area[4],\n              self.area[3],\n              self.fullArea[4]\n            ], #0f0, 20)\n            // bottom\n            void shared.graphics.filledTransparentArea([\n              self.area[1],\n              self.fullArea[2],\n              self.area[3],\n              self.area[2]\n            ], #0f0, 20)\n          )\n          \n          if self.name != \"RWLFrame\" (\n            void shared.graphics.filledTransparentArea(self.childArea, #0ff, 20)\n          )\n        )\n      )\n      \n      def renderBackground() (\n        if self.color != null (\n          void shared.graphics.filledBox(self.area, self.rounding, self.color)\n        )\n      )\n    )\n    \n    class RWLRoot extends RWLContainer (\n      blockName = \"root\"\n      \n      def init(array children, object header) (\n        self.children @= children\n        self.header @= header\n        void self.initGlobal()\n      )\n    )\n    \n    class RWLFrame extends RWLContainer (\n      blockName = \"frame\"\n      \n      def init(array children, object header) (\n        self.children @= children\n        self.header @= header\n        void self.initGlobal()\n      )\n      \n      def update(array area, object context) (\n        void self.updateBackgroundColor()\n        void self.updateBackground(area)\n        void self.updateGlobal(area, context)\n        \n        local dir = \"x\"\n        local flipped = false\n        for flagI self.header.flags.len (\n          switch self.header.flags[flagI] (\n            case \"Horizontal\"\n              dir = \"x\"\n              break\n            case \"Vertical\"\n              dir = \"y\"\n              break\n            case \"Flipped\"\n              flipped = !flipped\n              break\n          )\n        )\n        \n        local amount = 0\n        if dir == \"x\" (\n          local total = rwl.area.width(area)\n        ) else if dir == \"y\" (\n          local total = rwl.area.height(area)\n        )\n        \n        local frameContext @= {\n          inst: context.inst\n        }\n        \n        for i self.children.len (\n          local child @= self.children[i]\n          \n          // defaults to remaining\n          local size = total - amount\n          local pairs @= child.header.pairs\n          for pairI pairs.len (\n            local pair @= pairs[pairI]\n            local value @= pair[2]\n            if pair[1] == \"size\" or (pair[1] == \"width\" and dir == \"x\") or (pair[1] == \"height\" and dir == \"y\") (\n              switch value.type (\n                case \"num\"\n                  size = value.value\n                  break\n                case \"percentage\"\n                  size = value.value / 100 * (total - amount)\n                  break\n                default\n                  return rwl.error.Error(\"ValueTypeMismatch\", {\n                    wanted: [\"num\", \"percentage\"],\n                    got: value.type\n                  })\n              )\n              break\n            )\n          )\n          \n          if dir == \"x\" (\n            local childArea @= [\n              flipped ? (area[3] - amount - size) (area[1] + amount),\n              area[2],\n              flipped ? (area[3] - amount) (area[1] + amount + size),\n              area[4]\n            ]\n          ) else if dir == \"y\" (\n            local childArea @= [\n              area[1],\n              flipped ? (area[2] + amount) (area[4] - amount - size),\n              area[3],\n              flipped ? (area[2] + amount + size) (area[4] - amount)\n            ]\n          )\n          \n          child.fullArea @= childArea\n          \n          childArea @= rwl.area.pad(childArea, self.getMargin(pairs))\n          \n          if child.kind == \"block\" (\n            local out @= child.update(childArea, frameContext)\n            if out.isError (\n              return out\n            )\n          ) else if [\"icon\"].contains(child.kind) (\n            void child.update(childArea, frameContext)\n          ) else (\n            return rwl.error.Error(\"ElemInFrame\", {})\n          )\n          amount += size\n        )\n        if dir == \"x\" (\n          self.usedArea @= [\n            flipped ? (area[3] - amount) (area[1]),\n            area[2],\n            flipped ? (area[3]) (area[1] + amount),\n            area[4]\n          ]\n          self.unusedArea @= [\n            flipped ? (area[1]) (area[1] + amount),\n            area[2],\n            flipped ? (area[3] - amount) (area[3]),\n            area[4]\n          ]\n        ) else if dir == \"y\" (\n          self.usedArea @= [\n            area[1],\n            flipped ? (area[2]) (area[4] - amount),\n            area[3],\n            flipped ? (area[2] + amount) (area[4])\n          ]\n          self.unusedArea @= [\n            area[1],\n            flipped ? (area[2] + amount) (area[2]),\n            area[3],\n            flipped ? (area[4]) (area[4] - amount)\n          ]\n        )\n      )\n      \n      def render() (\n        if self.header.flags.contains(\"Hidden\") (\n          void self.renderFrameDevtools()\n          return\n        )\n        \n        void self.renderBackground()\n        void rwl.main.RenderElements(self.children)\n        void self.renderFrameDevtools()\n      )\n      \n      def renderFrameDevtools() (\n        if self.elemI == devtools.main.hoveredElement (\n          void shared.graphics.filledTransparentArea(self.usedArea, #0ff, 20)\n          void shared.graphics.filledTransparentArea(self.unusedArea, #00f, 20)\n        )\n      )\n    )\n    \n    class RWLSection extends RWLContainer (\n      blockName = \"section\"\n      \n      def init(array children, object header) (\n        self.children @= children\n        self.header @= header\n        void self.initGlobal()\n      )\n    )\n    \n    class RWLPositionedContainer extends RWLContainer (\n      def update(array containerArea, object context) (\n        void self.updateGlobal(containerArea, context)\n        \n        local height = self.expectOnHeader(\"height\", \"num\").value ?? 20\n        \n        local margin @= self.getMargin()\n        local padding @= self.getPadding()\n        \n        local anchor @= self.expectOnHeader(\"anchor\", \"str\")\n        if anchor.isError (\n          return anchor\n        )\n        anchor = anchor[\"value\"]\n        \n        if context.x == null or context.y == null (\n          anchor ??= \"c\"\n        )\n        \n        if anchor != null (\n          if [\"tl\",\"t\",\"tr\",\n              \"l\",\"c\",\"r\",\n              \"bl\",\"b\",\"br\",\n              \"top left\", \"top\", \"top right\",\n              \"left\", \"center\", \"right\",\n              \"bottom left\", \"bottom\", \"bottom right\"].contains(anchor).not() (\n            return rwl.error.Error(\"InvalidAnchorName\", {\n              name: anchor\n            })\n          )\n          \n          local anchorX = rwl.area.centerX(containerArea)\n          local anchorY = rwl.area.centerY(containerArea) + (height / 2)\n          local anchorXType = \"c\"\n          local anchorYType = \"c\"\n          \n          if anchor.endsWith(\"l\") or anchor.endsWith(\"left\") (\n            anchorXType = \"l\"\n          )\n          if anchor.endsWith(\"r\") or anchor.endsWith(\"right\") (\n            anchorXType = \"r\"\n          )\n          \n          if anchor.startsWith(\"t\") or anchor.endsWith(\"top\") (\n            anchorY = containerArea[4]\n            anchorYType = \"t\"\n          )\n          if anchor.startsWith(\"b\") or anchor.endsWith(\"bottom\") (\n            anchorY = containerArea[2] + height + margin[2] + margin[4]\n            anchorYType = \"b\"\n          )\n          \n          context.x = anchorX\n          context.y = anchorY\n          context.anchorX = anchorXType\n          context.anchorY = anchorYType\n        )\n        context.y -= height / (context.anchorY == \"b\" ? -2 2) + (context.anchorY == \"b\" ? -margin[2] margin[4])\n        \n        local area @= [\n          containerArea[1] + margin[1],\n          context.y - (height / 2),\n          containerArea[3] - margin[3],\n          context.y + (height / 2)\n        ]\n        self.fullArea @= [\n          containerArea[1],\n          context.y - (height / 2) - margin[2],\n          containerArea[3],\n          context.y + (height / 2) + margin[4]\n        ]\n        \n        context.y -= height / (context.anchorY == \"b\" ? -2 2) + (context.anchorY == \"c\" ? 0 context.anchorY == \"b\" ? -margin[4] margin[2])\n        \n        void self.updateBackground(area)\n        \n        local childArea @= rwl.area.pad(area, padding)\n        \n        self.childArea @= childArea\n        \n        return rwl.main.UpdateElements(self.children, childArea, {\n          anchorX: \"c\",\n          anchorY: \"c\",\n          color: \"#fff\",\n          inst: context.inst\n        }, self)\n      )\n      \n      def render() (\n        if self.header.flags.contains(\"Hidden\") (\n          void self.renderDevtools()\n          return\n        )\n        \n        void self.renderBackground()\n        if rwl.main.debug (\n          void rwl.debug.box(self.area, #f00)\n          void rwl.debug.box(self.childArea, #0f0)\n          void rwl.debug.box(self.outArea, #00f)\n        )\n        void rwl.main.RenderElements(self.children)\n        void self.renderDevtools()\n      )\n    )\n    \n    class RWLButton extends RWLPositionedContainer (\n      blockName = \"button\"\n      \n      def init(array children, object header) (\n        self.children @= children\n        self.header @= header\n        void self.initGlobal()\n      )\n      \n      def isHovered() (\n        return mouse_x > self.area[1] and mouse_y > self.area[2] and mouse_x < self.area[3] and mouse_y < self.area[4]\n      )\n      \n      def updateBackgroundColor() (\n        local color @= self.expectOnHeader(\"color\", \"color\")\n        if color.isError (\n          return color\n        )\n        if color != null (\n          self.color @= color.value\n        )\n        \n        local hover_color @= self.expectOnHeader(\"hover_color\", \"color\")\n        if hover_color.isError (\n          return hover_color\n        )\n        if hover_color != null (\n          self.hover_color @= hover_color.value\n        )\n      )\n      \n      def renderBackground() (\n        local hov = self.isHovered()\n        \n        local col = self.color\n        if self.hover_color != null and hov (\n          col = self.hover_color\n        )\n        if col != null (\n          void shared.graphics.filledBox(self.area, self.rounding, col)\n        )\n        \n        //void shared.graphics.box(self.area, #fff)\n      )\n      \n      def interactUpdate(object context) (\n        if self.isHovered() (\n          // rework to use actual ordering system / order elemI on elem creation\n          //log context.topI self.elemI\n          if context.topI < self.elemI (\n            context.top @= self\n            context.topI = self.elemI\n          )\n        )\n      )\n      \n      def topUpdate(object context) (\n        //log \"hi\" context shared.input.rwlLeftClick\n        if shared.input.rwlLeftClick (\n          void context.rtr.runEvents({\n            name: \"click\",\n            element: self\n          }, {})\n        )\n      )\n    )\n    \n    class RWLScript extends RWLNode (\n      blockName = \"script\"\n      kind = \"script\"\n      \n      def init(body, object header, object inst) (\n        self.body @= body\n        self.header @= header\n        \n        void self.parse()\n        void self.makeModule(inst)\n      )\n      \n      def parse() (\n        self.ast @= null\n        // TODO: try\n        local parser @= rtr.ast.Parser(body)\n        self.ast @= parser.parse()\n      )\n      \n      def makeModule(object inst) (\n        if self.ast != null (\n          self.mod @= rtr.main.Module(self.ast)\n          void inst.rtrInst.addModule(self.mod)\n        )\n      )\n      \n      def update(array area, object context) (\n        if self.mod != null (\n          void self.mod.runEvent({\n            name: \"onupdate\"\n          }, {})\n        )\n      )\n      \n      def start() (\n        void self.mod.runEvent({\n          name: \"onload\",\n        }, {})\n      )\n    )\n    \n    class RWLElement extends RWLNode (\n      kind = \"element\"\n      def init(object value, object header) (\n        self.value @= value\n        self.header @= header\n        void self.initGlobal()\n      )\n      \n      def update(array area, object context) (\n        void self.updateGlobal(area, context)\n        local text = null\n        \n        switch self.value.type (\n          case \"str\"; case \"num\"\n            text = self.value.value.toStr()\n            break\n        )\n        \n        if text == null (\n          return rwl.error.Error(\"InvalidElemType\", {\n            valueType: self.value.type\n          })\n        )\n        \n        // font\n        //<font>\n        local size @= self.expectOnHeader(\"size\", \"num\")\n        if size.isError (\n          return size\n        )\n        size = size[\"value\"] ?? 10\n        \n        local spacing @= self.expectOnHeader(\"spacing\", \"num\")\n        if spacing.isError (\n          return spacing\n        )\n        spacing = spacing[\"value\"] ?? 1\n        \n        local line_height @= self.expectOnHeader(\"line_height\", \"num\")\n        if line_height.isError (\n          return line_height\n        )\n        line_height = spacing[\"line_height\"] ?? 1\n        \n        // positioning\n        local margin @= self.getMargin()\n        \n        local anchor @= self.expectOnHeader(\"anchor\", \"str\")\n        if anchor.isError (\n          return anchor\n        )\n        anchor = anchor[\"value\"]\n        \n        if context.x == null or context.y == null (\n          anchor ??= \"c\"\n        )\n        \n        if anchor != null (\n          if [\"tl\",\"t\",\"tr\",\n              \"l\",\"c\",\"r\",\n              \"bl\",\"b\",\"br\",\n              \"top left\", \"top\", \"top right\",\n              \"left\", \"center\", \"right\",\n              \"bottom left\", \"bottom\", \"bottom right\"].contains(anchor).not() (\n            return rwl.error.Error(\"InvalidAnchorName\", {\n              name: anchor\n            })\n          )\n          \n          local anchorX = rwl.area.centerX(area)\n          local anchorY = rwl.area.centerY(area) + (line_height * 1 * size)\n          local anchorXType = \"c\"\n          local anchorYType = \"c\"\n          \n          if anchor.endsWith(\"l\") or anchor.endsWith(\"left\") (\n            anchorX = area[1] + margin[1]\n            anchorXType = \"l\"\n          )\n          if anchor.endsWith(\"r\") or anchor.endsWith(\"right\") (\n            anchorX = area[3] - margin[3]\n            anchorXType = \"r\"\n          )\n          \n          if anchor.startsWith(\"t\") or anchor.endsWith(\"top\") (\n            anchorY = area[4]\n            anchorYType = \"t\"\n          )\n          if anchor.startsWith(\"b\") or anchor.endsWith(\"bottom\") (\n            anchorY = area[2]\n            anchorYType = \"b\"\n          )\n          \n          context.x = anchorX\n          context.y = anchorY\n          context.anchorX = anchorXType\n          context.anchorY = anchorYType\n        )\n        \n        local boxAlignment = context.anchorX\n        \n        local alignment @= self.expectOnHeader(\"alignment\", \"str\")\n        if alignment.isError (\n          return alignment\n        )\n        alignment = alignment[\"value\"]\n        if alignment != null (\n          if [\"l\",\"c\",\"r\",\n              \"left\", \"center\", \"right\"].contains(alignment).not() (\n            return rwl.error.Error(\"InvalidAlignmentName\", {\n              name: anchor\n            })\n          )\n          \n          if alignment.endsWith(\"l\") or alignment.endsWith(\"left\") (\n            alignment = \"l\"\n          )\n          if alignment.endsWith(\"r\") or alignment.endsWith(\"right\") (\n            alignment = \"r\"\n          )\n        )\n        alignment ??= boxAlignment\n        \n        // appearance\n        //<link>\n        //<decoration>\n        local color @= self.expectOnHeader(\"color\", \"color\")\n        if color.isError (\n          return color\n        )\n        color = color.value\n        if color != null (\n          context.color = color\n        )\n        color ??= context.color\n        \n        local lines @= text.split(\"\\n\")\n        local width = 0\n        for lineI lines.len (\n          width = max(width, lines[lineI].len * size * spacing)\n        )\n        local height = lines.len * line_height * 2 * size\n        \n        local x = context.x\n        if boxAlignment == \"l\" (\n          x += width / 2\n        )\n        if boxAlignment == \"r\" (\n          x += width / -2\n        )\n        \n        context.y -= height / (context.anchorY == \"b\" ? -2 2) + (context.anchorY == \"b\" ? -margin[2] margin[4])\n        \n        self.lines @= []\n        local y = context.y + (height / 2)\n        for lineI lines.len (\n          y -= size * line_height\n          local lineW = shared.graphics.getTextWidth(lines[lineI]) * size\n          local lx = x\n          if alignment == \"l\" (\n            lx += width / -2\n          )\n          if alignment == \"r\" (\n            lx += width / 2 - lineW\n          )\n          if alignment == \"c\" (\n            // account for char spacing\n            lx += lineW * -.5\n          )\n          log self.lines\n          void self.lines.append([lines[lineI], lx, y, size, color])\n          y -= size * line_height\n        )\n        \n        self.debugArea @= [\n          x - (width / 2),\n          context.y - (height / 2),\n          x + (width / 2),\n          context.y + (height / 2)\n        ]\n        self.margin @= margin\n        \n        context.y -= height / (context.anchorY == \"b\" ? -2 2) + (context.anchorY == \"b\" ? -margin[4] margin[2])\n      )\n      \n      def render() (\n        if self.header.flags.contains(\"Hidden\") (\n          void self.renderDevtools()\n          return\n        )\n        \n        for lineI self.lines.len (\n          local line @= self.lines[lineI]\n          void shared.graphics.ptext(line[1], line[2], line[3], line[4], line[5])\n        )\n        \n        void rwl.debug.box(self.debugArea ?? [])\n        void self.renderDevtools()\n      )\n      \n      def renderDevtools() (\n        if self.elemI == devtools.main.hoveredElement (\n          void shared.graphics.filledTransparentArea(self.debugArea, #0ff, 20)\n          \n          local fullArea = rwl.area.margin(self.debugArea, self.margin)\n         \n          if fullArea != null (\n            // left\n            void shared.graphics.filledTransparentArea([\n              fullArea[1],\n              fullArea[2],\n              self.debugArea[1],\n              fullArea[4]\n            ], #f0f, 20)\n            // right\n            void shared.graphics.filledTransparentArea([\n              self.debugArea[3],\n              fullArea[2],\n              fullArea[3],\n              fullArea[4]\n            ], #f0f, 20)\n            // top\n            void shared.graphics.filledTransparentArea([\n              self.debugArea[1],\n              self.debugArea[4],\n              self.debugArea[3],\n              fullArea[4]\n            ], #f0f, 20)\n            // bottom\n            void shared.graphics.filledTransparentArea([\n              self.debugArea[1],\n              fullArea[2],\n              self.debugArea[3],\n              self.debugArea[2]\n            ], #f0f, 20)\n          )\n        )\n      )\n    )\n    \n    class RWLIcon extends RWLNode (\n      kind = \"icon\"\n      \n      def update(array area, object context) (\n        local scale @= self.expectOnHeader(\"scale\", \"num\")\n        if scale.isError (\n          return scale\n        )\n        self.scale = size.value ?? 1\n        \n        local src @= self.expectOnHeader(\"src\", \"str\")\n        if src.isError (\n          return src\n        )\n        if src == null (\n          return rwl.error.Error(\"NoIconSrc\", {})\n        )\n        self.src = src.value\n        \n        local color @= self.expectOnHeader(\"color\", \"color\")\n        if color.isError (\n          return color\n        )\n        self.color = color.value\n        \n        // TODO: anchors?\n        self.x = rwl.area.centerX(area)\n        self.y = rwl.area.centerY(area)\n      )\n      \n      def render() (\n        if self.header.flags.contains(\"Hidden\") (\n          void self.renderDevtools()\n          return\n        )\n        \n        void shared.graphics.picon(self.src, self.x, self.y, self.scale, self.color ?? \"#fff\")\n        void self.renderDevtools()\n      )\n      \n      def init(object header) (\n        self.header @= header\n      )\n    )\n    \n    def UpdateElements(array elements, array area, object context, object parentElem) (\n      for i elements.len (\n        elements[i].parent @= parentElem\n        local out @= elements[i].update(area, context)\n        if out.isError (\n          return out\n        )\n      )\n    )\n    \n    def RenderElements(array elements) (\n      for i elements.len (\n        //void\n        void elements[i].render()\n        void\n      )\n    )\n    \n    elemI = 0\n    def AstToElement(ast, object inst) (\n      def AstToHeader(header) (\n        local flags @= []\n        local pairs @= []\n        for attrI header.attributes.len (\n          local attr @= header.attributes[attrI]\n          switch attr.kind (\n            case \"flag\"\n              flags.append(attr.data)\n              break\n            case \"key\"\n              void pairs.append([attr.key, rwl.value.AstToValue(attr.value)])\n              break\n          )\n        )\n        return { flags, pairs }\n      )\n      //log \"a\" ast\n      local header @= AstToHeader(ast.data.header)\n      \n      switch ast.kind (\n        case \"block\"\n          if ast.data.header.key != \"script\" (\n            local children @= AstsToElements(ast.data.content.elements, inst)\n          )\n          if typeof(children) != \"array\" and children[\"isError\"] (\n            return children\n          )\n          switch ast.data.header.key (\n            // top level\n            case \"root\"\n              return rwl.main.RWLRoot(children, header)\n            \n            // normal\n            case \"frame\"\n              return rwl.main.RWLFrame(children, header)\n            case \"section\"\n              return rwl.main.RWLSection(children, header)\n            \n            case \"script\"\n              return rwl.main.RWLScript(shared.utils.removeIndents(ast.data.content), header, inst)\n            \n            case \"button\"\n              return rwl.main.RWLButton(children, header)\n            \n            default\n              return rwl.error.Error(\"UnknownBlockType\", {\n                blockType: ast.data.header.key\n              })\n              break\n          )\n          break\n        \n        case \"element\"\n          return rwl.main.RWLElement(rwl.value.AstToValue(ast.data.value), header)\n        \n        case \"icon\"\n          return rwl.main.RWLIcon(header)\n        \n        default\n          return rwl.error.Error(\"UnknownElementKind\", {\n            elementKind: ast.kind\n          })\n          break\n      )\n    )\n    \n    def AstsToElements(elements, object inst) (\n      local elems @= []\n      for i elements.len (\n        local out @= AstToElement(elements[i], inst)\n        if out.isError (\n          return out\n        )\n        void elems.append(out)\n      )\n      return elems\n    )\n    \n    class RWL (\n      def init(object ast, object rtrInst) (\n        self.rtrInst @= rtrInst\n        self.errored = false\n        self.needsUpdate = true\n        self.hasUpdated = false\n        \n        self._lastW = 0\n        self._lastH = 0\n        self._lastX = 0\n        self._lastY = 0\n        \n        void self.loadFromAst(ast)\n      )\n      \n      def loadFromAst(object ast) (\n        self.ast @= ast\n        self.elements @= rwl.main.AstsToElements(ast.elements, self)\n        \n        if typeof(self.elements) != \"array\" and self.elements.isError (\n          error self.elements.stringify()\n          self.errored = true\n          return\n        )\n      )\n      \n      def update(array area) (\n        self.hasUpdated = true\n        if self.errored (\n          return\n        )\n        \n        local out @= rwl.main.UpdateElements(self.elements, area, {\n          inst: self,\n          root: true\n        }, {})\n        if out.isError (\n          error out.stringify()\n          self.errored = true\n          self.errormsg = out.stringify()\n        )\n      )\n      \n      def checkUpdate(array area) (\n        local w = rwl.area.width(area)\n        local h = rwl.area.height(area)\n        local x = rwl.area.centerX(area)\n        local y = rwl.area.centerY(area)\n        \n        // if the width or height or x or y has changed, update\n        if w != self._lastW or h != self._lastH or x != self._lastX or y != self._lastY (\n          self.needsUpdate = true\n          \n          self._lastW = w\n          self._lastH = h\n          self._lastX = x\n          self._lastY = y\n        )\n        \n        if self.needsUpdate (\n          void self.update(area)\n          self.needsUpdate = false\n        )\n      )\n      \n      def interactUpdate(object context) (\n        if self.errored (\n          return\n        )\n      \n        context.top = null\n        context.topI = 0\n        for i self.elements.len (\n          void self.elements[i].interactUpdate(context)\n        )\n        \n        //log context.top\n        \n        if context.top != null (\n          void context.top.topUpdate(context)\n        )\n      )\n      \n      def checkElemUpdate() (\n        if self.errored (\n          return\n        )\n      \n        for i self.elements.len (\n          void self.elements[i].checkUpdate()\n        )\n      )\n      \n      def render(array area) (\n        void self.checkUpdate(area)\n      \n        self.worker.area @= area\n        if self.errored (\n          goto rwl.area.centerX(area) rwl.area.centerY(area)\n          centext \"rwl errored :(\" 12 : c#shared.theme.seco\n          if self.errormsg != null (\n            centext self.errormsg 8 : c#shared.theme.prim chy#-20\n          )\n          return\n        )\n        \n        void rwl.main.RenderElements(self.elements)\n      )\n      \n      def getElement(string id) (\n        local queue @= [...self.elements]\n        while queue.len > 0 (\n          local elem @= queue.shift()\n          \n          if elem.id == id (\n            return elem\n          )\n          \n          if elem.children != null (\n            for i elem.children.len (\n              void queue.append(elem.children[i])\n            )\n          )\n        )\n      )\n    )\n  )\n  return __imports__b471b13f60903428337025313115b852\ncase \"./sidebartest.rwl\"\n  return \"  root {\\n    frame [Horizontal, id=\\\"bleh\\\"] {\\n      section [\\n        id=\\\"sidebar\\\",\\n        size=150, color=theme:prim,\\n        rounding_tr=17.5, rounding_br=17.5,\\n        padding=10\\n      ] {},\\n      section {\\n      }\\n    },\\n    \\n    script {\\n      event(onload) {\\n        i := 0;\\n        createSidebarButton := (name) ~ {\\n          i = i + 1;\\n          elem := document.createContainer(\\\"button\\\");\\n          elem.height = 35;\\n          elem.padding = 10;\\n          elem.color = theme.seco;\\n          elem.hover_color = theme.tert;\\n          elem.rounding = 10;\\n          elem.id = \\\"btn\\\" + i;\\n          if (i == 1) {\\n            elem.anchor = \\\"t\\\";\\n          }\\n          elem.margin_b = 10;\\n          document.getElement(\\\"sidebar\\\").addChild(elem);\\n          \\n          script := document.createScript(\\\"event(#\\\" + elem.id + \\\":click) {\\\\n  log(\\\\\\\"\\\" + name + \\\" clicked!\\\\\\\");\\\\n}\\\\n\\\");\\n          document.root.addChild(script);\\n          \\n          text := document.createTextElement(name);\\n          text.color = theme.text;\\n          elem.addChild(text);\\n        };\\n        \\n        btns := [\\n          \\\"hi\\\",\\n          \\\"wow\\\",\\n          \\\"blehh\\\",\\n          \\\"fr\\\"\\n        ];\\n        \\n        for (btn, btns) {\\n          log(btn);\\n          createSidebarButton(btn);\\n        }\\n      }\\n    }\\n  }\"\n\ncase \"./test.rwl\"\n  return \"  root [color=theme:prim] {\\n    frame [Horizontal] {\\n      section [size=100, rounding_tr=20, rounding_br=20] {\\n        \\\"fr\\\" [color=theme:seco]\\n      },\\n      section {\\n        frame [Vertical] {\\n          section [size=50] {\\n            \\\"maybe?\\\" [color=theme:text, anchor=\\\"l\\\", margin=10, size=15]\\n          },\\n          section [color=theme:back, rounding=20, margin_r=10, margin_b=10, padding=20] {\\n            \\\"blehhh\\\" [color=theme:text],\\n            \\\"fr\\\",\\n            button [color=theme:prim,padding=5,rounding=5] {\\n              \\\"hi\\\"\\n            },\\n            \\\":P\\\" [anchor=\\\"bl\\\",size=5]\\n          }\\n        }\\n      }\\n    },\\n    script {\\n      event(onload) {\\n        log(\\\"blehh\\\");\\n        \\n        document.title = \\\"gay\\\";\\n        document.icon = \\\"flag-progress\\\";\\n      }\\n    }\\n  }\"\n\ncase \"./main.rwl\"\n  return \"  root {\\n    frame [Vertical] {\\n      section [size=50%, color=#fff] {\\n      \\n      }\\n    },\\n    \\\"hi\\\\nwow\\\"\\n  }\"\n)\n)\nimport as \"glass\" from \"packages\"\n\n// fpp boilerplate\n\n\n\nobject rwl @= {\n  main: import(\"./src/rwl/main.osl\"),\n  config: import(\"./src/rwl/config.osl\"),\n  area: import(\"./src/rwl/area.osl\"),\n  error: import(\"./src/rwl/error.osl\"),\n  value: import(\"./src/rwl/value.osl\"),\n  debug: import(\"./src/rwl/debug.osl\"),\n  ast: import(\"./src/rwl/ast.osl\")\n}\n\nobject rtr @= {\n  main: import(\"./src/rtr/main.osl\"),\n  ast: import(\"./src/rtr/ast.osl\"),\n  error: import(\"./src/rtr/error.osl\"),\n  value: import(\"./src/rtr/value.osl\"),\n  compiler: import(\"./src/rtr/compiler.osl\"),\n  instruction: import(\"./src/rtr/instruction.osl\"),\n  apis: {}\n}\n\n// make them load after\nrtr.apis @= {\n  main: import(\"./src/rtr/apis/main.osl\"),\n  rwl: import(\"./src/rtr/apis/rwl.osl\"),\n  browser: import(\"./src/rtr/apis/browser.osl\")\n}\n\nobject shared @= {\n  graphics: import(\"./src/shared/graphics.osl\"),\n  utils: import(\"./src/shared/utils.osl\"),\n  document: import(\"./src/shared/document.osl\"),\n  tab: import(\"./src/shared/tab.osl\"),\n  url: import(\"./src/shared/url.osl\"),\n  theme: import(\"./src/shared/theme.osl\"),\n  config: import(\"./src/shared/config.osl\"),\n  tab_worker: import(\"./src/shared/tab_worker.osl\"),\n  input: import(\"./src/shared/input.osl\"),\n  settings: import(\"./src/shared/settings.osl\"),\n  save: import(\"./src/shared/save.osl\")\n}\n\nobject layouts @= {\n  shared: {\n    state: import(\"./src/layouts/shared/state.osl\"),\n    utils: import(\"./src/layouts/shared/utils.osl\"),\n    topbar: import(\"./src/layouts/shared/topbar.osl\"),\n    urlbar: import(\"./src/layouts/shared/urlbar.osl\"),\n    view: import(\"./src/layouts/shared/view.osl\")\n  },\n  chromeLike: {\n    main: import(\"./src/layouts/chromeLike/main.osl\"),\n    topbar: import(\"./src/layouts/chromeLike/topbar.osl\")\n  },\n  summit: {\n    main: import(\"./src/layouts/summit/main.osl\"),\n    sidebar: import(\"./src/layouts/summit/sidebar.osl\"),\n    topbar: import(\"./src/layouts/summit/topbar.osl\")\n  }\n}\n\nobject net @= {\n  fetch: import(\"./src/net/fetch.osl\"),\n  response: import(\"./src/net/response.osl\")\n}\n\nif build.package.phosphorus.hasDevtools ?? true (\n  object devtools @= {\n    main: import(\"./src/devtools/main.osl\"),\n    topbar: import(\"./src/devtools/topbar.osl\"),\n    rightclick: import(\"./src/devtools/rightclick.osl\"),\n    \n    menus: {\n      elements: import(\"./src/devtools/menus/elements.osl\"),\n      console: import(\"./src/devtools/menus/console.osl\"),\n      network: import(\"./src/devtools/menus/network.osl\"),\n      storage: import(\"./src/devtools/menus/storage.osl\"),\n      compiled: import(\"./src/devtools/menus/compiled.osl\")\n    }\n  }\n)\n\nobject browserPages @= {\n  empty: import(\"./src/assets/empty.rwl\"),\n  home: import(\"./src/assets/home.rwl\"),\n  settings: () -> import(\"./src/assets/settings.rwl\")\n}\n\nvoid shared.settings.load()\nvoid shared.config.net.refresh()\n\nvoid layouts.chromeLike.main.init()\n\nif !build.built (\n  // debug tabs\n  local document @= shared.document.Document()\n  void document.loadUrl(shared.url.Url(\"phos://settings\"))\n  //void document.loadUrl(shared.url.Url(\"local://./main.rwl\"))\n  void layouts.shared.state.openTabDocument(document)\n  \n  local document2 @= shared.document.Document()\n  void document2.loadUrl(shared.url.Url(\"local://./test.rwl\"))\n  void layouts.shared.state.openTabDocument(document2)\n  \n  local document3 @= shared.document.Document()\n  void document3.loadUrl(shared.url.Url(\"local://./sidebartest.rwl\"))\n  void layouts.shared.state.openTabDocument(document3)\n) else (\n  local document3 @= shared.document.Document()\n  void document3.loadUrl(shared.url.Url(shared.config.url.browser_scheme ++ \"://home\"))\n  void layouts.shared.state.openTabDocument(document3)\n)\n\nvoid layouts.shared.state.selectTab(1)\n\nvoid window.resize(900,500)\n\ncurrentLayout = build.package.phosphorus.layout ?? \"chromeLike\"\n\nif !build.built (\n  currentLayout = \"summit\"\n)\n\nmainloop:\n  void layouts[currentLayout].main.update()\n  //void layouts.chromeLike.main.update()\n  //void layouts.summit.main.update()\n  \n  // file dropping\n  if file_dropped != 0 (\n    local data @= open(file_dropped,[3,2,1])\n    local path = data[1] ++ \"/\" ++ data[2] ++ data[3]\n    local document @= shared.document.Document()\n    void document.loadUrl(shared.url.Url(\"local://\" ++ path))\n    void layouts.shared.state.openTabDocument(document)\n    file_dropped = 0\n  )",""],[".osl","script-chromelike","build @= { built: true, package: {\"name\":\"summit\",\"version\":\"1.0.0a\",\"description\":\"rotur web engine\",\"main\":\"script.osl\",\"dependencies\":{},\"tags\":[],\"include\":[\"./main.rwl\",\"./test.rwl\",\"./sidebartest.rwl\"],\"phosphorus\":{\"layout\":\"chromeLike\",\"hasDevtools\":true},\"scripts\":{\"opaljson-summit\":\"osl ./scripts/opal_summit.osl\",\"opaljson-chromeLike\":\"osl ./scripts/opal_chromeLike.osl\",\"opaljson-reset\":\"osl ./scripts/opal_reset.osl\",\"build-summit\":[\"fpp script opaljson-summit\",\"fpp build\",\"rm build/script-summit.osl\",\"mv build/script.osl build/script-summit.osl\",\"echo \\\"summit build complete!\\\"\"],\"build-chromeLike\":[\"fpp script opaljson-chromeLike\",\"fpp build\",\"rm build/script-chromeLike.osl\",\"mv build/script.osl build/script-chromeLike.osl\",\"echo \\\"chromeLike build complete!\\\"\"],\"build\":[\"fpp script build-summit\",\"fpp script build-chromeLike\",\"fpp script opaljson-reset\"]}} }\nopal_imports = {}\ndef import(path) (\n  switch path (\n\ncase \"./src/assets/settings.rwl\"\n  return \"  root {\\n    frame [Horizontal, color=theme:prim] {\\n      section [id=\\\"sidebar\\\", size=150] {\\n        \\n      },\\n      section {\\n        frame [Vertical] {\\n          section [size=40, padding=10] {\\n            \\\"loading...\\\" [\\n              id=\\\"location\\\",\\n              color=theme:text,\\n              size=12, anchor=\\\"l\\\"\\n            ]\\n          },\\n          section [color=theme:back, rounding_tl=10] {\\n            \\n          }\\n        }\\n      }\\n    },\\n    \\n    script {\\n      event(onload) {\\n        setLocation := (text) ~ {\\n          document.getElement(\\\"location\\\").text = text;\\n        };\\n        setLocation(\\\"bleh\\\");\\n        \\n        sidebar := document.getElement(\\\"sidebar\\\");\\n        \\n        categories := $$brwsr.settings.getCategories();\\n        i := 0;\\n        for (category, categories) {\\n          i += 1;\\n          buttonElem := document.createContainer(\\\"button\\\");\\n          \\n          buttonElem.margin = 7.5;\\n          if (i == 1) {\\n            buttonElem.anchor = \\\"tl\\\";\\n            buttonElem.margin_t = 10;\\n          } else {\\n            buttonElem.margin_t = 0;\\n          }\\n          buttonElem.height = 35;\\n          buttonElem.rounding = 10;\\n          buttonElem.hover_color = theme.seco;\\n          buttonElem.id = \\\"cat_\\\" + category;\\n          \\n          titleElem := document.createTextElement(toTitle(category));\\n          titleElem.color = theme.text;\\n          titleElem.size = 11;\\n          \\n          buttonElem.addChild(titleElem);\\n          script := document.createScript(join(\\n            \\\"setLocation := (text) ~ {document.getElement(\\\\\\\"location\\\\\\\").text = text;};\\\\n\\\",\\n            \\\"event(#\\\" + buttonElem.id + \\\":click) {\\\\n\\\",\\n            \\\"  setLocation(\\\\\\\"\\\" + buttonElem.id + \\\"\\\\\\\");\\\\n\\\",\\n            \\\"}\\\\n\\\"\\n          ));\\n          buttonElem.addChild(script);\\n          \\n          sidebar.addChild(buttonElem);\\n        }\\n      }\\n    }\\n  }\"\n\ncase \"./src/devtools/menus/compiled.osl\"\n  class __imports__c2496c7321897b9bfcdc4b07bd6e8f28 (\n    number offsetX = 0\n    boolean exit = false\n    selectedCode = null\n    \n    object highlighting = {\n      program_flow: {\n        color: #ff4b19,\n        names: [\n          \"label\",\n          \n          \"jump\",\n          \"jumpIf\",\n          \"jumpNotIf\"\n        ]\n      },\n      operations: {\n        color: #ff8119,\n        names: [\n          \"call\",\n          \"unary\",\n          \"binary\",\n          \"prop\",\n          \"len\",\n          \n          \"asivar\",\n          \"asiprop\"\n        ]\n      },\n      values: {\n        color: #52e342,\n        names: [\n          \"null\",\n          \"str\",\n          \"bool\",\n          \"num\",\n          \"func\",\n          \"arr\",\n          \"obj\",\n          \"color\"\n        ]\n      },\n      scope: {\n        color: #00edb6,\n        names: [\n          \"get\",\n          \"decl\",\n          \n          \"newScope\",\n          \"popScope\"\n        ]\n      },\n      stack: {\n        color: #cd27e3,\n        names: [\n          \"pop\",\n          \"dupe\"\n        ]\n      }\n    }\n    \n    object colors = {\n      label: #34eb9b,\n      str: #eba434,\n      num: #34eb3a,\n      bool: #537aed,\n      col: #73a7f0,\n      var: #cf8846\n    }\n    \n    def getInst() (\n      return layouts.shared.state.currentDocument.rtrInst\n    )\n    \n    def topbar() (\n      if self.selectedCode == null (\n        self.topbarHeight = -1\n      ) else (\n        self.topbarHeight = null\n        \n        goto frame.left + 10 0\n        square 15 15 0 0 1\n        if mouse_touching (\n          cursor \"pointer\"\n          if onclick (\n            self.exit = true\n            self.topbarHeight = -1\n          )\n        )\n        icon \"left\" .5 : c#shared.theme.text\n        \n        change_x 15\n        \n        c shared.theme.prim\n        pen \"size\" 2\n        change_y 11\n        pen \"down\"\n        change_y -22\n        pen \"up\"\n        change_y 11\n        \n        change_x 7.5\n        drawLoc(self.selectedCode)\n      )\n    )\n    \n    def update() (\n      if !shared.config.browser.phosphorus.useCompiler (\n        goto 0 0\n        centext \"compiler disabled\" 10 : c#shared.theme.prim\n        return\n      )\n      \n      local inst @= self.getInst()\n      \n      if self.selectedCode == null (\n        // selector screen\n        local y = frame.top\n        \n        if inst.compiled != null (\n          for i inst.compiled.len (\n            local comp @= inst.compiled[i]\n            \n            y -= 15\n            goto frame.left + 7.5 y\n            \n            drawLoc(comp)\n            \n            goto frame.right + 16 y\n            square 10 10 12 : chx#-30 c#shared.theme.prim hover_c#shared.theme.seco\n            if mouse_touching (\n              cursor \"pointer\"\n              if onclick (\n                self.selectedCode @= comp\n              )\n            )\n            icon \"open\" .6 : c#shared.theme.text\n            \n            y -= 15\n            goto 0 y\n            pen \"size\" 2\n            line frame.left 0 frame.right 0 : c#shared.theme.prim\n          )\n        ) else (\n          goto 0 0\n          centext \"nothing compiled\" 10 : c#shared.theme.prim\n        )\n      ) else (\n        self.y = frame.top + frame.scroll\n        local start = self.y\n        self.offsetX = 0\n        drawInstructions(self.selectedCode.body, frame.left + 15)\n        self.height = start - self.y - 10\n      )\n      if self.exit (\n        self.exit = false\n        self.selectedCode = null\n      )\n    )\n    \n    def drawLoc(object comp) (\n      local txt = comp.start.loc ?? \"unknown\"\n      txt += comp.start.ln\n      txt ++= \":\"\n      txt ++= comp.start.char\n      txt += \"-\"\n      txt += comp.end.ln\n      txt ++= \":\"\n      txt ++= comp.end.char\n      text txt 10 : c#shared.theme.text\n    )\n    \n    def drawInstructions(array instructions, number x) (\n      for i instructions.len (\n        if instructions[i] != null (\n          drawInstruction(instructions[i], x, instructions, i)\n        )\n      )\n    )\n    \n    def drawInstruction(object instruction, number x, array instructions, number i) (\n      local height = 25\n      instruction.editorX = x\n      \n      self.y -= height / 2\n      instruction.editorY = self.y\n      \n      if instruction.kind == \"popScope\" (\n        self.offsetX -= 10\n      )\n      \n      if !(self.y - height > frame.top or self.y < frame.bottom) (\n        local fromleft = x + self.offsetX - frame.left\n        goto fromleft / 2 self.y\n        square frame.width - fromleft height 0 0 1\n        if mouse_touching (\n          change_x -2.5\n          square frame.width - fromleft - 15 height - 15 10 : c#shared.theme.prim\n        \n          local corresponding = self.getCorresponding(instructions, i)\n          if corresponding != null (\n            // \"arrow\" | \"point\"\n            local look = \"arrow\"\n            c shared.theme.tert\n            goto x + self.offsetX self.y\n            if look == \"point\" (\n              pen \"size\" 7.5\n              pen \"down\"\n              pen \"up\"\n            )\n            pen \"size\" 2.5\n            pen \"down\"\n            goto x + self.offsetX - 7.5 self.y\n            goto x + self.offsetX - 7.5 corresponding.editorY\n            goto x + self.offsetX corresponding.editorY\n            pen \"up\"\n            if look == \"point\" (\n              pen \"size\" 7.5\n              pen \"down\"\n              pen \"up\"\n            )\n            if look == \"arrow\" (\n              change_x 2\n              pen \"down\"\n              change -4 4\n              change 4 -4\n              change -4 -4\n              pen \"up\"\n            )\n          )\n        )\n        \n        goto x + 5 + self.offsetX self.y\n        \n        c shared.theme.text\n        local categories @= self.highlighting.getValues()\n        for i categories.len (\n          if categories[i].names.contains(instruction.kind) (\n            c categories[i].color\n          )\n        )\n        \n        text instruction.kind 9\n        \n        void self.drawData(instruction)\n      )\n      \n      self.y -= height / 2\n      \n      if instruction.kind == \"func\" (\n        drawInstructions(instruction.body, x + 20)\n      )\n      \n      if instruction.kind == \"newScope\" (\n        self.offsetX += 10\n      )\n    )\n    \n    def drawData(object instruction) (\n      switch instruction.kind (\n        case \"label\"\n          drawLabel(instruction.name)\n          break\n        case \"jump\"; case \"jumpIf\"; case \"jumpNotIf\";\n          drawLabel(instruction.label)\n          break\n        \n        case \"call\"\n          drawArgName(\"args\")\n          drawNum(instruction.args)\n          break\n        case \"unary\"; case \"binary\"\n          drawStr(instruction.op)\n          break\n        \n        case \"str\"\n          drawStr(instruction.data)\n          break\n        case \"num\"\n          drawNum(instruction.data)\n          break\n        case \"bool\"\n          drawBool(instruction.data)\n          break\n        case \"func\"\n          drawArgs(instruction.args)\n          break\n        case \"arr\"\n          drawArgName(\"elems\")\n          drawNum(instruction.elems)\n          break\n        case \"obj\"\n          drawArr(instruction.keys)\n          break\n        case \"color\"\n          drawColor(instruction.data)\n          break\n        \n        case \"get\"\n          drawVar(instruction.name)\n          break\n        case \"decl\"\n          drawVar(instruction.name)\n          break\n        \n        case \"asivar\"\n          if instruction.op != null (\n            drawStr(instruction.op)\n          )\n          drawVar(instruction.name)\n          break\n        case \"asiprop\"\n          if instruction.op != null (\n            drawStr(instruction.op)\n          )\n          break\n        \n        case \"dupe\"\n          drawArgName(\"idx\")\n          drawNum(instruction.i)\n          break\n      )\n    )\n    \n    def drawArgName(string name) (\n      text name 9 : c#shared.theme.text chx#7.5\n      text \"=\" 9 : chx#5\n      change_x -2.5\n    )\n    \n    def drawStr(string str) (\n      text str.JsonStringify() 9 : c#self.colors.str chx#7.5\n    )\n    def drawNum(number num) (\n      text num 9 : c#self.colors.num chx#7.5\n    )\n    def drawBool(boolean bool) (\n      text bool.toStr() 9 : c#self.colors.bool chx#7.5\n    )\n    def drawColor(string col) (\n      text col 9 : c#self.colors.col chx#7.5\n    )\n    def drawArr(array arr) (\n      text arr.join(\" \") 9 : c#shared.theme.text chx#7.5\n    )\n    def drawArgs(array args) (\n      text args.map(a -> \"@\" ++ a.name).join(\" \") 9 : c#self.colors.var chx#7.5\n    )\n    def drawVar(string name) (\n      text \"@\" ++ name 9 : c#self.colors.var chx#7.5\n    )\n    def drawLabel(string name) (\n      text \"#\" ++ name 9 : c#self.colors.label chx#7.5\n    )\n    \n    def getCorresponding(array instructions, number i) (\n      local cur @= instructions[i]\n      \n      if cur.kind == \"newScope\" (\n        local depth = 0\n        while i < instructions.len (\n          i ++\n          local instruction @= instructions[i]\n          if instruction.kind == \"newScope\" (\n            depth ++\n          )\n          if instruction.kind == \"popScope\" (\n            if depth == 0 (\n              return instruction\n            )\n            depth --\n          )\n        )\n      )\n      if cur.kind == \"popScope\" (\n        local depth = 0\n        while i > 0 (\n          i --\n          local instruction @= instructions[i]\n          if instruction.kind == \"newScope\" (\n            if depth == 0 (\n              return instruction\n            )\n            depth ++\n          )\n          if instruction.kind == \"popScope\" (\n            depth --\n          )\n        )\n      )\n      \n      if [\"jump\",\"jumpIf\",\"jumpNotIf\"].contains(cur.kind) (\n        for i instructions.len (\n          local instruction @= instructions[i]\n          if instruction.kind == \"label\" (\n            if instruction.name == cur.label (\n              return instruction\n            )\n          )\n        )\n      )\n    )\n  )\n  return __imports__c2496c7321897b9bfcdc4b07bd6e8f28\ncase \"./src/devtools/menus/storage.osl\"\n  class __imports__968375a74382766e626cb371cd10b43a (\n    \n  )\n  return __imports__968375a74382766e626cb371cd10b43a\ncase \"./src/devtools/menus/network.osl\"\n  class __imports__b4ec205ca81f7630cd7f76511fd744fb (\n    \n  )\n  return __imports__b4ec205ca81f7630cd7f76511fd744fb\ncase \"./src/devtools/menus/console.osl\"\n  class __imports__ac7f1c744ff0d794c130cdf96196926d (\n    def getInst() (\n      return layouts.shared.state.currentDocument.rtrInst\n    )\n    \n    def topbar() (\n      local inst @= self.getInst()\n      \n      goto frame.left + 10 0\n      square 15 15 0 0 1\n      if inst != null (\n        if mouse_touching (\n          cursor \"pointer\"\n          if onclick (\n            inst.console @= []\n          )\n        )\n        c shared.theme.text\n      ) else (\n        if mouse_touching (\n          cursor \"not-allowed\"\n        )\n        c shared.theme.seco\n      )\n      icon \"w 2.5 cutcircle 0 0 10 0 180 line -6 -6 6 6\" .7\n    )\n    \n    def update() (\n      local inst @= self.getInst()\n      \n      local y = frame.top + frame.scroll\n      local start = y\n      \n      for ii inst.console.len (\n        local item @= inst.console[ii]\n        local lines @= item[2].wrapText(frame.width - 10 / 10).split(\"\\n\")\n        local height = lines.len * 20\n        \n        local col = null\n        if item[1] == \"err\" or item[1] == \"repl-err\" (\n          col = #f00\n        )\n        \n        local ly = y\n        local sy = y\n        \n        y -= 5\n        y -= height\n        y -= 5\n        \n        if col != null (\n          frame frame.left y frame.right ly (\n            c col\n            pen \"opacity\" 20\n            pen \"size\" 10000\n            pen \"down\"\n            pen \"up\"\n          )\n        )\n        \n        local offsetX = 5\n        \n        if item[1].startsWith(\"repl\") (\n          goto frame.left + offsetX + 5 ly - 15\n          \n          if item[1] == \"repl-in\" (\n            icon \"right\" .5 : c#shared.theme.text\n          )\n          if item[1] == \"repl-ret\" (\n            icon \"left\" .5 : c#shared.theme.text\n          )\n          if item[1] == \"repl-err\" (\n            icon \"left\" .5 : c#shared.theme.text\n          )\n          offsetX += 20\n        )\n        \n        c shared.theme.text\n        for i lines.len (\n          ly -= 10\n          goto frame.left + offsetX ly - 5\n          text lines[i] 10\n          ly -= 10\n        )\n        \n        pen \"size\" 2 : c#shared.theme.prim\n        \n        goto 0 sy\n        line frame.left 0 frame.right 0\n        \n        goto 0 y\n        line frame.left 0 frame.right 0\n      )\n      \n      // repl\n      y -= 15\n      goto frame.left + 12.5 y\n      icon \"right\" .5 : c#shared.theme.text\n      \n      local inputId = \"devtools_repl_\" ++ inst.ouid\n      goto 12.5 y\n      input frame.width - 35 30 inputId null 0 shared.theme.text : c#shared.theme.back\n      \n      if \"enter\".onKeyDown() and inputs.selected.id == inputId (\n        local inp = inputs[inputId]\n        \n        void inst.console.append([\"repl-in\", inp])\n        \n        promiseData = inp\n        promiseData2 @= inst\n        self.runPromise @= Promise.new(def() -> (\n          local parser @= rtr.ast.Parser(\"event(onload){return(\" ++ promiseData ++ \");}\")\n          self.ast @= parser.parse()\n          self.mod @= rtr.main.Module(self.ast)\n          void rtr.apis.main.addToMod(layouts.shared.state.currentDocument, self.mod)\n          void promiseData2.addModule(self.mod)\n          local ret @= mod.runEventRaw({\n            name: \"onload\"\n          }, {})\n          return ret\n        ))\n        \n        inputs[inputId] = \"\"\n      )\n      \n      if self.runPromise != null (\n        local ret @= self.runPromise.worker.return\n        if ret != null (\n          void inst.console.append([\"repl-ret\", ret.stringify(true)])\n          self.runPromise = null\n        )\n      )\n      \n      y -= 15\n      \n      self.height = start - y - 10\n    )\n  )\n  return __imports__ac7f1c744ff0d794c130cdf96196926d\ncase \"./src/devtools/menus/elements.osl\"\n  class __imports__7de0f89117b2e081473955ae82bcf430 (\n    number indent = 20\n    \n    number x = 0\n    number y = 0\n    \n    number maxX = 0\n    \n    def drawElements(array elements) (\n      for i elements.len (\n        if elements[i] != null (\n          drawElement(elements[i])\n        )\n        if i < elements.len (\n          text \",\" 10\n        )\n      )\n    )\n    \n    def drawElement(object element) (\n      if element.children != null or element.kind == \"script\" (\n        self.y -= 15\n        goto 0 self.y\n        \n        element.dvt_open ??= false or true\n        \n        goto self.x self.y\n        square 20 20 0 0 1 : c#fff\n        if mouse_touching (\n          cursor \"pointer\"\n          if onclick (\n            element.dvt_open = !element.dvt_open\n          )\n        )\n        icon element.dvt_open ? \"down\" \"right\" .5 : c#shared.theme.text\n        \n        text element.blockName ?? element.name 10 : chx#15\n        if mouse_touching (\n          cursor \"pointer\"\n          devtools.main.hoveredElement = element.elemI\n          if onclick (\n            element.dvt_open = !element.dvt_open\n          )\n        )\n        \n        drawHeader(element.header)\n        \n        self.y -= 15\n        \n        if element.dvt_open (\n          text \"{\" 10 : chx#10\n          self.maxX = max(self.maxX, x_position)\n          self.x += self.indent\n          \n          if element.kind == \"script\" (\n            local content = element.body\n            local lines @= content.split(\"\\n\")\n            local line_height = 25\n            local height = lines.len - 1 * line_height + 5\n            \n            local cy = self.y - 2.5\n            self.y -= height\n            \n            for i lines.len (\n              cy -= line_height / 2\n              \n              goto self.x cy\n              \n              //self.maxX = max(self.maxX, x_position + (lines[i].len * 10))\n              //text lines[i].trimText(frame.right - x_position - 17.5 / 8) 10 : c#shared.theme.text\n              text lines[i] 10 : c#shared.theme.text\n              \n              cy -= line_height / 2\n            )\n          ) else (\n            drawElements(element.children)\n          )\n          \n          self.x -= self.indent\n          \n          self.y -= 15\n          goto self.x - 5 self.y\n          text \"}\" 10\n          self.y -= 15\n        ) else (\n          if element.kind == \"script\" (\n            text \"{\" 10 : chx#10\n            drawTooLong() : chx#10\n            text \"}\" 10 : chx#10\n          ) else (\n            text \"{\" 10 : chx#10\n            drawMiniChildren(element.children) : chx#10\n            text \"}\" 10 : chx#10\n          )\n          self.maxX = max(self.maxX, x_position)\n        )\n      ) else if element.kind == \"element\" (\n        self.y -= 15\n        goto self.x self.y\n        drawValue(element.value)\n        drawHeader(element.header)\n        local s = x_position\n        self.maxX = max(self.maxX, x_position)\n        local w = x_position - self.x\n        goto x_position + self.x / 2 self.y\n        square w 20 0 0 1\n        if mouse_touching (\n          devtools.main.hoveredElement = element.elemI\n        )\n        goto s self.y\n        self.y -= 15\n      ) else if element.kind == \"icon\" (\n        self.y -= 15\n        goto self.x self.y\n        text \"Icon\" 10\n        drawHeader(element.header)\n        self.maxX = max(self.maxX, x_position)\n        self.y -= 15\n      )\n    )\n    \n    def drawHeader(object header) (\n      if header.flags.len == 0 and header.pairs.len == 0 (\n        return\n      )\n      \n      change_x 7.5\n      text \"[\" 10\n      for i header.flags.len (\n        local flag = header.flags[i]\n        text flag 8\n        if i < header.flags.len or header.pairs.len > 0 (\n          text \", \" 8\n        )\n      )\n      \n      for i header.pairs.len (\n        local pair @= header.pairs[i]\n        text pair[1] 10\n        text \"=\" 8\n        drawValue(pair[2])\n        if i < header.pairs.len (\n          text \", \" 8\n        )\n      )\n      text \"]\" 10\n    )\n    \n    def drawValue(object value) (\n      switch value.type (\n        case \"str\"\n          text value.value.JsonStringify() 10\n          break\n        case \"num\"; case \"color\"\n          text value.value 10\n          break\n        case \"percentage\"\n          text value.value.toStr() ++ \"%\" 10\n          break\n      )\n    )\n    \n    def drawMiniChildren(array children) (\n      if children.len == 0 (\n        change_x -20\n        return\n      )\n      \n      change_x 5\n      for i children.len (\n        drawMiniChild(children[i])\n        if i < children.len (\n          text \", \" 8\n        )\n      )\n      change_x 5\n      \n      change_x -20\n    )\n    \n    def drawMiniChild(object element) (\n      if element.children != null or element.kind == \"script\" (\n        text element.blockName ?? element.name 7\n        text \"{\" 7 : chx#10\n        drawTooLong()\n        text \"}\" 7 : chx#20\n      ) else (\n        text \"Element\" 7\n      )\n    )\n    \n    def drawTooLong() (\n      text \"...\" 8 : chx#5\n      change_x -15\n    )\n    \n    def update() (\n      local document @= layouts.shared.state.currentDocument\n      local elements @= document.rwlInst.elements\n      if typeof(elements) != \"array\" (\n        elements @= []\n      )\n      \n      local s = frame.scroll_h * -1\n      self.x = frame.left + s + 15\n      local startX = self.x\n      self.y = frame.top + frame.scroll\n      local startY = self.y\n      \n      self.width = 0\n      self.maxX = 0\n      \n      if elements != null (\n        drawElements(elements)\n      )\n      \n      //self.width = self.maxX - startX\n      self.width = self.maxX - startX\n      self.height = startY - self.y + 5\n    )\n  )\n  return __imports__7de0f89117b2e081473955ae82bcf430\ncase \"./src/devtools/rightclick.osl\"\n  class __imports__0598a8fc1c085cefe2171384b023fe8b (\n    array topbar_more = [\n      [\"Dock\",\n        {\"left\": def() -> (\n          void shared.settings.set(\"devtools\", \"dockside\", \"l\")\n        )},\n        {\"right\": def() -> (\n          void shared.settings.set(\"devtools\", \"dockside\", \"r\")\n        )}\n      ]\n    ]\n  )\n  return __imports__0598a8fc1c085cefe2171384b023fe8b\ncase \"./src/devtools/topbar.osl\"\n  class __imports__3261b0e52c0051dec0dc6394c943d033 (\n    tabs_scroll = 0\n    tabs_width = 0\n    \n    def update() (\n      square frame.width frame.height 0 0 1\n      if mouse_touching (\n        self.tabs_scroll += scroll.x.velocity + scroll.y.velocity * -1.5 * scroll.multiplier\n      )\n      \n      self.tabs_scroll = min(self.tabs_scroll, self.tabs_width - frame.width)\n      self.tabs_scroll = max(self.tabs_scroll, 0)\n      \n      local x = frame.left - self.tabs_scroll\n      local start = x\n      local menus @= devtools.menus.getEntries()\n      for i menus.len (\n        local menu @= menus[i]\n        \n        local title = menu[1].toTitle()\n        local w = title.len * 8 + 10\n        \n        x += w / 2\n        \n        goto x 0\n        square w - 10 10 10 0 1\n        c devtools.main.menu == menu[1] ? shared.theme.seco shared.theme.prim\n        if mouse_touching (\n          c shared.theme.tert\n          cursor \"pointer\"\n          if onclick (\n            void shared.settings.set(\"devtools\", \"menu\", menu[1])\n          )\n        )\n        pen \"size\" 2\n        line w / -2 -11 w / 2 -11\n        centext title 8 : c#shared.theme.text\n        \n        x += w / 2\n      )\n      self.tabs_width = x - start\n    )\n  )\n  return __imports__3261b0e52c0051dec0dc6394c943d033\ncase \"./src/devtools/main.osl\"\n  class __imports__87f5572a1b07abb6f61e525f0557da7a (\n    string anchor = \"r\"\n    number width = 350\n    boolean open = false\n    \n    number saveWidth = 350\n    number resizingEdge = 0\n    \n    hoveredElement = 0\n    \n    string menu = \"console\"\n    \n    def alwaysUpdate() (\n      self.hoveredElement = 0\n    )\n    \n    def update(array area, array rawArea) (\n      goto rwl.area.centerX(area) rwl.area.centerY(area)\n      square rwl.area.width(area) - 10 rwl.area.height(area) - 10 10 : c#shared.theme.back\n      \n      local h = 25\n      frame area[1] area[4] area[3] area[4] - h (\n        goto 0 -5\n        square frame.width - 10 frame.height 10 : c#shared.theme.prim\n        \n        goto frame.right - 12.5 0\n        icon \"more-vertical\" .5 : c#shared.theme.text\n        if mouse_touching (\n          cursor \"pointer\"\n          if onclick (\n            local p @= Promise.new(() -> (\n              while mouse_down (\n                defer\n              )\n              open_rightclick devtools.rightclick.topbar_more\n            ))\n          )\n        )\n      )\n      frame area[1] area[4] area[3] - 25 area[4] - h (\n        void devtools.topbar.update()\n      )\n      \n      if mouse_y > area[2] and mouse_y < area[4] (\n        if anchor == \"r\" and abs(mouse_x - area[1]) < 5 (\n          cursor \"col-resize\"\n          goto mouse_x mouse_y\n          square 100 100 0 0 1\n          if onclick (\n            self.resizingEdge = 1\n          )\n        )\n        if anchor == \"l\" and abs(mouse_x - area[3]) < 5 (\n          cursor \"col-resize\"\n          goto mouse_x mouse_y\n          square 100 100 0 0 1\n          if onclick (\n            self.resizingEdge = 3\n          )\n        )\n      )\n      \n      if !mouse_down (\n        self.resizingEdge = 0\n      )\n      \n      if self.resizingEdge != 0 (\n        self.width = abs(mouse_x - area[4 - self.resizingEdge])\n      )\n      self.width = min(self.width, rwl.area.width(rawArea) - 200)\n      self.width = max(self.width, 200)\n      \n      local menu @= devtools.menus[self.menu]\n      \n      c shared.theme.prim\n      local topbarH = 0\n      if menu.topbar != null (\n        topbarH = menu.topbarHeight ?? 25\n        frame area[1] area[4] - h area[3] area[4] - h - topbarH (\n          void menu.topbar()\n        )\n        local w = rwl.area.width(area)\n        goto rwl.area.centerX(area) area[4] - h - topbarH\n        pen \"size\" 2\n        line w / -2 -1 w / 2 -1 : c#shared.theme.prim\n        topbarH += 1\n      )\n      \n      c shared.theme.prim\n      local bottombarH = 0\n      if menu.bottombar != null (\n        bottombarH = menu.bottombarHeight ?? 25\n        frame area[1] area[4] - h area[3] area[4] - h - bottombarH (\n          void menu.bottombar()\n        )\n        local w = rwl.area.width(area)\n        goto rwl.area.centerX(area) area[2] + bottombarH\n        pen \"size\" 2\n        line w / -2 1 w / 2 1 : c#shared.theme.prim\n        bottombarH += 1\n      )\n      \n      c shared.theme.prim\n      frame area[1] area[4] - h - topbarH area[3] area[2] + bottombarH [menu.width,menu.height] \"devtools_\" ++ self.menu (\n        if menu != null (\n          if menu.update != null (\n            void menu.update()\n          )\n        ) else (\n          goto 0 0\n          centext \"no open devtools menu\" 9 : c#shared.theme.prim\n        )\n      )\n    )\n  )\n  return __imports__87f5572a1b07abb6f61e525f0557da7a\ncase \"./src/layouts/summit/topbar.osl\"\n  class __imports__6a477e7780a631dfc33d414269cd6008 (\n    def update(array area) (\n      goto rwl.area.centerX(area) rwl.area.centerY(area)\n      square rwl.area.width(area) - 10 rwl.area.height(area) - 10 10 : c#shared.theme.back\n      \n      local btns @= layouts.shared.topbar.defaultButtons\n      void layouts.shared.topbar.winButtons(btns, false)\n      \n      local titlebarX = max(area[1], window.left + 30)\n      goto titlebarX + 10 rwl.area.centerY(area)\n      if layouts.shared.state.currentDocument != null (\n        local icn = layouts.shared.state.currentDocument.getIcon()\n        if icn != null (\n          icon icn 1 : c#fff chx#7.5\n          change_x 17.5\n        )\n        text layouts.shared.state.currentDocument.getTitle() 10 : c#shared.theme.text\n      )\n      \n      frame area[1] area[4] titlebarX area[2] (\n        goto 0 0\n        square frame.width - 5 25 0 0 1\n        if mouse_touching (\n          cursor \"pointer\"\n          if onclick (\n            layouts.summit.sidebar.open = true\n          )\n        )\n        icon \"right\" .6 : c#shared.theme.text chx#5\n      )\n    )\n  )\n  return __imports__6a477e7780a631dfc33d414269cd6008\ncase \"./src/layouts/summit/sidebar.osl\"\n  class __imports__3dfd082eaa91cc9b8340f13c6baac410 (\n    open_width = 250\n    \n    width = 200\n    tar_width = open_width\n    open = true\n    \n    def update(array area) (\n      goto rwl.area.centerX(area) rwl.area.centerY(area)\n      square rwl.area.width(area) - 20 rwl.area.height(area) - 20 10 : c#shared.theme.back\n      \n      frame area[1] + 10 area[4] - 10 area[3] - 10 area[4] - 35 (\n        //square 1000 1000 1000 : c#fff\n        goto frame.right - 12.5 0\n        square 20 20 0 0 1 : c#fff\n        if mouse_touching (\n          cursor \"pointer\"\n          if onclick (\n            self.open = false\n          )\n        )\n        goto frame.right - 12.5 0\n        icon \"left\" .6 : c#shared.theme.text\n        \n        goto frame.left + 12.5 0\n        square 20 20 0 0 1 : c#fff\n        if mouse_touching (\n          cursor \"pointer\"\n          if onclick (\n            void layouts.shared.state.openEmptyTab()\n          )\n        )\n        icon \"add\" .6 : c#shared.theme.text\n      )\n      \n      void layouts.shared.urlbar.update([\n        area[1] + 10,\n        area[4] - 40 - 32.5,\n        area[3] - 10,\n        area[4] - 40 - 2.5\n      ])\n      \n      c shared.theme.prim\n      frame area[1] + 5 area[4] - 40 - 35 area[3] - 5 area[2] + 5 self.height \"browser_sidebar\" (\n        local y = frame.top + frame.scroll\n        local startY = y\n        \n        for i layouts.shared.state.tabs.len (\n          local tab @= layouts.shared.state.tabs[i]\n          \n          local title = tab.document.getTitle()\n          local icon = tab.document.getIcon()\n          y -= 20\n          \n          local close_touching = false\n          \n          goto frame.right - 22.5 y\n          square 15 15 0 0 1\n          local close_touching = mouse_touching\n          \n          goto 0 y\n          c layouts.shared.state.currentTab == i ? shared.theme.seco shared.theme.prim\n          square frame.width - 25 20 15 : hover_c#shared.theme.tert\n          if mouse_touching and !close_touching (\n            cursor \"pointer\"\n            if onclick (\n              void layouts.shared.state.selectTab(i)\n            )\n          )\n          square frame.width - 25 20 10 : c#shared.theme.back\n          \n          goto frame.left + 15 y\n          if icon != null (\n            icon icon .9 : c#user.theme.text chx#7.5\n            change_x 15\n          )\n          text title.trimText(frame.right - x_position / 9 - 4) 9 : c#shared.theme.text tooltip#title\n          \n          goto frame.right - 22.5 y\n          square 15 15 0 0 1\n          if mouse_touching (\n            cursor \"pointer\"\n            if onclick (\n              void layouts.shared.state.closeTab(i)\n              i --\n            )\n          )\n          icon \"close\" .5\n          \n          y -= 20\n        )\n      )\n      self.height = startY - y - 7.5\n      \n      // clicking on the left side of the window opens the sidebar\n      if self.width < 25 (\n        goto window.left 0\n        square 20 window.height 0 0 1\n        if mouse_touching (\n          cursor \"pointer\"\n          if onclick (\n            self.open = true\n          )\n        )\n      )\n      \n      self.tar_width = self.open ? self.open_width 5\n      self.width += self.tar_width - self.width * min(delta_time, 0.02) * 10\n    )\n  )\n  return __imports__3dfd082eaa91cc9b8340f13c6baac410\ncase \"./src/layouts/summit/main.osl\"\n  class __imports__70bd3fa18cef0c20ca734751135b82d8 (\n    def init() (\n      void shared.document.init()\n      void layouts.shared.state.init()\n    )\n    \n    def update() (\n      void shared.theme.load()\n      void shared.input.update()\n      \n      window.show()\n      window_colour = #000\n      \n      glass:frame window.left window.top window.right window.bottom; frame \"clear\"\n      \n      void layouts.shared.state.resetDragbox()\n      \n      layouts.shared.state.dragbox[1][3] = max(layouts.summit.sidebar.width, 30)\n      \n      void layouts.summit.sidebar.update([\n        window.left + layouts.summit.sidebar.width - layouts.summit.sidebar.open_width,\n        window.bottom,\n        window.left + layouts.summit.sidebar.width,\n        window.top\n      ])\n      \n      void layouts.summit.topbar.update([\n        window.left + layouts.summit.sidebar.width,\n        window.top - 37.5,\n        window.right - 5,\n        window.top - 5\n      ])\n      \n      void layouts.shared.view.render([\n        window.left + layouts.summit.sidebar.width,\n        window.bottom + 5,\n        window.right - 5,\n        window.top - 42.5\n      ])\n      \n      void layouts.shared.state.applyDragbox()\n    )\n  )\n  return __imports__70bd3fa18cef0c20ca734751135b82d8\ncase \"./src/layouts/chromeLike/topbar.osl\"\n  class __imports__0f6f8e5da8ad7dfb8f0386ba0c4b7fd4 (\n    def tabs() (\n      local space = window.width - 100 - 17.5 - 15\n      \n      local hovered = false\n      \n      local x = 0\n      local tabMax = space / layouts.shared.state.tabs.len - 5\n      for i layouts.shared.state.tabs.len (\n        local tab @= layouts.shared.state.tabs[i]\n        \n        local title = tab.document.getTitle()\n        local icon = tab.document.getIcon()\n        \n        local pad = 15 + 27.5\n        if icon != null (\n          pad += 20\n        )\n        //local width = title.len * 9 + pad\n        local width = 200\n        //width = max(width, 200)\n        width = min(width, tabMax)\n        \n        local lx = x\n        x += 2.5 + (width / 2)\n        \n        loc 2 2 x + (width / 2) - 17.5 -20\n        square 15 15 0 0 1\n        local close_touching = mouse_touching\n        \n        loc 2 2 x -20\n        \n        square width - 17.5 17.5 15 0 1\n        c mouse_touching ? shared.theme.seco shared.theme.prim\n        if layouts.shared.state.currentTab == i (\n          c shared.theme.tert\n        )\n        square width - 17.5 17.5 15\n        \n        if mouse_touching and !close_touching (\n          layouts.shared.state.dragbox @= [\n            [2, 2, lx, 0],\n            [2, 2, lx + width, -20]\n          ]\n          hovered = true\n          \n          cursor \"pointer\"\n          if onclick (\n            void layouts.shared.state.selectTab(i)\n          )\n        )\n        \n        square width - 17.5 17.5 10 : c#shared.theme.prim\n        \n        if icon != null (\n          lx += 20\n          loc 2 2 lx -20\n          icon icon .9 : c#user.theme.text\n          lx += 5\n        )\n        lx += 10\n        \n        loc 2 2 lx -20\n        text title.trimText(width - pad / 9) 9 : c#shared.theme.text tooltip#title\n        \n        lx += 5\n        loc 2 2 x + (width / 2) - 17.5 -20\n        square 15 15 0 0 1\n        if mouse_touching (\n          cursor \"pointer\"\n          if onclick (\n            void layouts.shared.state.closeTab(i)\n            i --\n          )\n        )\n        icon \"close\" .5\n        \n        x += 2.5 + (width / 2)\n      )\n      \n      x += 17.5\n      loc 2 2 x -20\n      square 17.5 17.5 15 : c#shared.theme.prim hover_c#shared.theme.seco\n      if mouse_touching (\n        cursor \"pointer\"\n        if onclick (\n          void layouts.shared.state.openEmptyTab()\n        )\n      )\n      icon \"add\" .6 : c#user.theme.text\n      x += 20\n      \n      loc -2 2 -90 -20\n      line 0 -20 0 20 : c#shared.theme.prim w#1\n      \n      if !hovered (\n        layouts.shared.state.dragbox[1][3] += x\n      )\n    )\n  )\n  return __imports__0f6f8e5da8ad7dfb8f0386ba0c4b7fd4\ncase \"./src/layouts/chromeLike/main.osl\"\n  class __imports__34355e72215dbff81e1963b1534949ee (\n    def init() (\n      void shared.document.init()\n      void layouts.shared.state.init()\n    )\n    \n    def update() (\n      void shared.theme.load()\n      void shared.input.update()\n    \n      window.show()\n      window_colour = shared.theme.back\n      \n      void layouts.shared.state.resetDragbox()\n    \n      local btns @= layouts.shared.topbar.defaultButtons\n      void layouts.shared.topbar.winButtons(btns, false)\n      \n      void layouts.chromeLike.topbar.tabs()\n      \n      void layouts.shared.urlbar.update([\n        window.left,\n        window.top - 45 - 30,\n        window.right,\n        window.top - 44\n      ])\n      \n      void layouts.shared.view.render([\n        window.left,\n        window.bottom,\n        window.right,\n        window.top - 45 - 32.5\n      ])\n      \n      void layouts.shared.state.applyDragbox()\n    )\n  )\n  return __imports__34355e72215dbff81e1963b1534949ee\ncase \"./src/layouts/shared/view.osl\"\n  class __imports__5228a5cd2bf6a46e3a340119920c2e17 (\n    def render(array area) (\n      local contentArea @= rwl.area.copy(area)\n      \n      if devtools.main.open (\n        local devtoolsData @= devtools.main ?? { width: 0, anchor: \"l\" }\n        \n        local devtoolsArea @= rwl.area.copy(area)\n        switch devtoolsData.anchor (\n          case \"l\"\n            contentArea[1] += devtoolsData.width\n            devtoolsArea[3] = contentArea[1]\n            break\n          case \"r\"\n            contentArea[3] -= devtoolsData.width\n            devtoolsArea[1] = contentArea[3]\n            break\n        )\n      \n        devtoolsArea[1] += 5\n      )\n      \n      if layouts.shared.state.currentDocument != null (\n        void layouts.shared.state.currentDocument.checkResp()\n        void layouts.shared.state.currentDocument.render(contentArea)\n      )\n      \n      if devtools.main != null (\n        void devtools.main.alwaysUpdate()\n      )\n      if devtools.main.open (\n        void devtools.main.update(devtoolsArea, area)\n      )\n    )\n  )\n  return __imports__5228a5cd2bf6a46e3a340119920c2e17\ncase \"./src/layouts/shared/urlbar.osl\"\n  class __imports__e1f3f683350eb46be2bb39ac4a8762b8 (\n    inputId = \"browser_url\"\n    \n    def update(array area) (\n      local defaultText = \"blehh\"\n      \n      goto rwl.area.centerX(area) rwl.area.centerY(area) + 2.5\n      \n      local w = rwl.area.width(area) - 15\n      local h = rwl.area.height(area) - 0\n      \n      square w - 5 h - 18 15 : c#shared.theme.prim\n      input w h - 5 self.inputId defaultText 0 shared.theme.text\n      \n      if inputs.selected.id == self.inputId (\n        if \"enter\".onKeyDown() (\n          void self.goto()\n        )\n      )\n      \n      //void shared.graphics.box(area, #f00)\n    )\n    \n    def goto() (\n      local url = inputs[self.inputId]\n      \n      url @= shared.url.Url(url)\n      \n      if layouts.shared.state.tabs.len == 0 (\n        void layouts.shared.state.openEmptyTab()\n      )\n      \n      local tab @= layouts.shared.state.tabs[layouts.shared.state.currentTab]\n      void tab.redirect(url)\n    )\n  )\n  return __imports__e1f3f683350eb46be2bb39ac4a8762b8\ncase \"./src/layouts/shared/topbar.osl\"\n  class __imports__bce8e403422ca1f602a36f77e9c471c6 (\n    array defaultButtons = [\n      {\n        icon: \"close\",\n        click: window.close\n      },\n      {\n        icon: \"down\",\n        click: window.minimise\n      },\n      {\n        icon: \"maximise\",\n        click: window.fullscreen\n      }\n    ]\n    \n    def winButtons(array buttons, boolean background) (\n      if background (\n        local w = buttons.len * 25\n        \n        loc -2 2 w / -2 - 7.5 -20\n        square w - 5 18 10 : c#shared.theme.prim\n      )\n      \n      loc -2 2 -20 -20\n      change_x 25\n      for i buttons.len (\n        local button @= buttons[i]\n        \n        c shared.theme.text\n        icon button.icon 0.6 * (button.icon_size ?? 1) : hover_size#1.1 chx#-25\n        if mouse_touching (\n          cursor \"pointer\"\n          if onclick (\n            void button.click()\n          )\n        )\n      )\n    )\n  )\n  return __imports__bce8e403422ca1f602a36f77e9c471c6\ncase \"./src/layouts/shared/utils.osl\"\n  class __imports__bd7a86c2700e28469496d9f67248c0b2 (\n    def getContentArea() (\n      return [\n        window.left,\n        window.bottom,\n        window.right,\n        window.top - 50\n      ]\n    )\n  )\n  return __imports__bd7a86c2700e28469496d9f67248c0b2\ncase \"./src/layouts/shared/state.osl\"\n  class __imports__d1763f06b30a5d5d9c10608cf0f00c3e (\n    debug = false\n    \n    def init() (\n      void self.updateTab()\n      void self.selectTab(1)\n      \n      self.tabs @= []\n    )\n    \n    def resetDragbox() (\n      self.dragbox @= [[2,2,0,0],[-2,2,-90,-40]]\n    )\n    \n    def applyDragbox() (\n      window.setDragbox(self.dragbox[1], self.dragbox[2])\n      \n      if self.debug (\n        c #fff\n        loc self.dragbox[1][1] self.dragbox[1][2] self.dragbox[1][3] self.dragbox[1][4]\n        pen \"down\"\n        loc self.dragbox[2][1] self.dragbox[2][2] self.dragbox[2][3] self.dragbox[2][4]\n        pen \"up\"\n      )\n    )\n    \n    def openTabDocument(object document) (\n      local tab @= shared.tab.Tab(document)\n      void self.tabs.append(tab)\n      void self.selectTab(self.tabs.len)\n    )\n    \n    def openEmptyTab() (\n      void self.openTabDocument(shared.document.Document())\n    )\n    \n    def closeTab(number index) (\n      void self.tabs[index].document.close()\n      void self.tabs.delete(index)\n      \n      if index < self.currentTab (\n        self.currentTab --\n      )\n      \n      void self.selectTab(self.currentTab)\n    )\n    \n    def selectTab(number index) (\n      self.currentTab @= index\n      void self.updateTab()\n    )\n    \n    def updateTab() (\n      if self.currentDocument != null (\n        self.currentDocument.focused = false\n      )\n      self.currentDocument @= self.tabs[self.currentTab].document\n      if self.currentDocument.url != null (\n        inputs[layouts.shared.urlbar.inputId] = self.currentDocument.url.format()\n      ) else (\n        inputs[layouts.shared.urlbar.inputId] = \"\"\n      )\n      if inputs.selected.id == layouts.shared.urlbar.inputId (\n       input \"unfocus\"\n      )\n      \n      if self.currentDocument != null (\n        self.currentDocument.focused = true\n        \n        // fix for while workers be goofy\n        void self.currentDocument.createWorker()\n      )\n      //self.currentDocument ??= shared.document.Document()\n    )\n  )\n  return __imports__d1763f06b30a5d5d9c10608cf0f00c3e\ncase \"./src/assets/home.rwl\"\n  return \"  root {\\n    \\\"hi\\\"\\n  }\"\n\ncase \"./src/assets/empty.rwl\"\n  return \"  root {\\n    \\\"grahhh\\\"\\n  }\"\n\ncase \"./src/net/response.osl\"\n  class __imports__f336b41d073413cbdabb122f71c530f0 (\n    class Response (\n      isValid = false\n      \n      def init(object url, string content) (\n        self.url @= url\n        self.content = content\n        \n        self.isFinished = true\n      )\n    )\n    \n    class NoResponse extends Response (\n      \n    )\n    \n    class ValidResponse extends Response (\n      isValid = true\n      \n      def init(object url) (\n        self.url @= url\n        \n        self.isFinished = false\n      )\n      \n      def update() (\n        if self.isFinished (\n          return\n        )\n        local out @= self.fetch()\n        if out != null (\n          self.isFinished = true\n          self.content @= out\n        )\n      )\n    )\n  )\n  return __imports__f336b41d073413cbdabb122f71c530f0\ncase \"./src/net/fetch.osl\"\n  class __imports__d974ce5692d372884f5c4f8f8bf1ab18 (\n    def url(object url) (\n      if url.scheme == \"local\" (\n        //local f @= open(url.domain_name).toStr()\n        // fpp import instead (goes into output)\n        local f @= import(url.domain_name).toStr()\n        local r @= net.response.ValidResponse(url)\n        r.fetch @= def() -> (\n          self.content = self.f\n          self.isFinished = true\n        )\n        r.f @= f\n        return r\n      )\n      if url.scheme == shared.config.url.browser_scheme (\n        local r @= net.response.ValidResponse(url)\n        local page @= browserPages[url.domain_name]\n        if typeof(page) == \"string\" (\n          r.fetch @= def() -> (\n            self.content = self.data\n            self.isFinished = true\n          )\n          r.data @= page\n        ) else (\n          r.fetch @= page ?? (() -> ())\n        )\n        return r\n      )\n    \n      local servers @= shared.config.net.servers\n      local server @= servers[url.scheme]\n      \n      if server == null (\n        local r @= net.response.NoResponse(url, \"scheme '\" ++ url.scheme ++ \"' not found\")\n        return r\n      )\n      \n      local resource = url.domain_top\n      resource ++= \"/\"\n      if url.domain_sub != null (\n        resource ++= url.domain_sub\n        resource ++= \".\"\n      )\n      resource ++= url.domain_name\n      if url.resource != null (\n        resource ++= \"/\"\n        resource ++= url.resource\n      )\n      \n      local tld = server.tlds[url.domain_top]\n      \n      if tld == null (\n        local r @= net.response.NoResponse(url, \"tld '\" ++ url.domain_top ++ \"' not found\")\n        return r\n      )\n      \n      local realUrl = tld ++ \"/\" ++ resource\n      \n      local r @= net.response.ValidResponse(url)\n      r.fetch @= def() -> (\n        local o = self.realUrl.getAsync()\n        if o != \"Loading\" and o != \"404: Not Found\" (\n          self.content = o\n          self.isFinished = true\n        )\n      )\n      r.realUrl = realUrl\n      \n      return r\n    )\n  )\n  return __imports__d974ce5692d372884f5c4f8f8bf1ab18\ncase \"./src/shared/save.osl\"\n  class __imports__adb9c40aa8851930265661f644c37fb1 (\n    def setName(string name) (\n      save name \"set_directory\"\n    )\n    \n    def exists(string fileName) (\n      return fileName.saveExists()\n    )\n    \n    def get(string fileName) (\n      if !self.exists(fileName) (\n        throw fileName ++ \"does not exist\"\n      )\n    \n      return fileName.saveGet().toStr()\n    )\n    \n    def set(string fileName, string data) (\n      save fileName \"set\" data\n    )\n  )\n  return __imports__adb9c40aa8851930265661f644c37fb1\ncase \"./src/shared/settings.osl\"\n  class __imports__b9d870002d9a38c65f33053e346a5da3 (\n    object entries = {\n      devtools: {\n        dockside: {\n          type: \"string\",\n          desc: \"what side devtools is anchored to\",\n          default: \"r\",\n          applySetting: def(string value) -> (\n            devtools.main.anchor = value\n          )\n        },\n        open: {\n          type: \"boolean\",\n          desc: \"if devtools is open or not\",\n          default: false,\n          applySetting: def(boolean value) -> (\n            devtools.main.open = value\n          )\n        },\n        menu: {\n          type: \"string\",\n          desc: \"current open devtools menu\",\n          default: \"console\",\n          applySetting: def(string value) -> (\n            devtools.main.menu = value\n          )\n        }\n      },\n      net: {\n        offline: {\n          type: \"boolean\",\n          desc: \"disables networking\",\n          default: false\n        }\n      }\n    }\n    \n    object _data = {}\n    \n    def load() (\n      local br @= shared.config.browser\n      void shared.save.setName(br.name ++ \"@\" ++ br.save_developer)\n      if !shared.save.exists(\"settings.json\") (\n        void self.write()\n      )\n      self._data @= self.deserialize(shared.save.get(\"settings.json\"))\n      void self.applySettings()\n      void self.write()\n    )\n    \n    def write() (\n      void shared.save.set(\"settings.json\", self.serialize())\n    )\n    \n    def get(string category, string entry) (\n      return self._data[category][entry]\n    )\n    def set(string category, string entry, value) (\n      local entryData @= self.entries[category][entry]\n      if entryData == null (\n        throw \"setting\" + category ++ \"/\" ++ entry + \"doesnt exist\"\n      )\n      \n      if entryData.type != typeof(value) (\n        throw \"expected\" + entry.type + \"for\" + category ++ \"/\" ++ entry + \"but got\" + typeof(value)\n      )\n      self._data[category][entry] @= value\n      void self.write()\n      void self.applySettings()\n    )\n    \n    def applySettings() (\n      local categoryData @= self.entries.getEntries()\n      for categoryI categoryData.len (\n        local category @= categoryData[categoryI]\n        local entryData @= category[2].getEntries()\n        for entryI entryData.len (\n          local entry @= entryData[entryI]\n          local value = self._data[category[1]][entry[1]] ?? entry[2].default\n          if entry[2].applySetting != null (\n            void entry[2].applySetting(value)\n          )\n        )\n      )\n    )\n    \n    def serialize() (\n      local out @= {}\n      local categoryData @= self.entries.getEntries()\n      for categoryI categoryData.len (\n        local category @= categoryData[categoryI]\n        out[category[1]] @= {}\n        local entryData @= category[2].getEntries()\n        for entryI entryData.len (\n          local entry @= entryData[entryI]\n          local value = self._data[category[1]][entry[1]] ?? entry[2].default\n          out[category[1]][entry[1]] @= value\n        )\n      )\n      return out.JsonStringify()\n    )\n    def deserialize(string data) (\n      local raw @= data.JsonParse()\n      \n      local out @= {}\n      local categoryData @= self.entries.getEntries()\n      for categoryI categoryData.len (\n        local category @= categoryData[categoryI]\n        out[category[1]] @= {}\n        local entryData @= category[2].getEntries()\n        for entryI entryData.len (\n          local entry @= entryData[entryI]\n          local value = raw[category[1]][entry[1]] ?? entry[2].default\n          out[category[1]][entry[1]] @= value\n        )\n      )\n      return out\n    )\n  )\n  return __imports__b9d870002d9a38c65f33053e346a5da3\ncase \"./src/shared/input.osl\"\n  class __imports__f477f9b400e164d253c3bfeb6a54c186 (\n    boolean rwlLeftClick = false\n    \n    def reset() (\n      self.rwlLeftClick = false\n    )\n    \n    def update() (\n      self.leftClick = mouse_left and !self.leftDown\n      self.leftDown = mouse_left\n      if self.leftClick (\n        self.rwlLeftClick = true\n      )\n      \n      // TODO: make a keybind system?\n      if \"`\".onKeyDown() (\n        void shared.settings.set(\"devtools\", \"open\", !shared.settings.get(\"devtools\", \"open\"))\n        //devtools.main.open = !devtools.main.open\n      )\n    )\n  )\n  return __imports__f477f9b400e164d253c3bfeb6a54c186\ncase \"./src/shared/tab_worker.osl\"\n  class __imports__ed11349f32bd7389fac05d89b56e016d (\n    def oncreate() (\n      self.ouid = OuidNew()\n    )\n    \n    def onframe() (\n      if self.parseText != null (\n        local parser @= rwl.ast.Parser(self.parseText)\n        if self != null (\n          //log self\n          void self.document.loadAst(parser.parse())\n          self.parseText = null\n        )\n      )\n      if self.document != null and self.document.focused (\n        void self.document.rwlInst.interactUpdate({\n          rtr: self.document.rtrInst\n        })\n        void self.document.rtrUpdate()\n        //void self.document.rwlInst.checkElemUpdate()\n        local mods @= self.document.rtrInst.modules.getValues()\n        for i mods.len (\n          void mods[i].runEventQueue()\n        )\n        void shared.input.reset()\n      )\n    )\n  )\n  return __imports__ed11349f32bd7389fac05d89b56e016d\ncase \"./src/shared/config.osl\"\n  class __imports__9f198a2aa8925b082e5f887a2bba9b67 (\n    class net (\n      servers = {\n        rtr: {\n          url: \"https://web.rotur.dev/\",\n          \n          // <server>/<command>\n          commands: {\n            tlds: \"tlds\"\n          }\n        }\n      }\n      \n      def refresh() (\n        if shared.settings.get(\"net\", \"offline\") (\n          self.servers @= []\n        )\n        \n        for i self.servers.len (\n          local s @= self.servers.getValues()[i]\n          s.tlds @= (s.url ++ s.commands.tlds).httpGet()\n        )\n      )\n    )\n    \n    class url (\n      string browser_scheme = build.package.phosphorus.browser_scheme ?? \"phos\"\n      \n      class defaults (\n        string scheme = \"rtr\"\n        string name = \"unknown\"\n        string top = \"web\"\n      )\n    )\n    \n    class browser (\n      string name = build.package.name ?? \"phosphorus\"\n      array developers = build.package.developers ?? [\"flufi\"]\n      string version = build.package.version ?? \"1.0.0a\"\n      \n      // browserName@developer\n      string save_developer = build.package.save_developer ?? \"rotur\"\n      \n      class phosphorus (\n        string version = \"1.0.0a\"\n        \n        boolean useCanvas = false\n        boolean useCompiler = true\n      )\n    )\n  )\n  return __imports__9f198a2aa8925b082e5f887a2bba9b67\ncase \"./src/shared/theme.osl\"\n  class __imports__5876b7f6fcd5ce7f0fafd1a44ec4bd74 (\n    def load() (\n      self.back = user.theme.background\n      self.prim = user.theme.primary\n      self.seco = user.theme.secondary\n      self.tert = user.theme.tertiary\n      self.text = user.theme.text\n      self.accent = global_accent\n    )\n    \n    load()\n  )\n  return __imports__5876b7f6fcd5ce7f0fafd1a44ec4bd74\ncase \"./src/shared/url.osl\"\n  class __imports__a1d00c2cd890aa6e92598446ff24f924 (\n    class Url (\n      def init(string text) (\n        void self.parse(text)\n      )\n      \n      def parse(string text) (\n        self.text = text\n        local s @= text.match(\"/^((\\\\w+):\\\\/\\\\/)/\")\n        local match @= text.match(\"/^((\\\\w+):\\\\/\\\\/)?(((\\\\w+)\\\\.)?(\\\\w+)(\\\\.(\\\\w+))?\\\\/?(([\\\\/w]+)?(\\\\/(\\\\w+\\\\.\\\\w+))?))\\\\/?/\")\n        \n        self.scheme = match[3] ?? s[3] ?? shared.config.url.defaults.scheme\n        \n        if self.scheme == \"local\" (\n          self.domain_name = text.trim(\"local://\".len + 1, -1)\n          local usrPath = \"origin/(c) users/\" ++ username\n          if self.domain_name.toLower().startsWith(usrPath.toLower()) (\n            self.domain_name = \"~\" ++ self.domain_name.trim(usrPath.len + 1, -1)\n          )\n          self.domain_top = null\n          self.domain_sub = null\n          self.path = null\n          self.params @= {}\n          self.resource = null\n          self.text = \"local://\" ++ self.domain_name\n          return\n        )\n        \n        if match[9] != null (\n          local domain_name = match[7]\n          local domain_top = match[9]\n          local domain_sub = match[6]\n        ) else (\n          if match[6] != null (\n            local domain_name = match[6]\n            local domain_top = match[7]\n            local domain_sub = null\n          ) else (\n            local domain_name = match[7]\n            local domain_top = null\n            local domain_sub = null\n          )\n        )\n        \n        self.domain_name = domain_name ?? shared.config.url.defaults.name\n        self.domain_top = domain_top ?? shared.config.url.defaults.top\n        self.domain_sub = domain_sub\n        self.path = match[13]\n        self.params @= {}\n        self.resource = match[10] ?? \"index.rwl\"\n        \n        if self.scheme == shared.config.url.browser_scheme (\n          self.domain_top = null\n        )\n      )\n      \n      def format() (\n        if self.scheme == \"local\" (\n          return self.text\n        )\n        local sub = self.domain_sub != null ? self.domain_sub ++ \".\" \"\"\n        local top = self.domain_top != null ? \".\" ++ self.domain_top \"\"\n        local txt = self.scheme ++ \"://\" ++ sub ++ domain_name ++ top\n        if self.path != null (\n          txt ++= \"/\" ++ self.path\n        )\n        if self.resource != \"index.rwl\" (\n          txt ++= \"/\" ++ self.resource\n        )\n        return txt\n      )\n      \n      def getTitle() (\n        if self.scheme == \"local\" (\n          return self.domain_name.split(\"/\")[-1].split(\".\")[1]\n        )\n        return self.domain_name\n      )\n    )\n  )\n  return __imports__a1d00c2cd890aa6e92598446ff24f924\ncase \"./src/shared/tab.osl\"\n  class __imports__0ffc38803b2c8e6e0623c0ea1ffbcc28 (\n    class Tab (\n      def init(object document) (\n        self.document @= document\n      )\n      \n      def redirect(object url) (\n        void self.document.loadUrl(url)\n        void layouts.shared.state.updateTab()\n      )\n    )\n  )\n  return __imports__0ffc38803b2c8e6e0623c0ea1ffbcc28\ncase \"./src/shared/document.osl\"\n  class __imports__af13446f70bd7836009892ffef4b5078 (\n    class Document (\n      def init() (\n        void self.createInsts()\n        \n        self.started = false\n        self.shouldBeAlive = false\n        self.focused = false\n      )\n      \n      def close() (\n        void self.killWorker()\n      )\n      \n      def createWorker() (\n        //log \"create worker\"\n        void self.killWorker()\n        self.worker @= worker(shared.tab_worker)\n        self.worker.document @= self\n        self.shouldBeAlive = true\n      )\n      \n      def killWorker() (\n        if self.worker != null (\n          //log \"kill worker\"\n          if self.worker.kill == null (\n            return\n          )\n          void self.worker.kill()\n          self.worker = null\n          self.shouldBeAlive = false\n        )\n      )\n      \n      def createInsts() (\n        self.title = \"New Tab\"\n        if self.url != null (\n          self.title = self.url.getTitle()\n        )\n        self.icon = null\n        \n        self.rtrInst @= rtr.main.RTR()\n        self.rwlInst @= rwl.main.RWL(shared.document.empty, self.rtrInst)\n      )\n      \n      def updateInsts() (\n        // inject apis\n        void rtr.apis.main.addToInst(self, self.rtrInst)\n      )\n      \n      def update(array area) (\n        void self.rwlInst.update(area)\n      )\n      \n      def rtrUpdate() (\n        if !self.started and self.rwlInst.hasUpdated (\n          void self.rtrInst.startModules()\n          self.started = true\n        )\n      )\n      \n      def render(array area) (\n        if self.worker != null (\n          self.worker.area @= area\n          if !self.worker.alive and self.shouldBeAlive (\n            //void self.createWorker()\n            //self.rwlInst.errored = true\n            //self.rwlInst.errormsg = \"tab worker died, check js console\"\n          )\n        )\n        \n        goto rwl.area.centerX(area) rwl.area.centerY(area)\n        square rwl.area.width(area) - 10 rwl.area.height(area) - 10 10 : c#shared.theme.back\n        \n        if self.loading (\n          goto rwl.area.centerX(area) rwl.area.centerY(area)\n          direction timer * 720\n          icon \"sync\" .75 : c#shared.theme.text\n          direction 90\n          return\n        )\n        \n        //log self.rwlInst\n        void self.rwlInst.render(area)\n      )\n      \n      def checkResp() (\n        if self.resp == null (\n          self.loading = false\n          return\n        )\n        \n        if self.resp.isFinished (\n          if self.resp.isValid (\n            self.loading = false\n            \n            void self.createInsts()\n            void self.loadText(self.resp.content)\n            \n            self.resp = null\n          )\n        ) else (\n          self.loading = true\n          void self.resp.update()\n        )\n      )\n      \n      def loadAst(object ast) (\n        void self.createInsts()\n        void self.rwlInst.loadFromAst(ast)\n        void self.updateInsts()\n        self.started = false\n      )\n      \n      def loadText(string text) (\n        void self.createWorker()\n        self.worker.parseText = text\n      )\n      \n      def loadUrl(object url) (\n        self.url @= url\n        void self.createInsts()\n        self.resp @= net.fetch.url(url)\n      )\n      \n      def getIcon() (\n        return self.icon\n      )\n      def getTitle() (\n        return self.title\n      )\n    )\n    \n    def init() (\n      local parser @= rwl.ast.Parser(import(\"./src/assets/empty.rwl\"))\n      self.empty @= parser.parse()\n    )\n  )\n  return __imports__af13446f70bd7836009892ffef4b5078\ncase \"./src/shared/utils.osl\"\n  class __imports__ace3e4fea1b83d3f4a6cf8da09fee544 (\n    def removeIndents(str) (\n      local lines @= str.split(\"\\n\")\n      local indent = null\n      for i lines.len (\n        local l2 = lines[i].match(\"/^( *)(.+)$/\")\n        if l2[2].len > 0 (\n          indent = min(indent ?? 9999, l2[2].len)\n        )\n      )\n      for i lines.len (\n        lines[i] = lines[i].trim(indent + 1, -1)\n      )\n      return lines.join(\"\\n\")\n    )\n    \n    def jsFunc(string js) (\n      local f @= js.eval()\n      local f2 @= () -> ()\n      f2.code @= f\n      return f2\n    )\n  )\n  return __imports__ace3e4fea1b83d3f4a6cf8da09fee544\ncase \"./src/shared/graphics.osl\"\n  class __imports__8840a5e065c53e817186a2216f863bca (\n    _canvasID = null\n    _canvas = null\n    \n    def init() (\n      if shared.config.browser.phosphorus.useCanvas (\n        self._canvasID = OuidNew()\n        self._canvas @= shared.canvas.createCanvas(self._canvasID, window.width, window.height)\n        log self\n      )\n    )\n    \n    // cursor\n    cursor_x = 0\n    cursor_y = 0\n    def goto(number x, number y) (\n      self.cursor_x = x\n      self.cursor_y = y\n    )\n    \n    def change_x(number x) (\n      self.cursor_x += x\n    )\n    def change_y(number y) (\n      self.cursor_y += y\n    )\n    def change(number x, number y) (\n      self.cursor_x += x\n      self.cursor_y += y\n    )\n    \n    // utils\n    def getTextWidth(string text) (\n      return text.len\n    )\n    \n    // rendering\n    def box(array area, string color) (\n      c color\n      pen \"size\" 1\n      goto area[1] area[2]\n      pen \"down\"\n      goto area[3] area[2]\n      goto area[3] area[4]\n      goto area[1] area[4]\n      goto area[1] area[2]\n      pen \"up\"\n    )\n    \n    def filledBox(array area, rounding, string color) (\n      local x = rwl.area.centerX(area)\n      local y = rwl.area.centerY(area)\n      local w = rwl.area.width(area)\n      local h = rwl.area.height(area)\n      \n      if typeof(rounding) == \"number\" (\n        rounding @= [rounding,rounding,rounding,rounding]\n      )\n      \n      c color\n      \n      if typeof(rounding) == \"number\" (\n        goto x y\n        frame area[1] area[4] area[3] area[2] (\n          local r = max(rounding * 2 - 10, 0)\n          square w - r h - r r\n        )\n      ) else if typeof(rounding) == \"array\" (\n        // could rework this to have it be corner - rounding for pos\n        // so it would have higher parity with canvas?\n        x = round(x)\n        y = round(y)\n        local hw = w / 2\n        local hh = h / 2\n        goto x y\n        //local r = min(rounding[1] * 2, min(w, h) / 2)\n        frame area[1] y x area[2] (\n          local r = max(rounding[1] * 2, 0)\n          goto frame.left + hw frame.bottom + hh\n          square frame.width * 2 - r frame.height * 2 - r r\n        )\n        frame x y area[3] area[2] (\n          local r = max(rounding[2] * 2, 0)\n          goto frame.right - hw frame.bottom + hh\n          square frame.width * 2 - r frame.height * 2 - r r\n        )\n        frame area[1] area[4] x y (\n          local r = max(rounding[3] * 2, 0)\n          goto frame.left + hw frame.top - hh\n          square frame.width * 2 - r frame.height * 2 - r r\n        )\n        frame x area[4] area[3] y (\n          local r = max(rounding[4] * 2, 0)\n          goto frame.right - hw frame.top - hh\n          square frame.width * 2 - r frame.height * 2 - r r\n        )\n      )\n    )\n    \n    def filledTransparentArea(array area, string color, number opacity) (\n      frame area[1] area[4] area[3] area[2] (\n        c color\n        pen \"opacity\" opacity\n        pen \"size\" 9999\n        goto 0 0\n        pen \"down\"\n        pen \"up\"\n      )\n    )\n    \n    def ctext(string text, number size, string color) (\n      void ptext(text, self.cursor_x, self.cursor_y, size, color)\n    )\n    def ptext(string text, number x, number y, number size, string color) (\n      goto x y\n      text text size : c#color\n    )\n    \n    def cicon(string src, number size, string color) (\n      void picon(text, self.cursor_x, self.cursor_y, size, color)\n    )\n    def picon(string src, number x, number y, number size, string color) (\n      goto x y\n      icon src size : c#color\n    )\n  )\n  return __imports__8840a5e065c53e817186a2216f863bca\ncase \"./src/rtr/apis/browser.osl\"\n  class __imports__7fe61a304bd2774f13f2fe6e50c50f2a (\n    def addToMod(object doc, object mod) (\n      void mod.declScopeVar(\"$$brwsr\", rtr.value.RTRObjValue({\n        settings: rtr.value.RTRObjValue({\n          getCategories: rtr.value.RTROslFuncValue(def() -> (\n            return rtr.value.RTRArrValue(shared.settings.entries.getKeys().map(c -> rtr.value.RTRStrValue(c)))\n          )),\n          getCategory: rtr.value.RTROslFuncValue(def() -> (\n          \n          ))\n        })\n      }))\n    )\n  )\n  return __imports__7fe61a304bd2774f13f2fe6e50c50f2a\ncase \"./src/rtr/apis/rwl.osl\"\n  class __imports__da08879ce20a927bf625b809217d8644 (\n    class RTRDocument extends rtr.value.RTRValue (\n      def init(object doc) (\n        self.doc @= doc\n      )\n    \n      def getRtrType() (\n        return rtr.value.RTRTypeValue({\n          name: \"document\"\n        })\n      )\n      \n      def getItem(key) (\n        switch key.stringify() (\n          // values\n          case \"title\"\n            return rtr.value.RTRStrValue(self.doc.title)\n          case \"icon\"\n            if self.doc.icon == null (\n              return rtr.value.RTRNullValue()\n            )\n            return rtr.value.RTRStrValue(self.doc.icon)\n          case \"root\"\n            local elems @= self.doc.rwlInst.elements\n            for i elems.len (\n              local elem @= elems[i]\n              if elem.name == \"RWLRoot\" (\n                return rtr.apis.rwl.RTRElement(elem)\n              )\n            )\n            return rtr.value.RTRNullValue()\n          \n          // methods\n          case \"redirect\"\n            return rtr.value.RTROslFuncValue(def(args, _inst, doc) -> (\n              void doc.doc.loadUrl(shared.url.Url(args[1].stringify()))\n              void layouts.shared.state.updateTab()\n            ), self)\n          case \"getElement\"\n            return rtr.value.RTROslFuncValue(def(args, _inst, doc) -> (\n              local elem @= doc.doc.rwlInst.getElement(args[1].stringify())\n              if elem == null (\n                return rtr.value.RTRNullValue()\n              )\n              return rtr.apis.rwl.RTRElement(elem)\n            ), self)\n          case \"createTextElement\"\n            return rtr.value.RTROslFuncValue(def(args, _inst) -> (\n              return rtr.apis.rwl.RTRElement(rwl.main.RWLElement(rtr.apis.rwl.rtrValueToRwlValue(args[1]), { flags: [], pairs: [] }))\n            ))\n          case \"createScript\"\n            return rtr.value.RTROslFuncValue(def(args, _inst, doc) -> (\n              local elem @= rwl.main.RWLScript(args[1].stringify(), { flags: [], pairs: [] }, doc.doc.rwlInst)\n              void rtr.apis.main.addToMod(doc.doc, elem.mod)\n              void elem.start()\n              return rtr.apis.rwl.RTRElement(elem)\n            ), self)\n          case \"createContainer\"\n            return rtr.value.RTROslFuncValue(def(args, _inst) -> (\n              local kind = args[1].stringify()\n              switch kind (\n                case \"frame\"\n                  return rtr.apis.rwl.RTRElement(rwl.main.RWLFrame([], { flags: [], pairs: [] }))\n                case \"section\"\n                  return rtr.apis.rwl.RTRElement(rwl.main.RWLSection([], { flags: [], pairs: [] }))\n                case \"button\"\n                  return rtr.apis.rwl.RTRElement(rwl.main.RWLButton([], { flags: [], pairs: [] }))\n                \n                default\n                  throw \"unknown container type\" + kind\n              )\n              return rtr.apis.rwl.RTRElement(rwl.main.RWLElement(rtr.apis.rwl.rtrValueToRwlValue(args[1]), { flags: [], pairs: [] }))\n            ))\n          \n          default\n            throw \"unknown property\" + key.stringify() + \"on document\"\n        )\n      )\n      \n      def setItem(key, value) (\n        switch key.stringify() (\n          case \"title\"\n            self.doc.title = value.stringify()\n            break\n          case \"icon\"\n            self.doc.icon = value.stringify()\n            break\n          default\n            throw \"cannot set property\" + key.stringify() + \"on document\"\n        )\n      )\n    )\n    \n    class RTRElement extends rtr.value.RTRValue (\n      isRwlElem = true\n      \n      def init(object elem) (\n        self.elem @= elem\n      )\n    \n      def getRtrType() (\n        return rtr.value.RTRTypeValue({\n          name: \"element\"\n        })\n      )\n      \n      def stringify() (\n        local txt = (self.elem.blockName ?? self.elem.kind).toStr()\n        if self.elem.id != null (\n          txt ++= \":\" ++ self.elem.id\n        )\n        return \"<\" ++ txt ++ \">\"\n      )\n      \n      def getItem(key) (\n        local k = key.stringify()\n        \n        switch k (\n          case \"toggleFlag\"\n            return rtr.value.RTROslFuncValue(def(args, _inst, elem) -> (\n              local flags @= elem.elem.header.flags\n              local name = args[1].stringify()\n              \n              if flags.contains(name) (\n                void flags.delete(flags.index(name))\n              ) else (\n                void flags.append(name)\n              )\n              \n              elem.elem.needsUpdate = true\n              void elem.elem.checkUpdate()\n            ), self)\n          case \"addFlag\"\n            return rtr.value.RTROslFuncValue(def(args, _inst, elem) -> (\n              local flags @= elem.elem.header.flags\n              local name = args[1].stringify()\n              \n              if !flags.contains(name) (\n                void flags.append(name)\n              )\n              \n              elem.elem.needsUpdate = true\n              void elem.elem.checkUpdate()\n            ), self)\n          case \"removeFlag\"\n            return rtr.value.RTROslFuncValue(def(args, _inst, elem) -> (\n              local flags @= elem.elem.header.flags\n              local name = args[1].stringify()\n              \n              if flags.contains(name) (\n                void flags.delete(flags.index(name))\n              )\n              \n              elem.elem.needsUpdate = true\n              void elem.elem.checkUpdate()\n            ), self)\n          case \"hasFlag\"\n            return rtr.value.RTROslFuncValue(def(args, _inst, elem) -> (\n              local flags @= elem.elem.header.flags\n              local name = args[1].stringify()\n              \n              return rtr.value.RTRBoolValue(flags.contains(name))\n            ), self)\n          \n          case \"addChild\"\n            return rtr.value.RTROslFuncValue(def(args, _inst, elem) -> (\n              if elem.elem.children == null (\n                throw elem.kind + \"cannot contain children\"\n              )\n              if !args[1].isRwlElem (\n                throw \"argument is not rwl element\"\n              )\n              void elem.elem.children.append(args[1].elem)\n              \n              void elem.elem.updateParentFromCache()\n            ), self)\n          case \"popChild\"\n            return rtr.value.RTROslFuncValue(def(args, _inst, elem) -> (\n              if elem.elem.children == null (\n                throw elem.kind + \"doesnt contain children\"\n              )\n              local idx = args.len > 0 ? args[1].numbify() 1\n              local out @= elem.elem.children[idx]\n              if out != null (\n                out @= rtr.apis.rwl.RTRElement(out)\n              ) else (\n                out @= rtr.value.RTRNullValue()\n              )\n              void elem.elem.children.delete(idx)\n              \n              void elem.elem.updateParentFromCache()\n              return out\n            ), self)\n        )\n        \n        for i self.elem.header.pairs.len (\n          local pair @= self.elem.header.pairs[i]\n          if pair[1] == k (\n            return rtr.apis.rwl.rwlValueToRtrValue(pair[2])\n          )\n        )\n        return rtr.value.RTRNullValue()\n      )\n      \n      def setItem(key, value) (\n        local k = key.stringify()\n        local v @= rtr.apis.rwl.rtrValueToRwlValue(value)\n        \n        if k == \"text\" and self.elem.name == \"RWLElement\" (\n          self.elem.value @= v\n          void self.elem.updateFromCache()\n          return\n        )\n        \n        for i self.elem.header.pairs.len (\n          local pair @= self.elem.header.pairs[i]\n          if pair[1] == k (\n            pair[2] @= v\n            void self.elem.updateParentFromCache()\n            return\n          )\n        )\n        \n        void self.elem.header.pairs.append([\n          k, v\n        ])\n        \n        void self.elem.updateParentFromCache()\n      )\n    )\n    \n    def rwlValueToRtrValue(object val) (\n      switch val.type (\n        case \"str\"\n          return rtr.value.RTRStrValue(val.value)\n        case \"num\"\n          return rtr.value.RTRNumValue(val.value)\n        // percentage\n        // color\n      )\n      \n      return rtr.value.RTRNullValue()\n    )\n    \n    def rtrValueToRwlValue(object val) (\n      local type @= val.getRtrType()\n      \n      switch type.data.name (\n        case \"str\"\n          return rwl.value.RWLStrValue(val.value)\n        case \"num\"\n          return rwl.value.RWLNumValue(val.value)\n        case \"color\"\n          return rwl.value.RWLColorValue(val.value)\n      )\n      \n      throw \"cannot set\" + type.stringify() + \"as rwl property\"\n    )\n    \n    // applies rwl related apis to rtr\n    def addToMod(object doc, object mod) (\n      void mod.declScopeVar(\"document\", RTRDocument(doc))\n      void mod.declScopeVar(\"theme\", rtr.value.RTRObjValue({\n        back: rtr.value.RTRColorValue(shared.theme.back),\n        prim: rtr.value.RTRColorValue(shared.theme.prim),\n        seco: rtr.value.RTRColorValue(shared.theme.seco),\n        tert: rtr.value.RTRColorValue(shared.theme.tert),\n        text: rtr.value.RTRColorValue(shared.theme.text),\n        accent: rtr.value.RTRColorValue(shared.theme.accent),\n      }))\n    )\n  )\n  return __imports__da08879ce20a927bf625b809217d8644\ncase \"./src/rtr/apis/main.osl\"\n  class __imports__60f47f43e26f20419434c17601b19cbc (\n    // applies apis to rtr\n    def addToInst(object doc, object rtrInst) (\n      local mods @= rtrInst.modules.getValues()\n      for i mods.len (\n        addToMod(doc, mods[i])\n      )\n    )\n    \n    def addToMod(object doc, object mod) (\n      void rtr.apis.rwl.addToMod(doc, mod)\n      void rtr.apis.browser.addToMod(doc, mod)\n    )\n  )\n  return __imports__60f47f43e26f20419434c17601b19cbc\ncase \"./src/rtr/instruction.osl\"\n  class __imports__63f619ecaeba64e54adfad70c460fe06 (\n    // program flow\n    def label(string name) (\n      return { kind: \"label\", name }\n    )\n    def jump(string label) (\n      return { kind: \"jump\", label }\n    )\n    def jumpIf(string label) (\n      return { kind: \"jumpIf\", label }\n    )\n    def jumpNotIf(string label) (\n      return { kind: \"jumpNotIf\", label }\n    )\n    \n    // operations\n    def callOp(number amount) (\n      return { kind: \"call\", args: amount }\n    )\n    def unary(string op) (\n      return { kind: \"unary\", op }\n    )\n    def binary(string op) (\n      return { kind: \"binary\", op }\n    )\n    def prop() (\n      return { kind: \"prop\" }\n    )\n    def len() (\n      return { kind: \"len\" }\n    )\n    \n    // values\n    def null() (\n      return { kind: \"null\" }\n    )\n    def str(string data) (\n      return { kind: \"str\", data }\n    )\n    def num(number data) (\n      return { kind: \"num\", data }\n    )\n    def bool(boolean data) (\n      return { kind: \"bool\", data }\n    )\n    def func(array body, array args) (\n      return { kind: \"func\", body, args }\n    )\n    def arr(number elems) (\n      return { kind: \"arr\", elems }\n    )\n    def obj(array keys) (\n      return { kind: \"obj\", keys }\n    )\n    def color(string data) (\n      return { kind: \"color\", data }\n    )\n    \n    // scope\n    def get(string name) (\n      return { kind: \"get\", name }\n    )\n    def decl(string name) (\n      return { kind: \"decl\", name }\n    )\n    def newScope() (\n      return { kind: \"newScope\" }\n    )\n    def popScope() (\n      return { kind: \"popScope\" }\n    )\n    \n    // assignments\n    def asivar(string name, op) (\n      return { kind: \"asivar\", name, op }\n    )\n    def asiprop(op) (\n      return { kind: \"asiprop\", op }\n    )\n    \n    // stack\n    def pop() (\n      return { kind: \"pop\" }\n    )\n    def dupe(number i) (\n      return { kind: \"dupe\", i }\n    )\n  )\n  return __imports__63f619ecaeba64e54adfad70c460fe06\ncase \"./src/rtr/compiler.osl\"\n  class __imports__bf40e68b061a1d99656fd4525ccf9d7b (\n    lbli = 0\n    \n    def getLabelName() (\n      self.lbli ++\n      return self.lbli.toStr()\n    )\n    \n    def compileBlock(object block) (\n      local instructions @= []\n      //log \"blk\" block\n      for i block.elements.len (\n        local out @= compileStatement(block.elements[i])\n        if typeof(out) != \"array\" and out.isError (\n          return out\n        )\n        \n        instructions ++= out\n      )\n      return instructions\n    )\n    \n    def compileStatement(object statement) (\n      //log \"stat\" statement\n      switch statement.kind (\n        case \"expression\"\n          local out @= compileExpression(statement.expr)\n          if typeof(out) != \"array\" and out.isError (\n            return out\n          )\n          \n          out += rtr.instruction.pop()\n          return out\n        case \"block\"\n          local body @= compileBlock(statement.body)\n          if typeof(body) != \"array\" and body.isError (\n            return body\n          )\n          \n          local out @= []\n          \n          out += rtr.instruction.newScope()\n          out ++= body\n          out += rtr.instruction.popScope()\n          \n          return out\n        \n        case \"branch\"\n          local out @= []\n          local hasElse = statement.elifs.len > 0 or statement.elseBody != null\n          \n          local endLbl = getLabelName()\n          local elseLbl = hasElse ? getLabelName() endLbl\n          \n          local cond @= compileExpression(statement.cond)\n          if typeof(cond) != \"array\" and cond.isError (\n            return cond\n          )\n          out ++= cond\n          out += rtr.instruction.jumpNotIf(elseLbl)\n          local body @= compileStatement(statement.body)\n          if typeof(body) != \"array\" and body.isError (\n            return body\n          )\n          out ++= body\n          if hasElse (\n            out += rtr.instruction.jump(endLbl)\n          )\n          \n          for i statement.elifs.len (\n            local elif @= statement.elifs[i]\n            local isLast = i == statement.elifs.len and statement.elseBody == null\n            out += rtr.instruction.label(elseLbl)\n            elseLbl = isLast ? endLbl getLabelName()\n            \n            local cond @= compileExpression(elif.cond)\n            if typeof(cond) != \"array\" and cond.isError (\n              return cond\n            )\n            out ++= cond\n            out += rtr.instruction.jumpNotIf(elseLbl)\n            local body @= compileStatement(elif.body)\n            if typeof(body) != \"array\" and body.isError (\n              return body\n            )\n            out ++= body\n            if !(i == statement.elifs.len and statement.elseBody == null) (\n              out += rtr.instruction.jump(endLbl)\n            )\n          )\n          \n          if statement.elseBody != null (\n            out += rtr.instruction.label(elseLbl)\n            local body @= compileStatement(statement.elseBody)\n            if typeof(body) != \"array\" and body.isError (\n              return body\n            )\n            out ++= body\n          )\n          out += rtr.instruction.label(endLbl)\n          return out\n        \n        case \"while\"\n          local out @= []\n          \n          local startLbl @= getLabelName()\n          local endLbl @= getLabelName()\n          \n          out += rtr.instruction.label(startLbl)\n          local cond @= compileExpression(statement.cond)\n          if typeof(cond) != \"array\" and cond.isError (\n            return cond\n          )\n          out ++= cond\n          out += rtr.instruction.jumpNotIf(endLbl)\n          \n          local body @= compileStatement(statement.body)\n          if typeof(body) != \"array\" and body.isError (\n            return body\n          )\n          out ++= body\n          \n          out += rtr.instruction.jump(startLbl)\n          out += rtr.instruction.label(endLbl)\n          return out\n        case \"until\"\n          local out @= []\n          \n          local startLbl @= getLabelName()\n          local endLbl @= getLabelName()\n          \n          out += rtr.instruction.label(startLbl)\n          local cond @= compileExpression(statement.cond)\n          if typeof(cond) != \"array\" and cond.isError (\n            return cond\n          )\n          out ++= cond\n          out += rtr.instruction.jumpIf(endLbl)\n          \n          local body @= compileStatement(statement.body)\n          if typeof(body) != \"array\" and body.isError (\n            return body\n          )\n          out ++= body\n          \n          out += rtr.instruction.jump(startLbl)\n          out += rtr.instruction.label(endLbl)\n          return out\n        case \"repeat\"\n          local out @= []\n          \n          local startLbl @= getLabelName()\n          local endLbl @= getLabelName()\n          \n          out += rtr.instruction.num(1)\n          out += rtr.instruction.label(startLbl)\n          out += rtr.instruction.dupe(-1)\n          local amt @= compileExpression(statement.amount)\n          if typeof(amt) != \"array\" and amt.isError (\n            return amt\n          )\n          out ++= amt\n          out += rtr.instruction.binary(\">\")\n          out += rtr.instruction.jumpIf(endLbl)\n          \n          out ++= compileStatement(statement.body)\n          \n          out += rtr.instruction.num(1)\n          out += rtr.instruction.binary(\"+\")\n          out += rtr.instruction.jump(startLbl)\n          out += rtr.instruction.label(endLbl)\n          out += rtr.instruction.pop()\n          return out\n        case \"for\"\n          local out @= []\n          \n          local startLbl @= getLabelName()\n          local endLbl @= getLabelName()\n          local arr @= compileExpression(statement.arr)\n          if typeof(arr) != \"array\" and arr.isError (\n            return arr\n          )\n          out ++= arr\n          out += rtr.instruction.num(0)\n          out += rtr.instruction.label(startLbl)\n          out += rtr.instruction.dupe(-2)\n          out += rtr.instruction.len()\n          out += rtr.instruction.dupe(-2)\n          out += rtr.instruction.binary(\"<=\")\n          out += rtr.instruction.jumpIf(endLbl)\n          out += rtr.instruction.dupe(-2)\n          out += rtr.instruction.dupe(-2)\n          out += rtr.instruction.prop()\n          out += rtr.instruction.newScope()\n          out += rtr.instruction.decl(statement.var)\n          out += rtr.instruction.pop()\n          \n          out ++= compileStatement(statement.body)\n          \n          out += rtr.instruction.popScope()\n          out += rtr.instruction.num(1)\n          out += rtr.instruction.binary(\"+\")\n          out += rtr.instruction.jump(startLbl)\n          out += rtr.instruction.label(endLbl)\n          out += rtr.instruction.pop()\n          out += rtr.instruction.pop()\n          return out\n        \n        default\n          return rtr.error.Error(\"UnknownStatementKind\", { kind: statement.kind })\n      )\n      \n      return []\n    )\n    \n    def compileExpression(object expression) (\n      //log \"expr\" expression\n      switch expression.kind (\n        case \"call\"\n          local func @= compileExpression(expression.func)\n          if typeof(func) != \"array\" and func.isError (\n            return func\n          )\n          \n          local args @= []\n          for i expression.args.len (\n            local out @= compileExpression(expression.args[i])\n            if typeof(out) != \"array\" and out.isError (\n              return out\n            )\n            \n            args ++= out\n          )\n          local out @= []\n          out ++= func\n          out ++= args\n          out += rtr.instruction.callOp(expression.args.len)\n          return out\n        case \"decl\"\n          local val @= compileExpression(expression.val)\n          if typeof(val) != \"array\" and val.isError (\n            return val\n          )\n          \n          local out @= val\n          out += rtr.instruction.decl(expression.tar)\n          return out\n        case \"asi\"\n          local val @= compileExpression(expression.val)\n          if typeof(val) != \"array\" and val.isError (\n            return val\n          )\n          local out @= val\n          switch expression.tar.kind (\n            case \"var\"\n              void out.append(rtr.instruction.asivar(expression.tar.name, expression.op))\n              return out\n            case \"prop\"\n              out ++= compileExpression(expression.tar.obj)\n              if typeof(expression.tar.key) == \"string\" (\n                out += rtr.instruction.str(expression.tar.key)\n              ) else (\n                out ++= compileExpression(expression.tar.key)\n              )\n              void out.append(rtr.instruction.asiprop(expression.op))\n              return out\n          )\n          \n          return [rtr.instruction.null()]\n        case \"unary\"\n          local val @= compileExpression(expression.expr)\n          \n          local out @= []\n          out ++= val\n          out += rtr.instruction.unary(expression.type)\n          \n          return out\n        case \"binary\"\n          local left @= compileExpression(expression.left)\n          if typeof(left) != \"array\" and left.isError (\n            return left\n          )\n          local right @= compileExpression(expression.right)\n          if typeof(right) != \"array\" and right.isError (\n            return right\n          )\n          \n          local out @= []\n          out ++= left\n          out ++= right\n          out += rtr.instruction.binary(expression.op)\n          \n          return out\n        case \"var\"\n          if [\"true\",\"false\"].contains(expression.name) (\n            return [rtr.instruction.bool(expression.name == \"true\")]\n          )\n          return [rtr.instruction.get(expression.name)]\n        case \"prop\"\n          local out @= []\n          out ++= compileExpression(expression.obj)\n          if typeof(expression.key) == \"string\" (\n            out += rtr.instruction.str(expression.key)\n          ) else (\n            out ++= compileExpression(expression.key)\n          )\n          out += rtr.instruction.prop()\n          return out\n        \n        case \"str\"\n          return [rtr.instruction.str(expression.val)]\n        case \"num\"\n          return [rtr.instruction.num(expression.val)]\n        case \"func\"\n          return [rtr.instruction.func(compileStatement(expression.body), expression.args)]\n        case \"arr\"\n          local out @= []\n          for i expression.elems.len (\n            out ++= compileExpression(expression.elems[i])\n          )\n          out += rtr.instruction.arr(expression.elems.len)\n          return out\n        case \"obj\"\n          local out @= []\n          local keys @= []\n          for i expression.pairs.len (\n            out ++= compileExpression(expression.pairs[i].value)\n            void keys.append(expression.pairs[i].name)\n          )\n          out += rtr.instruction.obj(keys)\n          return out\n        case \"color\"\n          return [rtr.instruction.color(expression.val)]\n        \n        default\n          log expression\n          return rtr.error.Error(\"UnknownExpressionKind\", { kind: expression.kind })\n      )\n      \n      return [rtr.instruction.null()]\n    )\n  )\n  return __imports__bf40e68b061a1d99656fd4525ccf9d7b\ncase \"./src/rtr/value.osl\"\n  class __imports__b2506e9c8a1f71d53780de64c11f25a1 (\n    class RTRValue (\n      def callFunc() (\n        throw \"cannot call\" + self.stringify(true) + \"as function\"\n      )\n    \n      def getRtrType() (\n        throw self.name + \"has not implemented getRtrType()\"\n        return rtr.value.RTRTypeValue({\n          name: \"?\"\n        })\n      )\n    \n      def stringify() (\n        return \"<\" ++ self.getRtrType().getName() ++ \">\"\n      )\n      def numbify() (\n        return NaN\n      )\n      def boolify() (\n        return true\n      )\n      def arrify() (\n        return []\n      )\n      def length() (\n        return 0\n      )\n      def getItem(key) (\n        return null\n      )\n      def setItem(key, value) (\n        throw \"cannot set items on\" + self.stringify(true)\n      )\n      def keys() (\n        return []\n      )\n      def values() (\n        return []\n      )\n      def has(key) (\n        return false\n      )\n      def isEqual(other) (\n        return self.getRtrType().isEqual(other.getRtrType())\n      )\n    )\n    \n    class RTRTypeValue (\n      def init(object data) (\n        self.data @= data\n      )\n      \n      def stringify() (\n        return self.getName()\n      )\n      def getName() (\n        if self.data.name != null (\n          return self.data.name\n        )\n        return \"?\"\n      )\n      def isEqual(object other) (\n        return self.data.name == other.data.name\n      )\n    )\n    \n    class RTRLiteralValue extends RTRValue (\n      boolean isLiteral = true\n    )\n    \n    class RTRStrValue extends RTRLiteralValue (\n      def init(string value) (\n        self.value @= value\n      )\n      \n      def getRtrType() (\n        return rtr.value.RTRTypeValue({\n          name: \"str\"\n        })\n      )\n      \n      def stringify(format) (\n        return format ? self.value.JsonStringify() self.value\n      )\n      def numbify() (\n        return self.value.toNum()\n      )\n      def boolify() (\n        return self.value.len > 0\n      )\n      def arrify() (\n        return self.value.split(\"\").map(e -> rtr.value.RTRStrValue(e))\n      )\n      def length() (\n        return self.value.len\n      )\n      def getItem(index) (\n        return rtr.value.RTRStrValue(self.value[index.numbify() + 1])\n      )\n      def isEqual(other) (\n        return self.getRtrType().isEqual(other.getRtrType()) and self.value === other.value\n      )\n    )\n    \n    class RTRNumValue extends RTRLiteralValue (\n      def init(number value) (\n        self.value @= value\n      )\n      \n      def getRtrType() (\n        return rtr.value.RTRTypeValue({\n          name: \"num\"\n        })\n      )\n      \n      def stringify() (\n        return self.value.toStr()\n      )\n      def numbify() (\n        return self.value\n      )\n      def boolify() (\n        return self.value > 0\n      )\n      def arrify() (\n        return self.value.toStr().split(\"\").map(e -> rtr.value.RTRStrValue(e))\n      )\n      def length() (\n        return self.value.toStr().length\n      )\n      def getItem(index) (\n        return self.value.toStr()[index.numbify() + 1]\n      )\n      def isEqual(other) (\n        return self.getRtrType().isEqual(other.getRtrType()) and self.value === other.value\n      )\n    )\n    \n    class RTRBoolValue extends RTRLiteralValue (\n      def init(boolean value) (\n        self.value @= value\n      )\n      \n      def getRtrType() (\n        return rtr.value.RTRTypeValue({\n          name: \"bool\"\n        })\n      )\n      \n      def stringify() (\n        return self.value.toStr()\n      )\n      def numbify() (\n        return self.value.toNum()\n      )\n      def boolify() (\n        return self.value\n      )\n      def isEqual(other) (\n        return self.getRtrType().isEqual(other.getRtrType()) and self.value === other.value\n      )\n    )\n    \n    class RTRColorValue extends RTRLiteralValue (\n      def init(string value) (\n        self.value @= value\n      )\n      \n      def getRtrType() (\n        return rtr.value.RTRTypeValue({\n          name: \"color\"\n        })\n      )\n      \n      def stringify() (\n        return self.value.toStr()\n      )\n      def boolify() (\n        return !!self.value\n      )\n      def isEqual(other) (\n        return self.getRtrType().isEqual(other.getRtrType()) and self.value === other.value\n      )\n    )\n    \n    class RTRFuncValue extends RTRValue (\n      def getRtrType() (\n        return rtr.value.RTRTypeValue({\n          name: \"func\"\n        })\n      )\n    )\n    \n    class RTROslFuncValue extends RTRFuncValue (\n      def init(func, extra) (\n        self.func @= func\n        self.extra @= extra\n      )\n      \n      def callFunc(object inst, array args) (\n        return self.func(args, inst, extra) ?? rtr.value.RTRNullValue()\n      )\n    )\n    class RTRAstFuncValue extends RTRFuncValue (\n      def init(array args, object body) (\n        self.args @= args\n        self.body @= body\n      )\n      \n      def callFunc(object inst, array args) (\n        local s @= {}\n        for i self.args.len (\n          local a @= self.args[i]\n          local v @= args[i] ?? rtr.value.RTRNullValue()\n          s[a.name] @= [v, {}]\n        )\n        \n        void inst.newScope(s)\n        void inst.declScopeVar(\"@return\", 0)\n        \n        local exprOut @= inst.runStatement(self.body)\n        \n        local ret @= inst.getScopeVar(\"@return\") ?? 0\n        if ret == 0 (\n          ret @= exprOut\n        )\n        \n        void inst.popScope()\n        \n        return ret\n      )\n    )\n    class RTRBytecodeFuncValue extends RTRFuncValue (\n      def init(array args, array body) (\n        self.args @= args\n        self.body @= body\n      )\n      \n      def callFunc(object inst, array args) (\n        local s @= {}\n        for i self.args.len (\n          local a @= self.args[i]\n          local v @= args[i] ?? rtr.value.RTRNullValue()\n          s[a.name] @= [v, {}]\n        )\n        \n        void inst.newScope(s)\n        \n        local exprOut @= inst.runInstructions(self.body)\n        \n        void inst.popScope()\n        \n        return exprOut\n      )\n    )\n    \n    class RTRNullValue extends RTRValue (\n      def getRtrType() (\n        return rtr.value.RTRTypeValue({\n          name: \"null\"\n        })\n      )\n      \n      def boolify() (\n        return false\n      )\n      def isEqual(other) (\n        return self.getRtrType().isEqual(other.getRtrType()) and self.value === other.value\n      )\n    )\n    \n    class RTRArrValue extends RTRValue (\n      def init(array elements) (\n        self.elements @= elements\n      )\n      \n      def getRtrType() (\n        return rtr.value.RTRTypeValue({\n          name: \"arr\"\n        })\n      )\n      \n      def stringify() (\n        local el @= self.elements.map(e -> e.stringify(true))\n        return \"[\" ++ el.join(\", \") ++ \"]\"\n      )\n      def boolify() (\n        return self.elements.len > 0\n      )\n      def arrify() (\n        return self.elements\n      )\n      def length() (\n        return self.elements.len\n      )\n      def keys() (\n        local arr2 @= []\n        for i self.elements.len (\n          void arr2.append(i - 1)\n        )\n        return arr2\n      )\n      def values() (\n        return self.elements\n      )\n      def getItem(index) (\n        return self.elements[index.numbify() + 1]\n      )\n      // setItem\n    )\n    \n    class RTRObjValue extends RTRValue (\n      def init(object value) (\n        self.value @= value\n      )\n      \n      def getRtrType() (\n        return rtr.value.RTRTypeValue({\n          name: \"obj\"\n        })\n      )\n      \n      def stringify() (\n        local el @= self.value.getEntries().map(e -> e[1] ++ \":\" + e[2].stringify(true))\n        return \"{\" ++ el.join(\", \") ++ \"}\"\n      )\n      def boolify() (\n        return self.value.getKeys().len > 0\n      )\n      def arrify() (\n        return self.value.getKeys().map(e -> rtr.value.RTRStrValue(e))\n      )\n      def length() (\n        return self.value.getKeys().len\n      )\n      def keys() (\n        return self.value.getKeys()\n      )\n      def values() (\n        return self.value.getValues()\n      )\n      def has(key) (\n        return self.value.getKeys().contains(key)\n      )\n      def getItem(key) (\n        return self.value[key.stringify()]\n      )\n      def setItem(key, value) (\n        self.value[key.stringify()] @= value\n      )\n    )\n  )\n  return __imports__b2506e9c8a1f71d53780de64c11f25a1\ncase \"./src/rtr/error.osl\"\n  class __imports__a51b04c580d521af176787ba84843c9a (\n    object Errors = {\n      CannotAssign: def(data) -> (\n        return \"cannot assign to\" + data.kind\n      ),\n    \n      // instructions\n      UnknownInstructionKind: def(data) -> (\n        return \"unknown instruction kind:\" + data.kind\n      ),\n      \n      // compiler\n      UnknownStatementKind: def(data) -> (\n        return \"unknown statement kind:\" + data.kind\n      ),\n      UnknownExpressionKind: def(data) -> (\n        return \"unknown expression kind:\" + data.kind\n      )\n    }\n    \n    class Error (\n      boolean isError = true\n      \n      def init(string type, object data) (\n        self.type = type\n        self.data @= data\n        \n        local err @= rtr.error.Errors[type]\n        if err == null (\n          self.type = \"UnknownErrorType\"\n          self.txt = \"unknown error type\" + type\n          return\n        )\n        self.txt = err(data)\n      )\n      \n      def stringify() (\n        return \"Error<\" ++ self.type ++ \">:\\n\" ++ self.txt.split(\"\\n\").map(l -> \"    \" ++ l).join(\"\\n\")\n      )\n    )\n  )\n  return __imports__a51b04c580d521af176787ba84843c9a\ncase \"./src/rtr/ast.osl\"\n  class __imports__2691a00e099698fa56c4748f2551eb65 (\n    class Parser (\n      def init(string text, scriptLocation) (\n        self.scriptLocation @= scriptLocation\n        void self.tokenise(text)\n      )\n      \n      def parse() (\n        self.pointer = 1\n        log self\n        local out @= self.blockContent(true)\n        \n        if !self.atEnd() (\n          throw \"unexpected token\" + self.peek()\n        )\n        \n        return { elements: out }\n      )\n      \n      def peek(amount) (\n        amount ??= 1\n        return self.tokens[self.pointer + amount - 1]\n      )\n      def consume() (\n        local tkn = self.peek()\n        self.pointer ++\n        return tkn\n      )\n      def consumeWhitespace() (\n        while self.peek().match(\"/^\\\\s$/\") != null (\n          void self.consume()\n        )\n      )\n      def atEnd() (\n        return self.pointer >= self.tokens.len\n      )\n      def expect(string token) (\n        local tkn @= self.consume()\n        if tkn != token (\n          throw \"expected '\" ++ token ++ \"' got '\" ++ tkn ++ \"'\"\n        )\n        return tkn\n      )\n      def expects(array tokens) (\n        local tkn @= self.consume()\n        if !tokens.contains(tkn) (\n          throw \"expected '\" ++ tokens.join(\" or \") ++ \"' got '\" ++ tkn ++ \"'\"\n        )\n        return tkn\n      )\n      def expectText() (\n        local tkn @= self.consume()\n        if !tkn.match(\"/^[a-zA-Z_0-9]+$/\") (\n          throw \"identifier must consist of letters or _\"\n        )\n        return tkn\n      )\n      def getPos() (\n        local ln = 1\n        local col = 0\n        local char = 0\n        local i = self.pointer\n        for t self.pointer (\n          col ++\n          char += self.tokens[t].len\n          if self.tokens[t] == \"\\n\" (\n            ln ++\n            col = 0\n            char = 0\n          )\n        )\n        return { ln, col, char, i, loc: self.scriptLocation }\n      )\n      \n      def tokenise(string text) (\n        self.tokens @= []\n        local splitChars @= [\n          \"(\",\")\",\n          \"[\",\"]\",\n          \"{\",\"}\",\n          \",\",\";\",\":\",\"=\",\".\",\"#\",\n          \"+\",\"-\",\"*\",\"/\",\"%\",\"^\",\n          \"\\\\\",\n          \"'\",\"\\\"\",\"`\",\n          \" \",\"\\n\",\n          \"!\",\"?\"\n        ]\n        local buf = \"\"\n        for i text.len (\n          if splitChars.contains(text[i]) (\n            if buf.len > 0 (\n              void self.tokens.append(buf)\n            )\n            void self.tokens.append(text[i])\n            buf = \"\"\n          ) else (\n            buf ++= text[i]\n          )\n        )\n        if buf.len > 0 (\n          self.tokens.append(buf)\n        )\n      )\n      \n      // statements\n      def blockContent(top) (\n        local statements @= []\n        local end = peek() == \"}\" or self.atEnd()\n        while !end (\n          if top (\n            local out @= self.topLevelStatement()\n          ) else (\n            local out @= self.statement()\n          )\n          if out != null (\n            void statements.append(out)\n          )\n          void self.consumeWhitespace()\n          if self.peek() == \";\" (\n            void self.consume()\n          )\n          if self.peek() == \"}\" or self.atEnd() (\n            end = true\n          )\n        )\n        return statements\n      )\n      \n      def topLevelStatement() (\n        void self.consumeWhitespace()\n        \n        if self.peek() == \"event\" (\n          return self.event()\n        )\n        \n        void self.consumeWhitespace()\n        \n        // global parsing\n        local ptr = self.pointer\n        \n        local start @= self.getPos()\n        local name = self.consume()\n        if name.match(\"/^[a-zA-Z_0-9]+$/\") != null (\n          void self.consumeWhitespace()\n          if self.peek() == \":\" (\n            void self.consume()\n            void self.expect(\"=\")\n            void self.consumeWhitespace()\n            local expr @= self.expression()\n            void self.expect(\";\")\n            return {\n              kind: \"global\",\n              name,\n              val: expr,\n              auto: true,\n              start, end: self.getPos()\n            }\n          )\n          if self.peek() == \"=\" (\n            void self.consume()\n            local expr @= self.expression()\n            void self.expect(\";\")\n            return {\n              kind: \"global\",\n              name,\n              val: expr,\n              start, end: self.getPos()\n            }\n          )\n        )\n        \n        self.pointer = ptr\n        \n        void self.consumeWhitespace()\n        \n        throw \"unexpected token '\" ++ self.peek() ++ \"'\"\n      )\n      \n      def event() (\n        local start @= self.getPos()\n        void self.expect(\"event\")\n        void self.consumeWhitespace()\n        void self.expect(\"(\")\n        void self.consumeWhitespace()\n        local target @= self.eventTarget()\n        void self.consumeWhitespace()\n        void self.expect(\")\")\n        void self.consumeWhitespace()\n        local body @= self.block()\n        \n        return {\n          kind: \"event\",\n          target,\n          body,\n          start, end: self.getPos()\n        }\n      )\n      \n      def statement(noSemicolon) (\n        void self.consumeWhitespace()\n        \n        // statements\n        if self.peek() == \"{\" (\n          local start @= self.getPos()\n          local body @= self.block()\n          return {\n            kind: \"block\",\n            body,\n            start, end: self.getPos()\n          }\n        )\n        \n        if self.peek() == \"if\" (\n          local start @= self.getPos()\n          void self.consume()\n          void self.consumeWhitespace()\n          void self.expect(\"(\")\n          local ifCond @= self.expression()\n          void self.expect(\")\")\n          void self.consumeWhitespace()\n          local ifBody @= self.statement()\n          \n          local elifs @= []\n          \n          void self.consumeWhitespace()\n          while self.peek() == \"elif\" (\n            void self.consume()\n            void self.consumeWhitespace()\n            void self.expect(\"(\")\n            local elifCond @= self.expression()\n            void self.expect(\")\")\n            void self.consumeWhitespace()\n            local elifBody @= self.statement()\n            \n            void elifs.append({\n              cond: elifCond,\n              body: elifBody\n            })\n            void self.consumeWhitespace()\n          )\n          \n          local elseBody = null\n          void self.consumeWhitespace()\n          if self.peek() == \"else\" (\n            void self.consume()\n            void self.consumeWhitespace()\n            local elseBody @= self.statement()\n          )\n          \n          return {\n            kind: \"branch\",\n            cond: ifCond,\n            body: ifBody,\n            elifs,\n            elseBody,\n            start, end: self.getPos()\n          }\n        )\n        \n        if [\"while\",\"until\"].contains(self.peek()) (\n          local start @= self.getPos()\n          local kind @= self.consume()\n          void self.consumeWhitespace()\n          void self.expect(\"(\")\n          local cond @= self.expression()\n          void self.expect(\")\")\n          void self.consumeWhitespace()\n          local body @= self.statement()\n          \n          return {\n            kind,\n            cond,\n            body,\n            start, end: self.getPos()\n          }\n        )\n        \n        if self.peek() == \"repeat\" (\n          local start @= self.getPos()\n          void self.consume()\n          void self.consumeWhitespace()\n          void self.expect(\"(\")\n          local amount @= self.expression()\n          void self.expect(\")\")\n          void self.consumeWhitespace()\n          local body @= self.statement()\n          \n          return {\n            kind: \"repeat\",\n            amount,\n            body,\n            start, end: self.getPos()\n          }\n        )\n        \n        if self.peek() == \"for\" (\n          local start @= self.getPos()\n          void self.consume()\n          void self.consumeWhitespace()\n          void self.expect(\"(\")\n          local var @= self.expectText()\n          void self.consumeWhitespace()\n          void self.expect(\",\")\n          void self.consumeWhitespace()\n          local arr @= self.expression()\n          void self.expect(\")\")\n          void self.consumeWhitespace()\n          local body @= self.statement()\n          return {\n            kind: \"for\",\n            var,\n            arr,\n            body,\n            start, end: self.getPos()\n          }\n        )\n        \n        local expr @= self.expression()\n        if expr != null (\n          void self.consumeWhitespace()\n          if !noSemicolon (\n            void self.expect(\";\")\n          )\n          \n          return {\n            kind: \"expression\",\n            expr\n          }\n        ) else (\n          throw \"unexpected token '\" ++ self.peek() ++ \"'\"\n        )\n      )\n      \n      def block() (\n        local start @= self.getPos()\n        void self.expect(\"{\")\n        void self.consumeWhitespace()\n        local elements @= self.blockContent()\n        void self.consumeWhitespace()\n        void self.expect(\"}\")\n        return { elements, start, end: self.getPos() }\n      )\n      \n      // event targets\n      def eventTarget() (\n        local start @= self.getPos()\n        \n        local target @= self.target()\n        \n        void self.consumeWhitespace()\n        \n        if self.peek() == \":\" (\n          void self.consume()\n          local eventName = self.expectText()\n          return {\n            kind: \"property\",\n            target,\n            eventName,\n            start, end: self.getPos()\n          }\n        )\n        \n        self.pointer = start.i\n        \n        return {\n          kind: \"global\",\n          target: self.expectText(),\n          start, end: self.getPos()\n        }\n      )\n      \n      // targets\n      def target() (\n        local start @= self.getPos()\n        \n        if self.peek() == \"*\" (\n          void self.consume()\n          return {\n            kind: \"any\"\n          }\n        )\n        \n        local kind = \"element\"\n        \n        if self.peek() == \"#\" (\n          void self.consume()\n          void self.consumeWhitespace()\n          kind = \"id\"\n        )\n        \n        local name = self.expectText()\n        \n        return {\n          kind,\n          name\n        }\n      )\n      \n      // expressions\n      def expression() (\n        return self.declare()\n      )\n      \n      def declare() (\n        if self.peek().match(\"/^[a-zA-Z_]\\\\w*$/\") != null (\n          local start @= self.getPos()\n          local ptr = self.pointer\n          local tar = self.consume()\n          void self.consumeWhitespace()\n          if self.peek() == \":\" and self.peek(2) == \"=\" (\n            void self.consume()\n            void self.consume()\n            void self.consumeWhitespace()\n            \n            local val @= self.expression()\n            \n            return {\n              kind: \"decl\",\n              tar,\n              val,\n              start, end: self.getPos()\n            }\n          )\n          self.pointer = ptr\n        )\n        \n        return self.assignment()\n      )\n      \n      def assignment() (\n        local start @= self.getPos()\n        local expr @= self.equality()\n        void self.consumeWhitespace()\n        \n        local op = null\n        \n        if self.peek() ++ self.peek(2) == \"??\" and self.peek(3) == \"=\" (\n          op = self.peek() ++ self.peek(2)\n        )\n        \n        if self.peek(2) == \"=\" and [\"+\",\"-\",\"*\",\"/\",\"%\",\"^\"].contains(self.peek()) (\n          op = self.peek()\n        )\n        \n        if op != null or self.peek() == \"=\" (\n          if op != null (\n            loop op.len (\n              void self.consume()\n            )\n          )\n          void self.consume()\n          void self.consumeWhitespace()\n          \n          local val @= self.expression()\n          \n          return {\n            kind: \"asi\",\n            op,\n            tar: expr,\n            val,\n            start, end: self.getPos()\n          }\n        )\n        \n        return expr\n      )\n      \n      def equality() (\n        local expr @= self.comparison()\n        void self.consumeWhitespace()\n        \n        while [\"==\",\"!=\"].contains(self.peek() ++ self.peek(2)) (\n          local op @= self.consume() ++ self.consume()\n          local right @= self.comparison()\n          expr @= {\n            kind: \"binary\",\n            op,\n            left: expr,\n            right\n          }\n        )\n        \n        return expr\n      )\n      \n      def comparison() (\n        local expr @= self.term()\n        \n        local end = false\n        while !end (\n          void self.consumeWhitespace()\n          if [\">\",\"<\"].contains(self.peek()) (\n            local op @= self.consume()\n            local isEql = self.peek() == \"=\"\n            if isEql (\n              op ++= self.consume()\n            )\n            \n            local right @= self.factor()\n            \n            expr @= {\n              kind: \"binary\",\n              op,\n              left: expr,\n              right\n            }\n          ) else (\n            end = true\n          )\n        )\n        \n        return expr\n      )\n      \n      def term() (\n        local expr @= self.factor()\n        void self.consumeWhitespace()\n        \n        while [\"+\",\"-\"].contains(self.peek()) and self.peek(2) != \"=\" (\n          local op @= self.consume()\n          local right @= self.factor()\n          expr @= {\n            kind: \"binary\",\n            op,\n            left: expr,\n            right\n          }\n          void self.consumeWhitespace()\n        )\n        \n        return expr\n      )\n      \n      def factor() (\n        local expr @= self.otherBinary()\n        void self.consumeWhitespace()\n        \n        while [\"*\",\"/\"].contains(self.peek()) and self.peek(2) != \"=\" (\n          local op @= self.consume()\n          local right @= self.otherBinary()\n          expr @= {\n            kind: \"binary\",\n            op,\n            left: expr,\n            right\n          }\n          void self.consumeWhitespace()\n        )\n        \n        return expr\n      )\n      \n      def otherBinary() (\n        local expr @= self.coalescence()\n        void self.consumeWhitespace()\n        \n        while [\"%\",\"^\"].contains(self.peek()) and self.peek(2) != \"=\" (\n          local op @= self.consume()\n          local right @= self.coalescence()\n          expr @= {\n            kind: \"binary\",\n            op,\n            left: expr,\n            right\n          }\n          void self.consumeWhitespace()\n        )\n        \n        return expr\n      )\n      \n      def coalescence() (\n        local expr @= self.unary()\n        void self.consumeWhitespace()\n        \n        while self.peek() ++ self.peek(2) == \"??\" and self.peek(3) != \"=\" (\n          local op @= self.consume() ++ self.consume()\n          local right @= self.unary()\n          expr @= {\n            kind: \"binary\",\n            op,\n            left: expr,\n            right\n          }\n          void self.consumeWhitespace()\n        )\n        \n        return expr\n      )\n      \n      def unary() (\n        if self.peek(2) != \"=\" (\n          switch self.peek() (\n            case \"-\"; case \"+\"; case \"!\"; case \"?\"\n              return {\n                kind: \"unary\",\n                type: self.consume(),\n                expr: self.callExpr()\n              }\n          )\n        )\n        \n        return self.callExpr()\n      )\n      \n      def callExpr() (\n        local start @= self.getPos()\n        local expr @= self.func()\n        \n        if self.peek() == \"(\" (\n          void self.consume()\n          \n          local args @= []\n          local end = self.peek() == \")\"\n          while !end (\n            local out @= self.expression()\n            if out != null (\n              void args.append(out)\n            )\n            void self.consumeWhitespace()\n            if self.peek() == \",\" (\n              void self.consume()\n            )\n            void self.consumeWhitespace()\n            if self.peek() == \")\" or self.atEnd() (\n              end = true\n            )\n          )\n          void self.expect(\")\")\n          \n          return {\n            kind: \"call\",\n            args,\n            func: expr,\n            start, end: self.getPos()\n          }\n        )\n        \n        return expr\n      )\n      \n      def func() (\n        local start @= self.getPos()\n        \n        local is = false\n        if self.peek() == \"(\" (\n          local end = false\n          local depth = 0\n          while !end (\n            local tkn @= self.consume()\n            if tkn == \"(\" (\n              depth ++\n            )\n            if tkn == \")\" (\n              depth --\n            )\n            \n            if tkn == \")\" and depth == 0 (\n              end = true\n              is = true\n            )\n            if self.atEnd() (\n              end = true\n            )\n          )\n        )\n        void self.consumeWhitespace()\n        if is and self.peek() == \"~\" (\n          self.pointer = start.i\n          \n          local args @= []\n          void self.consume()\n          void self.consumeWhitespace()\n          local end = self.peek() == \")\"\n          if self.peek() == \")\" (\n            void self.consume()\n          )\n          while !end (\n            local tkn @= self.expectText()\n            void args.append({\n              name: tkn\n            })\n            \n            void self.consumeWhitespace()\n            local ntkn = self.expects([\",\",\")\"])\n            void self.consumeWhitespace()\n            if ntkn == \")\" or self.atEnd() (\n              end = true\n            )\n          )\n          void self.consumeWhitespace()\n          void self.expect(\"~\")\n          void self.consumeWhitespace()\n          local body @= self.statement(true)\n          return {\n            kind: \"func\",\n            args,\n            body,\n            start, end: self.getPos()\n          }\n        )\n        self.pointer = start.i\n        \n        return self.objProperty()\n      )\n      \n      def objProperty() (\n        local expr @= self.primary()\n        void self.consumeWhitespace()\n        \n        while (self.peek() == \"[\" or self.peek() == \".\") and !self.atEnd() (\n          if self.peek() == \"[\" (\n            void self.consume()\n            local key @= self.expression()\n            void self.expect(\"]\")\n          ) else if self.peek() == \".\" (\n            void self.consume()\n            local key @= self.expectText()\n          ) else (\n            throw \"unexpected token '\" ++ self.peek() ++ \"'\"\n          )\n          expr @= {\n            kind: \"prop\",\n            obj: expr,\n            key\n          }\n          if self.peek() == \"(\" (\n            void self.consume()\n            \n            local args @= []\n            local end = self.peek() == \")\"\n            while !end (\n              local out @= self.expression()\n              if out != null (\n                void args.append(out)\n              )\n              void self.consumeWhitespace()\n              if self.peek() == \",\" (\n                void self.consume()\n              )\n              void self.consumeWhitespace()\n              if self.peek() == \")\" or self.atEnd() (\n                end = true\n              )\n            )\n            void self.expect(\")\")\n            \n            expr @= {\n              kind: \"call\",\n              args,\n              func: expr\n            }\n          )\n          void self.consumeWhitespace()\n        )\n        \n        return expr\n      )\n      \n      def primary() (\n        void self.consumeWhitespace()\n        \n        if self.peek() == \"(\" (\n          void self.consume()\n          local expr @= self.expression()\n          void self.expect(\")\")\n          return expr\n        )\n        \n        if self.peek() == \"[\" (\n          return self.arr()\n        )\n        \n        if self.peek() == \"{\" (\n          return self.obj()\n        )\n        \n        if self.peek() == \"#\" (\n          return self.color()\n        )\n        \n        if [\"'\",\"\\\"\",\"`\"].contains(self.peek()) (\n          return self.str()\n        )\n        \n        if self.peek().match(\"/^[0-9]+$/\") != null (\n          return self.num()\n        )\n        \n        if self.peek().match(\"/^[a-zA-Z_\\\\$][\\\\w\\\\s\\\\$]*$/\") != null (\n          local start @= self.getPos()\n          return {\n            kind: \"var\",\n            name: self.consume(),\n            start, end: self.getPos()\n          }\n        )\n        \n        throw \"unexpected token '\" ++ self.peek() ++ \"'\"\n      )\n      \n      def arr() (\n        void self.expect(\"[\")\n        void self.consumeWhitespace()\n        \n        local elems @= []\n        \n        local end = self.peek() == \"]\"\n        while !end (\n          local expr @= self.expression()\n          void elems.append(expr)\n          \n          void self.consumeWhitespace()\n          if self.peek() == \"]\" or self.atEnd() (\n            end = true\n          ) else (\n            void self.expect(\",\")\n          )\n          void self.consumeWhitespace()\n        )\n        \n        void self.expect(\"]\")\n        \n        return {\n          kind: \"arr\",\n          elems\n        }\n      )\n      \n      def obj() (\n        void self.expect(\"{\")\n        void self.consumeWhitespace()\n        \n        local pairs @= []\n        \n        local end = self.peek() == \"}\"\n        while !end (\n          void self.consumeWhitespace()\n          local name @= self.expectText()\n          void self.consumeWhitespace()\n          void self.expect(\":\")\n          void self.consumeWhitespace()\n          local value @= self.expression()\n          \n          void pairs.append({ name, value })\n          \n          void self.consumeWhitespace()\n          if self.peek() == \"}\" (\n            end = true\n          ) else (\n            void self.expect(\",\")\n          )\n        )\n        void self.expect(\"}\")\n        \n        return {\n          kind: \"obj\",\n          pairs\n        }\n      )\n      \n      def color() (\n        local start @= self.getPos()\n        void self.expect(\"#\")\n        local value = self.consume()\n        if ![3,6].contains(value.len) (\n          throw \"hex values can only be 3 or 6 characters long\"\n        )\n        return {\n          kind: \"color\",\n          val: \"#\" ++ value,\n          start, end: self.getPos()\n        }\n      )\n      \n      def str() (\n        local start @= self.getPos()\n        local q @= self.expects([\"'\",\"\\\"\",\"`\"])\n        local content = \"\"\n        local end = false\n        while (!end) (\n          local tkn @= self.peek()\n          if tkn == \"\\\\\" (\n            void self.consume()\n            local tkn = self.consume()\n            local char = tkn[1]\n            switch char (\n              case \"n\"\n                char = \"\\n\"\n                break\n            )\n            content ++= char ++ tkn.trim(2,-1)\n            continue\n          )\n          \n          if q == tkn (\n            end = true\n          ) else (\n            content ++= self.consume()\n          )\n          if self.atEnd() (\n            end = true\n          )\n        )\n        void self.expect(q)\n        return {\n          kind: \"str\",\n          val: content,\n          start, end: self.getPos()\n        }\n      )\n      \n      def num() (\n        if self.peek().match(\"/^[0-9]+$/\") == null (\n          throw \"unexpected token '\" ++ self.peek() ++ \"'\"\n        )\n        \n        local start @= self.getPos()\n        local val @= self.consume()\n        \n        if self.peek() == \".\" (\n          val ++= self.consume()\n          if self.peek().match(\"/^[0-9]+$/\") == null (\n            throw \"unexpected token '\" ++ self.peek() ++ \"'\"\n          )\n          val ++= self.consume()\n        )\n        \n        val @= val.toNum()\n        \n        return {\n          kind: \"num\",\n          val,\n          start, end: self.getPos()\n        }\n      )\n    )\n  )\n  return __imports__2691a00e099698fa56c4748f2551eb65\ncase \"./src/rtr/main.osl\"\n  class __imports__954b63a69b7120a02fa83923726ef587 (\n    class Module (\n      def init(object ast) (\n        void self.loadFromAst(ast)\n        void self.initScope()\n        void self.defScope()\n        \n        self.eventQueue @= []\n        self.initTopDone = false\n        \n        // only used in bytecode\n        self.returnVal = null\n      )\n      def loadFromAst(object ast) (\n        self.ast @= ast\n        \n        self.events @= []\n        self.eventList @= []\n        for i self.ast.elements.len (\n          local topLevel @= self.ast.elements[i]\n          if topLevel.kind == \"event\" (\n            if topLevel.target.kind == \"global\" (\n              if self.eventList.contains(topLevel.target.target) (\n                throw topLevel.target.target + \"event already exists on module\"\n              )\n              void self.eventList.append(topLevel.target.target)\n            )\n            void self.events.append([\n              topLevel.target,\n              topLevel\n            ])\n          )\n        )\n      )\n      def initTop() (\n        if self.initTopDone (\n          return\n        )\n        self.initTopDone = true\n        \n        self.ast @= ast\n        \n        void self.newScope({})\n        for i self.ast.elements.len (\n          local topLevel @= self.ast.elements[i]\n          if topLevel.kind == \"global\" (\n            local val @= self.runExpression(topLevel.val)\n            local meta = null\n            if topLevel.auto (\n              meta @= {\n                type: val.getRtrType()\n              }\n            )\n            void self.declScopeVar(topLevel.name, val, meta)\n          )\n        )\n      )\n      \n      def initScope() (\n        self.scope @= []\n      )\n      def newScope(object vars) (\n        void self.scope.append(vars)\n      )\n      def popScope() (\n        return self.scope.pop()\n      )\n      def defScope() (\n        // helper funcs\n        local cFunc @= def(name, content) -> (\n          void self.setScopeVar(name, rtr.value.RTROslFuncValue(content))\n        )\n        \n        void self.newScope({})\n        \n        void self.setScopeVar(\"true\", rtr.value.RTRBoolValue(true))\n        void self.setScopeVar(\"false\", rtr.value.RTRBoolValue(false))\n        \n        cFunc(\"log\", def(args, inst) -> (\n          local txt = args.map(a -> a.stringify()).join(\" \")\n          log txt\n          void inst.inst.console.append([\"log\", txt])\n        ))\n        cFunc(\"error\", def(args, inst) -> (\n          local txt = args.map(a -> a.stringify()).join(\" \")\n          void inst.inst.console.append([\"err\", txt])\n          throw txt\n        ))\n        cFunc(\"return\", def(args, inst) -> (\n          local val @= args[1]\n          val ??= rtr.value.RTRNullValue()\n          void inst.setScopeVar(\"@return\", val)\n          inst.returnVal @= val\n        ))\n        cFunc(\"typeof\", def(args) -> (\n          local val @= args[1] ?? rtr.value.RTRNullValue()\n          return val.getRtrType()\n        ))\n        cFunc(\"length\", def(args) -> (\n          return rtr.value.RTRNumValue(args[1].length())\n        ))\n        \n        // mathematical\n        cFunc(\"min\", def(args) -> (\n          local v = args[1].numbify()\n          for i args.len - 1 (\n            local a @= args[i + 1].numbify()\n            v = min(v, a)\n          )\n          return rtr.value.RTRNumValue(v)\n        ))\n        cFunc(\"max\", def(args) -> (\n          local v = args[1].numbify()\n          for i args.len - 1 (\n            local a @= args[i + 1].numbify()\n            v = max(v, a)\n          )\n          return rtr.value.RTRNumValue(v)\n        ))\n        \n        cFunc(\"abs\", def(args) -> (\n          return rtr.value.RTRNumValue(args[1].numbify().abs())\n        ))\n        cFunc(\"sqrt\", def(args) -> (\n          return rtr.value.RTRNumValue(args[1].numbify().sqrt())\n        ))\n        \n        cFunc(\"round\", def(args) -> (\n          return rtr.value.RTRNumValue(args[1].numbify().round())\n        ))\n        cFunc(\"floor\", def(args) -> (\n          return rtr.value.RTRNumValue(args[1].numbify().floor())\n        ))\n        cFunc(\"ceil\", def(args) -> (\n          return rtr.value.RTRNumValue(args[1].numbify().ceiling())\n        ))\n        \n        // string\n        cFunc(\"join\", def(args) -> (\n          local txt = \"\"\n          for i args.len (\n            txt ++= args[i].stringify()\n          )\n          return rtr.value.RTRStrValue(txt)\n        ))\n        cFunc(\"split\", def(args) -> (\n          return rtr.value.RTRArrValue(args[1]\n            .stringify()\n            .split(args[2].stringify())\n            .map(e -> rtr.value.RTRStrValue(e)))\n        ))\n        \n        cFunc(\"chr\", def(args) -> (\n          return rtr.value.RTRStrValue(args[1].numbify().chr())\n        ))\n        cFunc(\"ord\", def(args) -> (\n          return rtr.value.RTRNumValue(args[1].stringify().ord())\n        ))\n        \n        cFunc(\"toUpper\", def(args) -> (\n          return rtr.value.RTRStrValue(args[1].stringify().toUpper())\n        ))\n        cFunc(\"toLower\", def(args) -> (\n          return rtr.value.RTRStrValue(args[1].stringify().toLower())\n        ))\n        cFunc(\"toTitle\", def(args) -> (\n          return rtr.value.RTRStrValue(args[1].stringify().toTitle())\n        ))\n        \n        // array\n        cFunc(\"item\", def(args) -> (\n          return args[1].getItem(args[2])\n        ))\n        cFunc(\"range\", def(args) -> (\n          return rtr.value.RTRArrValue((args[1].numbify() to args[2].numbify()).map(e -> rtr.value.RTRNumValue(e)))\n        ))\n        \n        // object\n        cFunc(\"keys\", def(args) -> (\n          return rtr.value.RTRArrValue(args[1].keys().map(e -> rtr.value.RTRStrValue(e)))\n        ))\n        cFunc(\"values\", def(args) -> (\n          return rtr.value.RTRArrValue(args[1].values())\n        ))\n        cFunc(\"has\", def(args) -> (\n          return rtr.value.RTRBoolValue(args[1].has(args[2].stringify()))\n        ))\n        cFunc(\"obj\", def() -> (\n          return rtr.value.RTRObjValue({})\n        ))\n        \n        // logical\n        cFunc(\"all\", def(args) -> (\n          return rtr.value.RTRBoolValue(args.every(a -> a.boolify()))\n        ))\n        cFunc(\"any\", def(args) -> (\n          return rtr.value.RTRBoolValue(args.some(a -> a.boolify()))\n        ))\n        cFunc(\"not\", def(args) -> (\n          return rtr.value.RTRBoolValue(!args[1].boolify())\n        ))\n      )\n      def getScopeVarRaw(string key) (\n        for rawI self.scope.len (\n          local layer @= self.scope[self.scope.len - rawI + 1]\n          if layer[key] != null (\n            return layer[key]\n          )\n        )\n        return null\n      )\n      def getScopeVar(string key) (\n        return self.getScopeVarRaw(key)[1]\n      )\n      def getScopeVarMeta(string key) (\n        return self.getScopeVarRaw(key)[2]\n      )\n      def setScopeVar(string key, val, meta) (\n        meta ??= {}\n        for rawI self.scope.len (\n          local layer @= self.scope[self.scope.len - rawI + 1]\n          if layer[key] != null (\n            layer[key] @= [val, layer[key][2] ++ meta]\n            return\n          )\n        )\n        void self.declScopeVar(key, val, meta)\n      )\n      def declScopeVar(string key, val, meta) (\n        self.scope[self.scope.len][key] @= [val, meta]\n      )\n      \n      def findEligible(object target) (\n        local evs @= []\n        \n        for i self.events.len (\n          local ev @= self.events[i][2]\n          \n          if target.element != null (\n            if ev.target.kind == \"property\" and ev.target.eventName == target.name (\n              if ev.target.target.kind == \"id\" (\n                if ev.target.target.name == target.element.id (\n                  void evs.append(ev)\n                )\n              )\n            )\n          ) else if typeof(ev.target.target) == \"string\" (\n            if ev.target.target == target.name (\n              void evs.append(ev)\n            )\n          )\n        )\n        \n        return evs\n      )\n      \n      def runEvents(object target, object data) (\n        void self.eventQueue.append([\n          \"events\",\n          target,\n          data\n        ])\n      )\n      def runEvent(object target, object data) (\n        void self.eventQueue.append([\n          \"event\",\n          target,\n          data\n        ])\n      )\n      \n      def runEventQueue() (\n        for i self.eventQueue.len (\n          local ev @= self.eventQueue.shift()\n          \n          if ev[1] == \"events\" (\n            void self.runEventsRaw(ev[2], ev[3])\n          )\n          if ev[1] == \"event\" (\n            void self.runEventRaw(ev[2], ev[3])\n          )\n        )\n      )\n      \n      def runEventsRaw(object target, object data) (\n        local evs @= self.findEligible(target)\n        \n        void self.initTop()\n        for i evs.len (\n          void self.runBlock(evs[i].body)\n        )\n      )\n      def runEventRaw(object target, object data) (\n        local ev @= self.findEligible(target)[1]\n        \n        if ev == null (\n          return rtr.value.RTRNullValue()\n        )\n        \n        void self.initTop()\n        return self.runBlock(ev.body)\n      )\n      def runBlock(object block) (\n        if shared.config.browser.phosphorus.useCompiler and block.compile == null (\n          local start = performance\n          local compileOut @= rtr.compiler.compileBlock(block)\n          if typeof(compileOut) != \"array\" and compileOut.isError (\n            block.compile = false\n          ) else (\n            block.compile @= compileOut\n          )\n          self.inst.compiled ??= []\n          void self.inst.compiled.append({\n            body: compileOut,\n            start: block.start,\n            end: block.end,\n            ast: block,\n            time: start - performance\n          })\n        )\n        if block.compile != null (\n          return self.runInstructions(block.compile)\n        )\n        \n        local elements @= block.elements\n        local outVal @= rtr.value.RTRNullValue()\n        void self.newScope({})\n        for i elements.len (\n          local out @= self.runStatement(elements[i])\n          if self.getScopeVar(\"@return\") ?? 0 != 0 (\n            outVal @= self.getScopeVar(\"@return\")\n            break\n          )\n        )\n        void self.popScope()\n        return outVal\n      )\n      def runStatement(object statement) (\n        switch statement.kind (\n          case \"expression\"\n            return self.runExpression(statement.expr)\n          case \"block\"\n            return self.runBlock(statement.body)\n          \n          case \"branch\"\n            if self.runExpression(statement.cond).boolify() (\n              return self.runStatement(statement.body)\n            )\n            for i statement.elifs.len (\n              local elif @= statement.elifs[i]\n              if self.runExpression(elif.cond).boolify() (\n                return self.runStatement(elif.body)\n              )\n            )\n            if statement.elseBody != null (\n              return self.runStatement(statement.elseBody)\n            )\n            return rtr.value.RTRNullValue()\n          \n          case \"while\"\n            local iters = 0\n            while self.runExpression(statement.cond).boolify() and self.getScopeVar(\"@return\") ?? 0 == 0 and iters < 999999 (\n              void self.runStatement(statement.body)\n              iters ++\n            )\n            return rtr.value.RTRNullValue()\n          case \"until\"\n            local iters = 0\n            while !self.runExpression(statement.cond).boolify() and self.getScopeVar(\"@return\") ?? 0 == 0 and iters < 999999 (\n              void self.runStatement(statement.body)\n              iters ++\n            )\n            return rtr.value.RTRNullValue()\n          case \"repeat\"\n            loop self.runExpression(statement.amount).numbify() (\n              void self.runStatement(statement.body)\n            )\n            return rtr.value.RTRNullValue()\n          case \"for\"\n            local arr @= self.runExpression(statement.arr).arrify()\n            for i arr.len (\n              void self.newScope({})\n              void self.declScopeVar(statement.var, arr[i])\n              void self.runStatement(statement.body)\n              void self.popScope()\n            )\n            return rtr.value.RTRNullValue()\n          \n          default\n            throw \"unknown statement type\" + statement.kind\n        )\n      )\n      def runExpression(object expression) (\n        switch expression.kind (\n          case \"call\"\n            local func @= self.runExpression(expression.func)\n            local args @= []\n            for i expression.args.len (\n              void args.append(self.runExpression(expression.args[i]))\n            )\n            return func.callFunc(self, args) ?? rtr.value.RTRNullValue()\n          case \"decl\"\n            local val @= self.runExpression(expression.val)\n            \n            void self.declScopeVar(expression.tar, val, {\n              type: val.getRtrType()\n            })\n            \n            return val\n          case \"asi\"\n            local val @= self.runExpression(expression.val)\n            \n            local existingMeta = null\n            local existing = null\n            switch expression.tar.kind (\n              case \"var\"\n                existingMeta @= self.getScopeVarMeta(expression.tar.name)\n                existing @= self.getScopeVar(expression.tar.name)\n                break\n              case \"prop\"\n                existing @= self.runExpression(expression.tar)\n                break\n            )\n            \n            if expression.op != null (\n              val @= self.runBinary(existing, expression.op, val)\n            )\n            \n            switch expression.tar.kind (\n              case \"var\"\n                if existingMeta != null (\n                  local curType @= val.getRtrType()\n                  if existingMeta.type != null (\n                    if !existingMeta.type.isEqual(curType) (\n                      throw \"cannot assign\" + curType.stringify() + \"to\" + existingMeta.type.stringify() + \"variable\" \n                    )\n                  )\n                )\n                void self.setScopeVar(expression.tar.name, val)\n                break\n              case \"prop\"\n                local obj @= self.runExpression(expression.tar.obj)\n                local key @= expression.tar.key\n                if typeof(key) == \"string\" (\n                  key @= rtr.value.RTRStrValue(key)\n                ) else (\n                  key @= self.runExpression(key)\n                )\n                void obj.setItem(key, val)\n                break\n              default\n                throw \"cannot assign to\" + expression.tar.kind\n            )\n            \n            return val\n          case \"unary\"\n            local val @= self.runExpression(expression.expr)\n            return self.runUnary(expression.type, val)\n          case \"binary\"\n            local left @= self.runExpression(expression.left)\n            local right @= self.runExpression(expression.right)\n            return self.runBinary(left, expression.op, right)\n          \n          case \"var\"\n            local val @= self.getScopeVar(expression.name)\n            return val ?? rtr.value.RTRNullValue()\n          case \"prop\"\n            local obj @= self.runExpression(expression.obj)\n            local key @= expression.key\n            if typeof(key) == \"string\" (\n              key @= rtr.value.RTRStrValue(key)\n            ) else (\n              key @= self.runExpression(key)\n            )\n            return obj.getItem(key) ?? rtr.value.RTRNullValue()\n          \n          case \"str\"\n            return rtr.value.RTRStrValue(expression.val)\n          case \"num\"\n            return rtr.value.RTRNumValue(expression.val)\n          case \"func\"\n            return rtr.value.RTRAstFuncValue(expression.args, expression.body)\n          case \"arr\"\n            return rtr.value.RTRArrValue(expression.elems.map(e -> self.runExpression(e)))\n          case \"obj\"\n            local val @= {}\n            for i expression.pairs.len (\n              local pair @= expression.pairs[i]\n              val[pair.name] @= self.runExpression(pair.value)\n            )\n            return rtr.value.RTRObjValue(val)\n          case \"color\"\n            return rtr.value.RTRColorValue(expression.val)\n          \n          default\n            throw \"unknown expression type\" + expression.kind\n        )\n      )\n      def runUnary(string op, object val) (\n        switch op (\n          case \"-\"\n            return rtr.value.RTRNumValue(-val.numbify())\n          case \"+\"\n            return rtr.value.RTRNumValue(val.numbify())\n          case \"!\"\n            return rtr.value.RTRBoolValue(!val.boolify())\n          case \"?\"\n            return rtr.value.RTRBoolValue(val.boolify())\n        )\n        return rtr.value.RTRNullValue()\n      )\n      def runBinary(object left, string op, object right) (\n        local numT @= rtr.value.RTRNumValue.getRtrType()\n        switch op (\n          case \"+\"\n            if left.getRtrType().isEqual(numT) and right.getRtrType().isEqual(numT) (\n              return rtr.value.RTRNumValue(left.numbify() + right.numbify())\n            )\n            return rtr.value.RTRStrValue(left.stringify() ++ right.stringify())\n          case \"-\"\n            if left.getRtrType().isEqual(numT) and right.getRtrType().isEqual(numT) (\n              return rtr.value.RTRNumValue(left.numbify() - right.numbify())\n            )\n            return rtr.value.RTRNumValue(NaN)\n          case \"*\"\n            if left.getRtrType().isEqual(numT) and right.getRtrType().isEqual(numT) (\n              return rtr.value.RTRNumValue(left.numbify() * right.numbify())\n            )\n            return rtr.value.RTRNumValue(NaN)\n          case \"/\"\n            if left.getRtrType().isEqual(numT) and right.getRtrType().isEqual(numT) (\n              return rtr.value.RTRNumValue(left.numbify() / right.numbify())\n            )\n            return rtr.value.RTRNumValue(NaN)\n          case \"%\"\n            if left.getRtrType().isEqual(numT) and right.getRtrType().isEqual(numT) (\n              return rtr.value.RTRNumValue(left.numbify() % right.numbify())\n            )\n            return rtr.value.RTRNumValue(NaN)\n          case \"^\"\n            if left.getRtrType().isEqual(numT) and right.getRtrType().isEqual(numT) (\n              return rtr.value.RTRNumValue(left.numbify() ^ right.numbify())\n            )\n            return rtr.value.RTRNumValue(NaN)\n          \n          case \"==\"\n            return rtr.value.RTRBoolValue(left.isEqual(right))\n          case \"!=\"\n            return rtr.value.RTRBoolValue(left.isEqual(right))\n          \n          case \">\"\n            return rtr.value.RTRBoolValue(left.numbify() > right.numbify())\n          case \"<\"\n            return rtr.value.RTRBoolValue(left.numbify() < right.numbify())\n          case \">=\"\n            return rtr.value.RTRBoolValue(left.numbify() >= right.numbify())\n          case \"<=\"\n            return rtr.value.RTRBoolValue(left.numbify() <= right.numbify())\n        \n          case \"??\"\n            return left.getRtrType().data.name == \"null\" ? right left\n        )\n        \n        return rtr.value.RTRNullValue()\n      )\n      \n      def runInstructions(array instructions) (\n        self.stack ??= []\n        \n        local labels @= {}\n        \n        for i instructions.len (\n          local instruction @= instructions[i]\n          if instruction.kind == \"label\" (\n            labels[instruction.name] = i\n          )\n        )\n        \n        local i = 0\n        local iters = 0\n        while i < instructions.len and iters < 1000 (\n          i ++\n          iters ++\n          local instruction @= instructions[i]\n          //log i iters instruction self.stack.map(s -> s.stringify())\n          switch instruction.kind (\n            case \"label\"; break\n            case \"jump\"\n              i = labels[instruction.label] ?? i\n              break\n            case \"jumpIf\"\n              local val @= self.stack.pop() ?? rtr.value.RTRNullValue()\n              if val.boolify() (\n                i = labels[instruction.label] ?? i\n              )\n              break\n            case \"jumpNotIf\"\n              local val @= self.stack.pop() ?? rtr.value.RTRNullValue()\n              if !val.boolify() (\n                i = labels[instruction.label] ?? i\n              )\n              break\n            \n            case \"call\"\n              local args @= []\n              loop instruction.args (\n                void args.prepend(self.stack.pop() ?? rtr.value.RTRNullValue())\n              )\n              local func @= self.stack.pop() ?? rtr.value.RTRNullValue()\n              local out @= func.callFunc(self, args) ?? rtr.value.RTRNullValue()\n              if self.returnVal != null (\n                local out @= self.returnVal\n                self.returnVal = null\n                return out\n              )\n              void self.stack.append(out)\n              break\n            case \"unary\"\n              local val @= self.stack.pop() ?? rtr.value.RTRNullValue()\n              void self.stack.append(self.runUnary(instruction.op, val))\n              break\n            case \"binary\"\n              local right @= self.stack.pop() ?? rtr.value.RTRNullValue()\n              local left @= self.stack.pop() ?? rtr.value.RTRNullValue()\n              void self.stack.append(self.runBinary(left, instruction.op, right))\n              break\n            case \"prop\"\n              local key @= self.stack.pop() ?? rtr.value.RTRNullValue()\n              local obj @= self.stack.pop() ?? rtr.value.RTRNullValue()\n              void self.stack.append(obj.getItem(key))\n              break\n            case \"len\"\n              local obj @= self.stack.pop() ?? rtr.value.RTRNullValue()\n              void self.stack.append(rtr.value.RTRNumValue(obj.length()))\n              break\n              \n            case \"null\"\n              void self.stack.append(rtr.value.RTRNullValue())\n              break\n            case \"str\"\n              void self.stack.append(rtr.value.RTRStrValue(instruction.data))\n              break\n            case \"bool\"\n              void self.stack.append(rtr.value.RTRBoolValue(instruction.data))\n              break\n            case \"num\"\n              void self.stack.append(rtr.value.RTRNumValue(instruction.data))\n              break\n            case \"func\"\n              void self.stack.append(rtr.value.RTRBytecodeFuncValue(instruction.args, instruction.body))\n              break\n            case \"arr\"\n              local elems @= []\n              loop instruction.elems (\n                void elems.prepend(self.stack.pop() ?? rtr.value.RTRNullValue())\n              )\n              void self.stack.append(rtr.value.RTRArrValue(elems))\n              break\n            case \"obj\"\n              local values @= []\n              loop instruction.keys.len (\n                void values.prepend(self.stack.pop() ?? rtr.value.RTRNullValue())\n              )\n              \n              local obj @= {}\n              for obji values.len (\n                obj[instruction.keys[obji]] @= values[obji]\n              )\n              void self.stack.append(rtr.value.RTRObjValue(obj))\n              break\n            case \"color\"\n              void self.stack.append(rtr.value.RTRColorValue(instruction.data))\n              break\n            \n            case \"get\"\n              local val @= self.getScopeVar(instruction.name) ?? rtr.value.RTRNullValue()\n              void self.stack.append(val)\n              break\n            case \"decl\"\n              local val @= self.stack[-1] ?? rtr.value.RTRNullValue()\n              void self.declScopeVar(instruction.name, val, {\n                type: val.getRtrType()\n              })\n              break\n            case \"newScope\"\n              void self.newScope({})\n              break\n            case \"popScope\"\n              void self.popScope()\n              break\n            \n            case \"asivar\"\n              local val @= self.stack[-1] ?? rtr.value.RTRNullValue()\n              \n              local existingMeta @= self.getScopeVarMeta(instruction.name)\n              local existing @= self.getScopeVar(instruction.name)\n              \n              if instruction.op != null (\n                val @= self.runBinary(existing, instruction.op, val)\n              )\n              \n              local curType @= val.getRtrType()\n              if existingMeta.type != null (\n                if !existingMeta.type.isEqual(curType) (\n                  // replace with return err\n                  throw \"cannot assign\" + curType.stringify() + \"to\" + existingMeta.type.stringify() + \"variable\" \n                )\n              )\n              \n              void self.setScopeVar(instruction.name, val)\n              break\n            case \"asiprop\"\n              local key @= self.stack.pop() ?? rtr.value.RTRNullValue()\n              local obj @= self.stack.pop() ?? rtr.value.RTRNullValue()\n              \n              local val @= self.stack[-1] ?? rtr.value.RTRNullValue()\n              if instruction.op != null (\n                val @= self.runBinary(obj.getItem(key), instruction.op, val)\n              )\n              \n              void obj.setItem(key, val)\n              break\n            \n            case \"pop\"\n              void self.stack.pop()\n              break\n            case \"dupe\"\n              void self.stack.append(self.stack[instruction.i])\n              break\n            \n            default\n              return rtr.error.Error(\"UnknownInstructionKind\", { kind: instruction.kind })\n          )\n          \n        )\n        \n        return rtr.value.RTRNullValue()\n      )\n    )\n    \n    class RTR (\n      def init() (\n        self.modules @= {}\n        self.console @= []\n        self.ouid = OuidNew()\n        \n        self.started = false\n      )\n    \n      def addModule(object mod) (\n        local key @= OuidNew()\n        mod.inst @= self\n        self.modules[key] @= mod\n        return key\n      )\n      \n      def startModules() (\n        if !self.started (\n          self.started = true\n          void self.runEvent({\n           name: \"onload\"\n          }, {})\n        )\n      )\n      \n      def runEvent(object target, object data) (\n        local mods @= self.modules.getValues()\n        for i mods.len (\n          void mods[i].runEvent(target, data)\n        )\n      )\n      def runEvents(object target, object data) (\n        local mods @= self.modules.getValues()\n        for i mods.len (\n          void mods[i].runEvents(target, data)\n        )\n      )\n    )\n  )\n  return __imports__954b63a69b7120a02fa83923726ef587\ncase \"./src/rwl/ast.osl\"\n  class __imports__823191bbaeb9397e6eaf51c446a37c4c (\n    class Parser (\n      def init(string text) (\n        void self.tokenise(text)\n      )\n      \n      def parse() (\n        self.pointer = 1\n        \n        local out @= {\n          elements: self.blockContent()\n        }\n        \n        if !self.atEnd() (\n          throw \"unexpected token '\" ++ self.peek() ++ \"'\"\n        )\n        \n        return out\n      )\n      \n      def peek() (\n        return self.tokens[self.pointer]\n      )\n      def consume() (\n        local tkn = self.peek()\n        self.pointer ++\n        return tkn\n      )\n      def consumeWhitespace() (\n        while self.peek().match(\"/^\\\\s$/\") != null (\n          void self.consume()\n        )\n      )\n      def consumeSpaces() (\n        local txt = \"\"\n        while self.peek() == \" \" (\n          txt ++= self.consume()\n        )\n        return txt\n      )\n      def atEnd() (\n        return self.pointer >= self.tokens.len\n      )\n      def expect(string token) (\n        local tkn @= self.consume()\n        if tkn != token (\n          throw \"expected '\" ++ token ++ \"' got '\" ++ tkn ++ \"'\"\n        )\n        return tkn\n      )\n      def expects(array tokens) (\n        local tkn @= self.consume()\n        if !tokens.contains(tkn) (\n          throw \"expected '\" ++ tokens.join(\" or \") ++ \"' got '\" ++ tkn ++ \"'\"\n        )\n        return tkn\n      )\n      def expectText() (\n        local tkn @= self.consume()\n        if !tkn.match(\"/^[a-zA-Z_0-9]+$/\") (\n          throw \"identifier must consist of letters or _\"\n        )\n        return tkn\n      )\n      def getPos() (\n        local ln = 1\n        local col = 0\n        local i = self.pointer\n        for t self.pointer (\n          col ++\n          if self.tokens[t] == \"\\n\" (\n            ln ++\n            col = 0\n          )\n        )\n        return { ln, col, i }\n      )\n      \n      def tokenise(string text) (\n        self.tokens @= []\n        local splitChars @= [\n          // rwl\n          \"{\",\"}\",\n          \"[\",\"]\",\n          \",\",\n          \" \",\n          \"\\n\",\n          \"/\",\"\\\\\",\"*\",\n          \"'\",\"\\\"\",\"`\",\n          \":\",\"#\",\"%\",\"=\",\n          // rtr\n          \"(\",\")\",\n          \"[\",\"]\",\n          \"{\",\"}\",\n          \",\",\";\",\":\",\"=\",\".\",\n          \"+\",\"-\",\"*\",\"/\",\"%\",\"^\",\n          \"\\\\\",\n          \"'\",\"\\\"\",\"`\",\n          \" \",\"\\n\",\n          \"!\",\"?\"\n        ]\n        local buf = \"\"\n        for i text.len (\n          if splitChars.contains(text[i]) (\n            if buf.len > 0 (\n              void self.tokens.append(buf)\n            )\n            void self.tokens.append(text[i])\n            buf = \"\"\n          ) else (\n            buf ++= text[i]\n          )\n        )\n        if buf.len > 0 (\n          self.tokens.append(buf)\n        )\n      )\n      \n      // statements\n      def blockContent() (\n        local statements @= []\n        local end = false\n        while !end (\n          local out @= self.statement()\n          if out != null (\n            void statements.append(out)\n          )\n          void self.consumeWhitespace()\n          log self.atEnd()\n          if self.peek() == \"}\" or self.atEnd() (\n            end = true\n          ) else (\n            void self.expect(\",\")\n          )\n        )\n        return statements\n      )\n      \n      def statement() (\n        void self.consumeWhitespace()\n        \n        local start @= self.getPos()\n        local tkn @= self.peek()\n        \n        // void elements\n        if [\"icon\",\"image\"].contains(tkn) (\n          void self.consume()\n          void self.consumeWhitespace()\n          local header @= self.header()\n          \n          return {\n            data: {\n              header\n            },\n            kind: tkn,\n            start, end: self.getPos()\n          }\n        )\n        \n        // block\n        if tkn.match(\"/^[a-zA-Z]+$/\") != null (\n          return self.blockStatement()\n        )\n        \n        // element\n        local value @= self.value()\n        if value != null (\n          void self.consumeWhitespace()\n          local header @= self.header()\n          \n          return {\n            data: {\n              value,\n              header\n            },\n            kind: \"element\",\n            start, end: self.getPos()\n          }\n        )\n      )\n      \n      def blockStatement() (\n        local start @= self.getPos()\n        local key @= self.consume()\n        \n        void self.consumeWhitespace()\n        \n        local header @= self.header()\n        header.key = key\n        \n        void self.consumeWhitespace()\n        \n        if key == \"script\" (\n          local content = \"\"\n          local spaceContent = \"\"\n          void self.expect(\"{\")\n          local end = false\n          local depth = 1\n          local stringType = null\n          while !end (\n            local tkn @= self.peek()\n            \n            if tkn == \"'\" (\n              if stringType == \"'\" (\n                stringType = null\n              ) else if stringType == null (\n                stringType = \"'\"\n              )\n            )\n            \n            if tkn == \"\\\"\" (\n              if stringType == \"\\\"\" (\n                stringType = null\n              ) else if stringType == null (\n                stringType = \"\\\"\"\n              )\n            )\n            \n            if tkn == \"`\" (\n              if stringType == \"`\" (\n                stringType = null\n              ) else if stringType == null (\n                stringType = \"`\"\n              )\n            )\n            \n            if stringType == null (\n              if tkn == \"{\" (\n                depth ++\n              )\n              if tkn == \"}\" (\n                depth --\n              )\n            )\n            \n            if self.atEnd() or (tkn == \"}\" and depth == 0 and stringType == null) (\n              end = true\n            ) else (\n              if tkn == \"\\n\" (\n                spaceContent = \"\"\n                void self.consume()\n                if content != \"\" (\n                  content ++= \"\\n\"\n                )\n              ) else if tkn == \" \" (\n                spaceContent ++= self.consume()\n              ) else (\n                content ++= spaceContent\n                content ++= self.consume()\n                spaceContent = \"\"\n              )\n            )\n          )\n          void self.expect(\"}\")\n        ) else (\n          local content @= self.block()\n        )\n        \n        return {\n          kind: \"block\",\n          data: {\n            header,\n            content\n          },\n          start, end: self.getPos()\n        }\n      )\n      \n      def block() (\n        local start @= self.getPos()\n        void self.expect(\"{\")\n        void self.consumeWhitespace()\n        local elements @= self.blockContent()\n        void self.consumeWhitespace()\n        void self.expect(\"}\")\n        return { elements, start, end: self.getPos() }\n      )\n      \n      // header stuff\n      def header() (\n        local start @= self.getPos()\n        local attributes @= []\n        if self.peek() == \"[\" (\n          void self.expect(\"[\")\n          local end = self.peek() == \"]\"\n          while !end (\n            local out @= self.headerItem()\n            if out != null (\n              void attributes.append(out)\n            )\n            void self.consumeWhitespace()\n            if self.peek() == \",\" (\n              void self.consume()\n            )\n            if self.peek() == \"]\" or self.atEnd() (\n              end = true\n            )\n          )\n          void self.expect(\"]\")\n        )\n        \n        return { attributes, start, end: self.getPos() }\n      )\n      def headerItem() (\n        void self.consumeWhitespace()\n        local start @= self.getPos()\n        local tkn @= self.consume()\n        void self.consumeWhitespace()\n        if self.peek() == \"=\" (\n          if tkn.match(\"/^[a-zA-Z_]+$/\") == null (\n            throw \"attribute key must consist of letters or _\"\n          )\n          void self.consume()\n          local value @= self.value()\n          return {\n            kind: \"key\",\n            key: tkn,\n            value,\n            start, end: self.getPos()\n          }\n        )\n        if tkn.match(\"/^[a-zA-Z_]+$/\") != null (\n          return {\n            kind: \"flag\",\n            data: tkn,\n            start, end: self.getPos()\n          }\n        )\n      )\n      \n      // values\n      def value() (\n        log self.peek()\n        if [\"'\",\"\\\"\",\"`\"].contains(self.peek()) (\n          return self.str()\n        )\n        \n        if self.peek().match(\"/^[0-9]+$/\") != null (\n          return self.num()\n        )\n        \n        if self.peek() == \"#\" (\n          return self.color()\n        )\n        \n        if self.peek().match(\"/^\\\\w+$/\") != null (\n          return self.property()\n        )\n      )\n      \n      def str() (\n        local start @= self.getPos()\n        local q @= self.expects([\"'\",\"\\\"\",\"`\"])\n        local content = \"\"\n        local end = false\n        while !end (\n          local tkn @= self.peek()\n          if tkn == \"\\\\\" (\n            void self.consume()\n            local tkn = self.consume()\n            local char = tkn[1]\n            switch char (\n              case \"n\"\n                char = \"\\n\"\n                break\n            )\n            content ++= char ++ tkn.trim(2,-1)\n            continue\n          )\n          \n          if q == tkn (\n            end = true\n          ) else (\n            content ++= self.consume()\n          )\n          if self.atEnd() (\n            end = true\n          )\n        )\n        void self.expect(q)\n        return {\n          type: \"str\",\n          value: content,\n          start, end: self.getPos()\n        }\n      )\n      \n      // and percentage\n      def num() (\n        if self.peek().match(\"/^[0-9]+$/\") == null (\n          throw \"unexpected token '\" ++ self.peek() ++ \"'\"\n        )\n        \n        local start @= self.getPos()\n        \n        local value @= self.consume().toNum()\n        \n        local type = \"num\"\n        \n        if self.peek() == \"%\" (\n          void self.consume()\n          type = \"percentage\"\n        )\n        \n        return {\n          type,\n          value,\n          start, end: self.getPos()\n        }\n      )\n      \n      def color() (\n        local start @= self.getPos()\n        void self.expect(\"#\")\n        local value = self.consume()\n        if ![3,6].contains(value.len) (\n          throw \"hex values can only be 3 or 6 characters long\"\n        )\n        return {\n          type: \"color\",\n          value: \"#\" ++ value,\n          start, end: self.getPos()\n        }\n      )\n      \n      def property() (\n        local start @= self.getPos()\n        local source = self.consume()\n        if source.match(\"/^[a-zA-Z_]+$/\") == null (\n          throw \"source must consist of letters or _\"\n        )\n        \n        void self.consumeWhitespace()\n        void self.expect(\":\")\n        void self.consumeWhitespace()\n        \n        local name = self.consume()\n        if name.match(\"/^[a-zA-Z_]+$/\") == null (\n          throw \"name must consist of letters or _\"\n        )\n        \n        return {\n          type: \"property\",\n          source,\n          name,\n          start, end: self.getPos()\n        }\n      )\n    )\n  )\n  return __imports__823191bbaeb9397e6eaf51c446a37c4c\ncase \"./src/rwl/debug.osl\"\n  class __imports__a02a29842cf0d752bb9291888afe9568 (\n    def box(array area, color) (\n      if !rwl.main.debug (\n        return\n      )\n      void shared.graphics.box(area, color ?? #f00)\n    )\n  )\n  return __imports__a02a29842cf0d752bb9291888afe9568\ncase \"./src/rwl/value.osl\"\n  class __imports__b6b9b465fcf5c8c4f9d5fe786e8bce9c (\n    class RWLValue (\n      \n    )\n    \n    class RWLStrValue extends RWLValue (\n      type = \"str\"\n      def init(string value) (\n        self.value @= value\n      )\n    )\n    \n    class RWLNumValue extends RWLValue (\n      type = \"num\"\n      def init(number value) (\n        self.value @= value\n      )\n    )\n    \n    class RWLPercentageValue extends RWLValue (\n      type = \"percentage\"\n      def init(number value) (\n        self.value @= value\n      )\n    )\n    \n    class RWLColorValue extends RWLValue (\n      type = \"color\"\n      def init(string value) (\n        self.value @= value\n      )\n    )\n    \n    def AstToValue(ast) (\n      switch ast.type (\n        case \"str\"\n          return rwl.value.RWLStrValue(ast.value)\n        case \"num\"\n          return rwl.value.RWLNumValue(ast.value)\n        case \"percentage\"\n          return rwl.value.RWLPercentageValue(ast.value)\n        case \"color\"\n          return rwl.value.RWLColorValue(ast.value)\n        case \"property\"\n          switch ast.source (\n            case \"theme\"\n              local col = shared.theme[ast.name]\n              if typeof(col) == \"string\" (\n                return rwl.value.RWLColorValue(col)\n              )\n              break\n            default\n              return rwl.error.Error(\"UnknownPropertySource\", {\n                source: ast.source\n              })\n          )\n          return rwl.error.Error(\"UnknownProperty\", {\n            property: ast.name,\n            source: ast.source\n          })\n        default\n          return rwl.error.Error(\"UnknownValueType\", {\n            valueType: ast.type\n          })\n      )\n    )\n  )\n  return __imports__b6b9b465fcf5c8c4f9d5fe786e8bce9c\ncase \"./src/rwl/error.osl\"\n  class __imports__c17b91d805bd65a760423a0b948a2c09 (\n    object Errors = {\n      UnknownElementKind: def(data) -> (\n        return \"unknown element kind:\" + data.elementKind\n      ),\n      UnknownAttributeKind: def(data) -> (\n        return \"unknown attribute kind:\" + data.attributeKind\n      ),\n      \n      UnknownValueType: def(data) -> (\n        return \"unknown value type:\" + data.valueType\n      ),\n      UnknownBlockType: def(data) -> (\n        return \"unknown block type:\" + data.blockType\n      ),\n      \n      InvalidAnchorName: def(data) -> (\n        return \"unknown anchor name\" + data.name\n      ),\n      InvalidAlignmentName: def(data) -> (\n        return \"unknown anchor name\" + data.name\n      ),\n      \n      InvalidElemType: def(data) -> (\n        return \"cannot have\" + data.valueType + \"as element\"\n      ),\n      \n      ValueTypeMismatch: def(data) -> (\n        if typeof(data.wanted) == \"string\" (\n          data.wanted @= [data.wanted]\n        )\n        local forCtx = \"\"\n        if data.attr != null (\n          forCtx += \"for\" + data.attr\n        )\n        return \"wanted\" + data.wanted.join(\" or \") + \"got\" + data.got ++ forCtx\n      ),\n      \n      UnknownProperty: def(data) -> (\n        return \"unknown property\" + data.property + \"on\" + data.source\n      ),\n      UnknownPropertySource: def(data) -> (\n        return \"unknown source\" + data.source\n      ),\n      \n      ElemInFrame: def(data) -> (\n        return \"element in a frame, only sections are allowed directly in frames\"\n      ),\n      \n      NoScriptType: def(data) -> (\n        return \"no script type attribute\"\n      ),\n      InvalidScriptType: def(data) -> (\n        return \"unknown script type\" + data.type\n      ),\n      InvalidScriptAttrType: def(data) -> (\n        return \"unknown script type attribute type\" + data.type\n      ),\n      \n      NoIconSrc: def(data) -> (\n        return \"icon has no src\"\n      )\n    }\n    \n    class Error (\n      boolean isError = true\n      \n      def init(string type, object data) (\n        self.type = type\n        self.data @= data\n        \n        local err @= rwl.error.Errors[type]\n        if err == null (\n          self.type = \"UnknownErrorType\"\n          self.txt = \"unknown error type\" + type\n          return\n        )\n        self.txt = err(data)\n      )\n      \n      def stringify() (\n        return \"Error<\" ++ self.type ++ \">:\\n\" ++ self.txt.split(\"\\n\").map(l -> \"    \" ++ l).join(\"\\n\")\n      )\n    )\n  )\n  return __imports__c17b91d805bd65a760423a0b948a2c09\ncase \"./src/rwl/area.osl\"\n  class __imports__51b19cf190821eee598f3dc8fa9be944 (\n    def copy(area) (\n      return [area[1], area[2], area[3], area[4]]\n    )\n    \n    def centerX(area) (\n      return area[1] + area[3] / 2\n    )\n    \n    def centerY(area) (\n      return area[2] + area[4] / 2\n    )\n    \n    def width(area) (\n      return area[3] - area[1]\n    )\n    \n    def height(area) (\n      return area[4] - area[2]\n    )\n    \n    def pad(area, pad) (\n      return [\n        area[1] + pad[1],\n        area[2] + pad[2],\n        area[3] - pad[3],\n        area[4] - pad[4]\n      ]\n    )\n    \n    def margin(area, mar) (\n      return [\n        area[1] - mar[1],\n        area[2] - mar[2],\n        area[3] + mar[3],\n        area[4] + mar[4]\n      ]\n    )\n  )\n  return __imports__51b19cf190821eee598f3dc8fa9be944\ncase \"./src/rwl/config.osl\"\n  class __imports__997006161a7103fcb97a4e4d8f4a25b1 (\n    goob = \"hi\"\n  )\n  return __imports__997006161a7103fcb97a4e4d8f4a25b1\ncase \"./src/rwl/main.osl\"\n  class __imports__b471b13f60903428337025313115b852 (\n    debug = false\n    \n    class RWLNode (\n      // global attributes\n      def initGlobal() (\n        self.elemI = rwl.main.elemI\n        rwl.main.elemI ++\n        self.updateGlobal()\n      )\n      def updateGlobal(area, context) (\n        self.id = null\n        \n        local id @= self.expectOnHeader(\"id\", \"str\")\n        if id.isError (\n          return id\n        )\n        if id != null (\n          self.id = id.value\n        )\n        \n        self.cu_area @= area\n        self.cu_context @= context\n        void self.checkUpdate()\n      )\n      \n      def updateFromCache() (\n        if self.cu_area != null (\n          void self.update(self.cu_area, self.cu_context)\n        )\n      )\n      \n      def updateParentFromCache() (\n        if self.parent != null and self.parent.name != null (\n          void self.parent.updateFromCache()\n        ) else (\n          void self.updateFromCache()\n        )\n      )\n      \n      def checkUpdate() (\n        if self.needsUpdate (\n          self.needsUpdate = false\n          void self.updateFromCache()\n        )\n        \n        // used when this was a branch like system\n        //if self.children != null (\n        //  for i self.children.len (\n        //    void self.children[i].checkUpdate()\n        //  )\n        //)\n      )\n      \n      def update() (\n        \n      )\n      \n      def topUpdate() (\n        \n      )\n      \n      def interactUpdate() (\n        \n      )\n      \n      def render() (\n        \n      )\n      \n      def renderDevtools() (\n        \n      )\n      \n      def expectOnHeader(string key, string type) (\n        for attrI self.header.pairs.len (\n          local attr @= self.header.pairs[attrI]\n          if attr[2].isError (\n            return attr[2]\n          )\n          if attr[1] == key (\n            if attr[2].type != type (\n              return rwl.error.Error(\"ValueTypeMismatch\", {\n                wanted: type,\n                got: attr[2].type\n              })\n            ) else (\n              return attr[2]\n            )\n          )\n        )\n        return null\n      )\n      \n      def getAreaKeys(string name, pairs) (\n        local l = 0\n        local r = 0\n        local b = 0\n        local t = 0\n        \n        pairs ??= self.header.pairs\n        for pairI pairs.len (\n          local pair @= pairs[pairI]\n          local n = pair[1]\n          local value @= pair[2]\n          \n          if n == name (\n            l = value.value\n            r = value.value\n            b = value.value\n            t = value.value\n          ) else if n == name ++ \"_x\" (\n            l = value.value\n            r = value.value\n          ) else if n == name ++ \"_y\" (\n            b = value.value\n            t = value.value\n          ) else if n == name ++ \"_l\" or n == name ++ \"_left\" (\n            l = value.value\n          ) else if n == name ++ \"_r\" or n == name ++ \"_right\" (\n            r = value.value\n          ) else if n == name ++ \"_b\" or n == name ++ \"_bottom\" (\n            b = value.value\n          ) else if n == name ++ \"_t\" or n == name ++ \"_top\" (\n            t = value.value\n          )\n        )\n        \n        return [l, b, r, t]\n      )\n      \n      def getPadding(pairs) (\n        return self.getAreaKeys(\"padding\", pairs)\n      )\n      def getMargin(pairs) (\n        return self.getAreaKeys(\"margin\", pairs)\n      )\n    )\n    \n    class RWLContainer extends RWLNode (\n      kind = \"block\"\n      def init(array children, object header) (\n        self.children @= children\n        self.header @= header\n        void self.initGlobal()\n      )\n      \n      def update(array area, object context) (\n        void self.updateBackgroundColor()\n        void self.updateBackground(area)\n        void self.updateGlobal(area, context)\n        \n        local childArea @= rwl.area.pad(area, self.getPadding())\n        \n        self.area @= area\n        self.childArea @= childArea\n        \n        return rwl.main.UpdateElements(self.children, childArea, {\n          anchorX: \"c\",\n          anchorY: \"c\",\n          color: \"#fff\",\n          inst: context.inst\n        }, self)\n      )\n      \n      def interactUpdate(object context) (\n        for i self.children.len (\n          void self.children[i].interactUpdate(context)\n        )\n      )\n      \n      def updateBackgroundColor() (\n        local color @= self.expectOnHeader(\"color\", \"color\")\n        \n        if color != null (\n          self.color @= color.value\n        )\n      )\n      \n      def updateBackground(array area) (\n        self.area @= area\n        \n        local allRounding @= self.expectOnHeader(\"rounding\", \"num\")\n        \n        local rounding @= allRounding.value ?? 0\n        \n        local corners @= [\"bl\",\"br\",\"tl\",\"tr\"]\n        for i corners.len (\n          local corner @= self.expectOnHeader(\"rounding_\" ++ corners[i], \"num\")\n          if corner != null (\n            if typeof(rounding) != \"array\" (\n              rounding @= []\n              loop i - 1 (\n                void rounding.append(allRounding.value ?? 0)\n              )\n            )\n            void rounding.append(corner.value ?? 0)\n          ) else (\n            void rounding.append(allRounding.value ?? 0)\n          )\n        )\n        self.rounding @= rounding\n        \n        void self.updateBackgroundColor()\n      )\n      \n      def render() (\n        if self.header.flags.contains(\"Hidden\") (\n          void self.renderDevtools()\n          return\n        )\n        \n        void self.renderBackground()\n        if rwl.main.debug (\n          void rwl.debug.box(self.area, #f00)\n          void rwl.debug.box(self.childArea, #0f0)\n        )\n        void rwl.main.RenderElements(self.children)\n        void self.renderDevtools()\n      )\n      \n      def renderDevtools() (\n        if self.elemI == devtools.main.hoveredElement (\n          self.childArea ??= self.area\n          \n          // left\n          void shared.graphics.filledTransparentArea([\n            self.area[1],\n            self.area[2],\n            self.childArea[1],\n            self.area[4]\n          ], #f0f, 20)\n          // right\n          void shared.graphics.filledTransparentArea([\n            self.childArea[3],\n            self.area[2],\n            self.area[3],\n            self.area[4]\n          ], #f0f, 20)\n          // top\n          void shared.graphics.filledTransparentArea([\n            self.childArea[1],\n            self.childArea[4],\n            self.childArea[3],\n            self.area[4]\n          ], #f0f, 20)\n          // bottom\n          void shared.graphics.filledTransparentArea([\n            self.childArea[1],\n            self.area[2],\n            self.childArea[3],\n            self.childArea[2]\n          ], #f0f, 20)\n          \n          if self.fullArea != null (\n            // left\n            void shared.graphics.filledTransparentArea([\n              self.fullArea[1],\n              self.fullArea[2],\n              self.area[1],\n              self.fullArea[4]\n            ], #0f0, 20)\n            // right\n            void shared.graphics.filledTransparentArea([\n              self.area[3],\n              self.fullArea[2],\n              self.fullArea[3],\n              self.fullArea[4]\n            ], #0f0, 20)\n            // top\n            void shared.graphics.filledTransparentArea([\n              self.area[1],\n              self.area[4],\n              self.area[3],\n              self.fullArea[4]\n            ], #0f0, 20)\n            // bottom\n            void shared.graphics.filledTransparentArea([\n              self.area[1],\n              self.fullArea[2],\n              self.area[3],\n              self.area[2]\n            ], #0f0, 20)\n          )\n          \n          if self.name != \"RWLFrame\" (\n            void shared.graphics.filledTransparentArea(self.childArea, #0ff, 20)\n          )\n        )\n      )\n      \n      def renderBackground() (\n        if self.color != null (\n          void shared.graphics.filledBox(self.area, self.rounding, self.color)\n        )\n      )\n    )\n    \n    class RWLRoot extends RWLContainer (\n      blockName = \"root\"\n      \n      def init(array children, object header) (\n        self.children @= children\n        self.header @= header\n        void self.initGlobal()\n      )\n    )\n    \n    class RWLFrame extends RWLContainer (\n      blockName = \"frame\"\n      \n      def init(array children, object header) (\n        self.children @= children\n        self.header @= header\n        void self.initGlobal()\n      )\n      \n      def update(array area, object context) (\n        void self.updateBackgroundColor()\n        void self.updateBackground(area)\n        void self.updateGlobal(area, context)\n        \n        local dir = \"x\"\n        local flipped = false\n        for flagI self.header.flags.len (\n          switch self.header.flags[flagI] (\n            case \"Horizontal\"\n              dir = \"x\"\n              break\n            case \"Vertical\"\n              dir = \"y\"\n              break\n            case \"Flipped\"\n              flipped = !flipped\n              break\n          )\n        )\n        \n        local amount = 0\n        if dir == \"x\" (\n          local total = rwl.area.width(area)\n        ) else if dir == \"y\" (\n          local total = rwl.area.height(area)\n        )\n        \n        local frameContext @= {\n          inst: context.inst\n        }\n        \n        for i self.children.len (\n          local child @= self.children[i]\n          \n          // defaults to remaining\n          local size = total - amount\n          local pairs @= child.header.pairs\n          for pairI pairs.len (\n            local pair @= pairs[pairI]\n            local value @= pair[2]\n            if pair[1] == \"size\" or (pair[1] == \"width\" and dir == \"x\") or (pair[1] == \"height\" and dir == \"y\") (\n              switch value.type (\n                case \"num\"\n                  size = value.value\n                  break\n                case \"percentage\"\n                  size = value.value / 100 * (total - amount)\n                  break\n                default\n                  return rwl.error.Error(\"ValueTypeMismatch\", {\n                    wanted: [\"num\", \"percentage\"],\n                    got: value.type\n                  })\n              )\n              break\n            )\n          )\n          \n          if dir == \"x\" (\n            local childArea @= [\n              flipped ? (area[3] - amount - size) (area[1] + amount),\n              area[2],\n              flipped ? (area[3] - amount) (area[1] + amount + size),\n              area[4]\n            ]\n          ) else if dir == \"y\" (\n            local childArea @= [\n              area[1],\n              flipped ? (area[2] + amount) (area[4] - amount - size),\n              area[3],\n              flipped ? (area[2] + amount + size) (area[4] - amount)\n            ]\n          )\n          \n          child.fullArea @= childArea\n          \n          childArea @= rwl.area.pad(childArea, self.getMargin(pairs))\n          \n          if child.kind == \"block\" (\n            local out @= child.update(childArea, frameContext)\n            if out.isError (\n              return out\n            )\n          ) else if [\"icon\"].contains(child.kind) (\n            void child.update(childArea, frameContext)\n          ) else (\n            return rwl.error.Error(\"ElemInFrame\", {})\n          )\n          amount += size\n        )\n        if dir == \"x\" (\n          self.usedArea @= [\n            flipped ? (area[3] - amount) (area[1]),\n            area[2],\n            flipped ? (area[3]) (area[1] + amount),\n            area[4]\n          ]\n          self.unusedArea @= [\n            flipped ? (area[1]) (area[1] + amount),\n            area[2],\n            flipped ? (area[3] - amount) (area[3]),\n            area[4]\n          ]\n        ) else if dir == \"y\" (\n          self.usedArea @= [\n            area[1],\n            flipped ? (area[2]) (area[4] - amount),\n            area[3],\n            flipped ? (area[2] + amount) (area[4])\n          ]\n          self.unusedArea @= [\n            area[1],\n            flipped ? (area[2] + amount) (area[2]),\n            area[3],\n            flipped ? (area[4]) (area[4] - amount)\n          ]\n        )\n      )\n      \n      def render() (\n        if self.header.flags.contains(\"Hidden\") (\n          void self.renderFrameDevtools()\n          return\n        )\n        \n        void self.renderBackground()\n        void rwl.main.RenderElements(self.children)\n        void self.renderFrameDevtools()\n      )\n      \n      def renderFrameDevtools() (\n        if self.elemI == devtools.main.hoveredElement (\n          void shared.graphics.filledTransparentArea(self.usedArea, #0ff, 20)\n          void shared.graphics.filledTransparentArea(self.unusedArea, #00f, 20)\n        )\n      )\n    )\n    \n    class RWLSection extends RWLContainer (\n      blockName = \"section\"\n      \n      def init(array children, object header) (\n        self.children @= children\n        self.header @= header\n        void self.initGlobal()\n      )\n    )\n    \n    class RWLPositionedContainer extends RWLContainer (\n      def update(array containerArea, object context) (\n        void self.updateGlobal(containerArea, context)\n        \n        local height = self.expectOnHeader(\"height\", \"num\").value ?? 20\n        \n        local margin @= self.getMargin()\n        local padding @= self.getPadding()\n        \n        local anchor @= self.expectOnHeader(\"anchor\", \"str\")\n        if anchor.isError (\n          return anchor\n        )\n        anchor = anchor[\"value\"]\n        \n        if context.x == null or context.y == null (\n          anchor ??= \"c\"\n        )\n        \n        if anchor != null (\n          if [\"tl\",\"t\",\"tr\",\n              \"l\",\"c\",\"r\",\n              \"bl\",\"b\",\"br\",\n              \"top left\", \"top\", \"top right\",\n              \"left\", \"center\", \"right\",\n              \"bottom left\", \"bottom\", \"bottom right\"].contains(anchor).not() (\n            return rwl.error.Error(\"InvalidAnchorName\", {\n              name: anchor\n            })\n          )\n          \n          local anchorX = rwl.area.centerX(containerArea)\n          local anchorY = rwl.area.centerY(containerArea) + (height / 2)\n          local anchorXType = \"c\"\n          local anchorYType = \"c\"\n          \n          if anchor.endsWith(\"l\") or anchor.endsWith(\"left\") (\n            anchorXType = \"l\"\n          )\n          if anchor.endsWith(\"r\") or anchor.endsWith(\"right\") (\n            anchorXType = \"r\"\n          )\n          \n          if anchor.startsWith(\"t\") or anchor.endsWith(\"top\") (\n            anchorY = containerArea[4]\n            anchorYType = \"t\"\n          )\n          if anchor.startsWith(\"b\") or anchor.endsWith(\"bottom\") (\n            anchorY = containerArea[2] + height + margin[2] + margin[4]\n            anchorYType = \"b\"\n          )\n          \n          context.x = anchorX\n          context.y = anchorY\n          context.anchorX = anchorXType\n          context.anchorY = anchorYType\n        )\n        context.y -= height / (context.anchorY == \"b\" ? -2 2) + (context.anchorY == \"b\" ? -margin[2] margin[4])\n        \n        local area @= [\n          containerArea[1] + margin[1],\n          context.y - (height / 2),\n          containerArea[3] - margin[3],\n          context.y + (height / 2)\n        ]\n        self.fullArea @= [\n          containerArea[1],\n          context.y - (height / 2) - margin[2],\n          containerArea[3],\n          context.y + (height / 2) + margin[4]\n        ]\n        \n        context.y -= height / (context.anchorY == \"b\" ? -2 2) + (context.anchorY == \"c\" ? 0 context.anchorY == \"b\" ? -margin[4] margin[2])\n        \n        void self.updateBackground(area)\n        \n        local childArea @= rwl.area.pad(area, padding)\n        \n        self.childArea @= childArea\n        \n        return rwl.main.UpdateElements(self.children, childArea, {\n          anchorX: \"c\",\n          anchorY: \"c\",\n          color: \"#fff\",\n          inst: context.inst\n        }, self)\n      )\n      \n      def render() (\n        if self.header.flags.contains(\"Hidden\") (\n          void self.renderDevtools()\n          return\n        )\n        \n        void self.renderBackground()\n        if rwl.main.debug (\n          void rwl.debug.box(self.area, #f00)\n          void rwl.debug.box(self.childArea, #0f0)\n          void rwl.debug.box(self.outArea, #00f)\n        )\n        void rwl.main.RenderElements(self.children)\n        void self.renderDevtools()\n      )\n    )\n    \n    class RWLButton extends RWLPositionedContainer (\n      blockName = \"button\"\n      \n      def init(array children, object header) (\n        self.children @= children\n        self.header @= header\n        void self.initGlobal()\n      )\n      \n      def isHovered() (\n        return mouse_x > self.area[1] and mouse_y > self.area[2] and mouse_x < self.area[3] and mouse_y < self.area[4]\n      )\n      \n      def updateBackgroundColor() (\n        local color @= self.expectOnHeader(\"color\", \"color\")\n        if color.isError (\n          return color\n        )\n        if color != null (\n          self.color @= color.value\n        )\n        \n        local hover_color @= self.expectOnHeader(\"hover_color\", \"color\")\n        if hover_color.isError (\n          return hover_color\n        )\n        if hover_color != null (\n          self.hover_color @= hover_color.value\n        )\n      )\n      \n      def renderBackground() (\n        local hov = self.isHovered()\n        \n        local col = self.color\n        if self.hover_color != null and hov (\n          col = self.hover_color\n        )\n        if col != null (\n          void shared.graphics.filledBox(self.area, self.rounding, col)\n        )\n        \n        //void shared.graphics.box(self.area, #fff)\n      )\n      \n      def interactUpdate(object context) (\n        if self.isHovered() (\n          // rework to use actual ordering system / order elemI on elem creation\n          //log context.topI self.elemI\n          if context.topI < self.elemI (\n            context.top @= self\n            context.topI = self.elemI\n          )\n        )\n      )\n      \n      def topUpdate(object context) (\n        //log \"hi\" context shared.input.rwlLeftClick\n        if shared.input.rwlLeftClick (\n          void context.rtr.runEvents({\n            name: \"click\",\n            element: self\n          }, {})\n        )\n      )\n    )\n    \n    class RWLScript extends RWLNode (\n      blockName = \"script\"\n      kind = \"script\"\n      \n      def init(body, object header, object inst) (\n        self.body @= body\n        self.header @= header\n        \n        void self.parse()\n        void self.makeModule(inst)\n      )\n      \n      def parse() (\n        self.ast @= null\n        // TODO: try\n        local parser @= rtr.ast.Parser(body)\n        self.ast @= parser.parse()\n      )\n      \n      def makeModule(object inst) (\n        if self.ast != null (\n          self.mod @= rtr.main.Module(self.ast)\n          void inst.rtrInst.addModule(self.mod)\n        )\n      )\n      \n      def update(array area, object context) (\n        if self.mod != null (\n          void self.mod.runEvent({\n            name: \"onupdate\"\n          }, {})\n        )\n      )\n      \n      def start() (\n        void self.mod.runEvent({\n          name: \"onload\",\n        }, {})\n      )\n    )\n    \n    class RWLElement extends RWLNode (\n      kind = \"element\"\n      def init(object value, object header) (\n        self.value @= value\n        self.header @= header\n        void self.initGlobal()\n      )\n      \n      def update(array area, object context) (\n        void self.updateGlobal(area, context)\n        local text = null\n        \n        switch self.value.type (\n          case \"str\"; case \"num\"\n            text = self.value.value.toStr()\n            break\n        )\n        \n        if text == null (\n          return rwl.error.Error(\"InvalidElemType\", {\n            valueType: self.value.type\n          })\n        )\n        \n        // font\n        //<font>\n        local size @= self.expectOnHeader(\"size\", \"num\")\n        if size.isError (\n          return size\n        )\n        size = size[\"value\"] ?? 10\n        \n        local spacing @= self.expectOnHeader(\"spacing\", \"num\")\n        if spacing.isError (\n          return spacing\n        )\n        spacing = spacing[\"value\"] ?? 1\n        \n        local line_height @= self.expectOnHeader(\"line_height\", \"num\")\n        if line_height.isError (\n          return line_height\n        )\n        line_height = spacing[\"line_height\"] ?? 1\n        \n        // positioning\n        local margin @= self.getMargin()\n        \n        local anchor @= self.expectOnHeader(\"anchor\", \"str\")\n        if anchor.isError (\n          return anchor\n        )\n        anchor = anchor[\"value\"]\n        \n        if context.x == null or context.y == null (\n          anchor ??= \"c\"\n        )\n        \n        if anchor != null (\n          if [\"tl\",\"t\",\"tr\",\n              \"l\",\"c\",\"r\",\n              \"bl\",\"b\",\"br\",\n              \"top left\", \"top\", \"top right\",\n              \"left\", \"center\", \"right\",\n              \"bottom left\", \"bottom\", \"bottom right\"].contains(anchor).not() (\n            return rwl.error.Error(\"InvalidAnchorName\", {\n              name: anchor\n            })\n          )\n          \n          local anchorX = rwl.area.centerX(area)\n          local anchorY = rwl.area.centerY(area) + (line_height * 1 * size)\n          local anchorXType = \"c\"\n          local anchorYType = \"c\"\n          \n          if anchor.endsWith(\"l\") or anchor.endsWith(\"left\") (\n            anchorX = area[1] + margin[1]\n            anchorXType = \"l\"\n          )\n          if anchor.endsWith(\"r\") or anchor.endsWith(\"right\") (\n            anchorX = area[3] - margin[3]\n            anchorXType = \"r\"\n          )\n          \n          if anchor.startsWith(\"t\") or anchor.endsWith(\"top\") (\n            anchorY = area[4]\n            anchorYType = \"t\"\n          )\n          if anchor.startsWith(\"b\") or anchor.endsWith(\"bottom\") (\n            anchorY = area[2]\n            anchorYType = \"b\"\n          )\n          \n          context.x = anchorX\n          context.y = anchorY\n          context.anchorX = anchorXType\n          context.anchorY = anchorYType\n        )\n        \n        local boxAlignment = context.anchorX\n        \n        local alignment @= self.expectOnHeader(\"alignment\", \"str\")\n        if alignment.isError (\n          return alignment\n        )\n        alignment = alignment[\"value\"]\n        if alignment != null (\n          if [\"l\",\"c\",\"r\",\n              \"left\", \"center\", \"right\"].contains(alignment).not() (\n            return rwl.error.Error(\"InvalidAlignmentName\", {\n              name: anchor\n            })\n          )\n          \n          if alignment.endsWith(\"l\") or alignment.endsWith(\"left\") (\n            alignment = \"l\"\n          )\n          if alignment.endsWith(\"r\") or alignment.endsWith(\"right\") (\n            alignment = \"r\"\n          )\n        )\n        alignment ??= boxAlignment\n        \n        // appearance\n        //<link>\n        //<decoration>\n        local color @= self.expectOnHeader(\"color\", \"color\")\n        if color.isError (\n          return color\n        )\n        color = color.value\n        if color != null (\n          context.color = color\n        )\n        color ??= context.color\n        \n        local lines @= text.split(\"\\n\")\n        local width = 0\n        for lineI lines.len (\n          width = max(width, lines[lineI].len * size * spacing)\n        )\n        local height = lines.len * line_height * 2 * size\n        \n        local x = context.x\n        if boxAlignment == \"l\" (\n          x += width / 2\n        )\n        if boxAlignment == \"r\" (\n          x += width / -2\n        )\n        \n        context.y -= height / (context.anchorY == \"b\" ? -2 2) + (context.anchorY == \"b\" ? -margin[2] margin[4])\n        \n        self.lines @= []\n        local y = context.y + (height / 2)\n        for lineI lines.len (\n          y -= size * line_height\n          local lineW = shared.graphics.getTextWidth(lines[lineI]) * size\n          local lx = x\n          if alignment == \"l\" (\n            lx += width / -2\n          )\n          if alignment == \"r\" (\n            lx += width / 2 - lineW\n          )\n          if alignment == \"c\" (\n            // account for char spacing\n            lx += lineW * -.5\n          )\n          log self.lines\n          void self.lines.append([lines[lineI], lx, y, size, color])\n          y -= size * line_height\n        )\n        \n        self.debugArea @= [\n          x - (width / 2),\n          context.y - (height / 2),\n          x + (width / 2),\n          context.y + (height / 2)\n        ]\n        self.margin @= margin\n        \n        context.y -= height / (context.anchorY == \"b\" ? -2 2) + (context.anchorY == \"b\" ? -margin[4] margin[2])\n      )\n      \n      def render() (\n        if self.header.flags.contains(\"Hidden\") (\n          void self.renderDevtools()\n          return\n        )\n        \n        for lineI self.lines.len (\n          local line @= self.lines[lineI]\n          void shared.graphics.ptext(line[1], line[2], line[3], line[4], line[5])\n        )\n        \n        void rwl.debug.box(self.debugArea ?? [])\n        void self.renderDevtools()\n      )\n      \n      def renderDevtools() (\n        if self.elemI == devtools.main.hoveredElement (\n          void shared.graphics.filledTransparentArea(self.debugArea, #0ff, 20)\n          \n          local fullArea = rwl.area.margin(self.debugArea, self.margin)\n         \n          if fullArea != null (\n            // left\n            void shared.graphics.filledTransparentArea([\n              fullArea[1],\n              fullArea[2],\n              self.debugArea[1],\n              fullArea[4]\n            ], #f0f, 20)\n            // right\n            void shared.graphics.filledTransparentArea([\n              self.debugArea[3],\n              fullArea[2],\n              fullArea[3],\n              fullArea[4]\n            ], #f0f, 20)\n            // top\n            void shared.graphics.filledTransparentArea([\n              self.debugArea[1],\n              self.debugArea[4],\n              self.debugArea[3],\n              fullArea[4]\n            ], #f0f, 20)\n            // bottom\n            void shared.graphics.filledTransparentArea([\n              self.debugArea[1],\n              fullArea[2],\n              self.debugArea[3],\n              self.debugArea[2]\n            ], #f0f, 20)\n          )\n        )\n      )\n    )\n    \n    class RWLIcon extends RWLNode (\n      kind = \"icon\"\n      \n      def update(array area, object context) (\n        local scale @= self.expectOnHeader(\"scale\", \"num\")\n        if scale.isError (\n          return scale\n        )\n        self.scale = size.value ?? 1\n        \n        local src @= self.expectOnHeader(\"src\", \"str\")\n        if src.isError (\n          return src\n        )\n        if src == null (\n          return rwl.error.Error(\"NoIconSrc\", {})\n        )\n        self.src = src.value\n        \n        local color @= self.expectOnHeader(\"color\", \"color\")\n        if color.isError (\n          return color\n        )\n        self.color = color.value\n        \n        // TODO: anchors?\n        self.x = rwl.area.centerX(area)\n        self.y = rwl.area.centerY(area)\n      )\n      \n      def render() (\n        if self.header.flags.contains(\"Hidden\") (\n          void self.renderDevtools()\n          return\n        )\n        \n        void shared.graphics.picon(self.src, self.x, self.y, self.scale, self.color ?? \"#fff\")\n        void self.renderDevtools()\n      )\n      \n      def init(object header) (\n        self.header @= header\n      )\n    )\n    \n    def UpdateElements(array elements, array area, object context, object parentElem) (\n      for i elements.len (\n        elements[i].parent @= parentElem\n        local out @= elements[i].update(area, context)\n        if out.isError (\n          return out\n        )\n      )\n    )\n    \n    def RenderElements(array elements) (\n      for i elements.len (\n        //void\n        void elements[i].render()\n        void\n      )\n    )\n    \n    elemI = 0\n    def AstToElement(ast, object inst) (\n      def AstToHeader(header) (\n        local flags @= []\n        local pairs @= []\n        for attrI header.attributes.len (\n          local attr @= header.attributes[attrI]\n          switch attr.kind (\n            case \"flag\"\n              flags.append(attr.data)\n              break\n            case \"key\"\n              void pairs.append([attr.key, rwl.value.AstToValue(attr.value)])\n              break\n          )\n        )\n        return { flags, pairs }\n      )\n      //log \"a\" ast\n      local header @= AstToHeader(ast.data.header)\n      \n      switch ast.kind (\n        case \"block\"\n          if ast.data.header.key != \"script\" (\n            local children @= AstsToElements(ast.data.content.elements, inst)\n          )\n          if typeof(children) != \"array\" and children[\"isError\"] (\n            return children\n          )\n          switch ast.data.header.key (\n            // top level\n            case \"root\"\n              return rwl.main.RWLRoot(children, header)\n            \n            // normal\n            case \"frame\"\n              return rwl.main.RWLFrame(children, header)\n            case \"section\"\n              return rwl.main.RWLSection(children, header)\n            \n            case \"script\"\n              return rwl.main.RWLScript(shared.utils.removeIndents(ast.data.content), header, inst)\n            \n            case \"button\"\n              return rwl.main.RWLButton(children, header)\n            \n            default\n              return rwl.error.Error(\"UnknownBlockType\", {\n                blockType: ast.data.header.key\n              })\n              break\n          )\n          break\n        \n        case \"element\"\n          return rwl.main.RWLElement(rwl.value.AstToValue(ast.data.value), header)\n        \n        case \"icon\"\n          return rwl.main.RWLIcon(header)\n        \n        default\n          return rwl.error.Error(\"UnknownElementKind\", {\n            elementKind: ast.kind\n          })\n          break\n      )\n    )\n    \n    def AstsToElements(elements, object inst) (\n      local elems @= []\n      for i elements.len (\n        local out @= AstToElement(elements[i], inst)\n        if out.isError (\n          return out\n        )\n        void elems.append(out)\n      )\n      return elems\n    )\n    \n    class RWL (\n      def init(object ast, object rtrInst) (\n        self.rtrInst @= rtrInst\n        self.errored = false\n        self.needsUpdate = true\n        self.hasUpdated = false\n        \n        self._lastW = 0\n        self._lastH = 0\n        self._lastX = 0\n        self._lastY = 0\n        \n        void self.loadFromAst(ast)\n      )\n      \n      def loadFromAst(object ast) (\n        self.ast @= ast\n        self.elements @= rwl.main.AstsToElements(ast.elements, self)\n        \n        if typeof(self.elements) != \"array\" and self.elements.isError (\n          error self.elements.stringify()\n          self.errored = true\n          return\n        )\n      )\n      \n      def update(array area) (\n        self.hasUpdated = true\n        if self.errored (\n          return\n        )\n        \n        local out @= rwl.main.UpdateElements(self.elements, area, {\n          inst: self,\n          root: true\n        }, {})\n        if out.isError (\n          error out.stringify()\n          self.errored = true\n          self.errormsg = out.stringify()\n        )\n      )\n      \n      def checkUpdate(array area) (\n        local w = rwl.area.width(area)\n        local h = rwl.area.height(area)\n        local x = rwl.area.centerX(area)\n        local y = rwl.area.centerY(area)\n        \n        // if the width or height or x or y has changed, update\n        if w != self._lastW or h != self._lastH or x != self._lastX or y != self._lastY (\n          self.needsUpdate = true\n          \n          self._lastW = w\n          self._lastH = h\n          self._lastX = x\n          self._lastY = y\n        )\n        \n        if self.needsUpdate (\n          void self.update(area)\n          self.needsUpdate = false\n        )\n      )\n      \n      def interactUpdate(object context) (\n        if self.errored (\n          return\n        )\n      \n        context.top = null\n        context.topI = 0\n        for i self.elements.len (\n          void self.elements[i].interactUpdate(context)\n        )\n        \n        //log context.top\n        \n        if context.top != null (\n          void context.top.topUpdate(context)\n        )\n      )\n      \n      def checkElemUpdate() (\n        if self.errored (\n          return\n        )\n      \n        for i self.elements.len (\n          void self.elements[i].checkUpdate()\n        )\n      )\n      \n      def render(array area) (\n        void self.checkUpdate(area)\n      \n        self.worker.area @= area\n        if self.errored (\n          goto rwl.area.centerX(area) rwl.area.centerY(area)\n          centext \"rwl errored :(\" 12 : c#shared.theme.seco\n          if self.errormsg != null (\n            centext self.errormsg 8 : c#shared.theme.prim chy#-20\n          )\n          return\n        )\n        \n        void rwl.main.RenderElements(self.elements)\n      )\n      \n      def getElement(string id) (\n        local queue @= [...self.elements]\n        while queue.len > 0 (\n          local elem @= queue.shift()\n          \n          if elem.id == id (\n            return elem\n          )\n          \n          if elem.children != null (\n            for i elem.children.len (\n              void queue.append(elem.children[i])\n            )\n          )\n        )\n      )\n    )\n  )\n  return __imports__b471b13f60903428337025313115b852\ncase \"./sidebartest.rwl\"\n  return \"  root {\\n    frame [Horizontal, id=\\\"bleh\\\"] {\\n      section [\\n        id=\\\"sidebar\\\",\\n        size=150, color=theme:prim,\\n        rounding_tr=17.5, rounding_br=17.5,\\n        padding=10\\n      ] {},\\n      section {\\n      }\\n    },\\n    \\n    script {\\n      event(onload) {\\n        i := 0;\\n        createSidebarButton := (name) ~ {\\n          i = i + 1;\\n          elem := document.createContainer(\\\"button\\\");\\n          elem.height = 35;\\n          elem.padding = 10;\\n          elem.color = theme.seco;\\n          elem.hover_color = theme.tert;\\n          elem.rounding = 10;\\n          elem.id = \\\"btn\\\" + i;\\n          if (i == 1) {\\n            elem.anchor = \\\"t\\\";\\n          }\\n          elem.margin_b = 10;\\n          document.getElement(\\\"sidebar\\\").addChild(elem);\\n          \\n          script := document.createScript(\\\"event(#\\\" + elem.id + \\\":click) {\\\\n  log(\\\\\\\"\\\" + name + \\\" clicked!\\\\\\\");\\\\n}\\\\n\\\");\\n          document.root.addChild(script);\\n          \\n          text := document.createTextElement(name);\\n          text.color = theme.text;\\n          elem.addChild(text);\\n        };\\n        \\n        btns := [\\n          \\\"hi\\\",\\n          \\\"wow\\\",\\n          \\\"blehh\\\",\\n          \\\"fr\\\"\\n        ];\\n        \\n        for (btn, btns) {\\n          log(btn);\\n          createSidebarButton(btn);\\n        }\\n      }\\n    }\\n  }\"\n\ncase \"./test.rwl\"\n  return \"  root [color=theme:prim] {\\n    frame [Horizontal] {\\n      section [size=100, rounding_tr=20, rounding_br=20] {\\n        \\\"fr\\\" [color=theme:seco]\\n      },\\n      section {\\n        frame [Vertical] {\\n          section [size=50] {\\n            \\\"maybe?\\\" [color=theme:text, anchor=\\\"l\\\", margin=10, size=15]\\n          },\\n          section [color=theme:back, rounding=20, margin_r=10, margin_b=10, padding=20] {\\n            \\\"blehhh\\\" [color=theme:text],\\n            \\\"fr\\\",\\n            button [color=theme:prim,padding=5,rounding=5] {\\n              \\\"hi\\\"\\n            },\\n            \\\":P\\\" [anchor=\\\"bl\\\",size=5]\\n          }\\n        }\\n      }\\n    },\\n    script {\\n      event(onload) {\\n        log(\\\"blehh\\\");\\n        \\n        document.title = \\\"gay\\\";\\n        document.icon = \\\"flag-progress\\\";\\n      }\\n    }\\n  }\"\n\ncase \"./main.rwl\"\n  return \"  root {\\n    frame [Vertical] {\\n      section [size=50%, color=#fff] {\\n      \\n      }\\n    },\\n    \\\"hi\\\\nwow\\\"\\n  }\"\n)\n)\nimport as \"glass\" from \"packages\"\n\n// fpp boilerplate\n\n\n\nobject rwl @= {\n  main: import(\"./src/rwl/main.osl\"),\n  config: import(\"./src/rwl/config.osl\"),\n  area: import(\"./src/rwl/area.osl\"),\n  error: import(\"./src/rwl/error.osl\"),\n  value: import(\"./src/rwl/value.osl\"),\n  debug: import(\"./src/rwl/debug.osl\"),\n  ast: import(\"./src/rwl/ast.osl\")\n}\n\nobject rtr @= {\n  main: import(\"./src/rtr/main.osl\"),\n  ast: import(\"./src/rtr/ast.osl\"),\n  error: import(\"./src/rtr/error.osl\"),\n  value: import(\"./src/rtr/value.osl\"),\n  compiler: import(\"./src/rtr/compiler.osl\"),\n  instruction: import(\"./src/rtr/instruction.osl\"),\n  apis: {}\n}\n\n// make them load after\nrtr.apis @= {\n  main: import(\"./src/rtr/apis/main.osl\"),\n  rwl: import(\"./src/rtr/apis/rwl.osl\"),\n  browser: import(\"./src/rtr/apis/browser.osl\")\n}\n\nobject shared @= {\n  graphics: import(\"./src/shared/graphics.osl\"),\n  utils: import(\"./src/shared/utils.osl\"),\n  document: import(\"./src/shared/document.osl\"),\n  tab: import(\"./src/shared/tab.osl\"),\n  url: import(\"./src/shared/url.osl\"),\n  theme: import(\"./src/shared/theme.osl\"),\n  config: import(\"./src/shared/config.osl\"),\n  tab_worker: import(\"./src/shared/tab_worker.osl\"),\n  input: import(\"./src/shared/input.osl\"),\n  settings: import(\"./src/shared/settings.osl\"),\n  save: import(\"./src/shared/save.osl\")\n}\n\nobject layouts @= {\n  shared: {\n    state: import(\"./src/layouts/shared/state.osl\"),\n    utils: import(\"./src/layouts/shared/utils.osl\"),\n    topbar: import(\"./src/layouts/shared/topbar.osl\"),\n    urlbar: import(\"./src/layouts/shared/urlbar.osl\"),\n    view: import(\"./src/layouts/shared/view.osl\")\n  },\n  chromeLike: {\n    main: import(\"./src/layouts/chromeLike/main.osl\"),\n    topbar: import(\"./src/layouts/chromeLike/topbar.osl\")\n  },\n  summit: {\n    main: import(\"./src/layouts/summit/main.osl\"),\n    sidebar: import(\"./src/layouts/summit/sidebar.osl\"),\n    topbar: import(\"./src/layouts/summit/topbar.osl\")\n  }\n}\n\nobject net @= {\n  fetch: import(\"./src/net/fetch.osl\"),\n  response: import(\"./src/net/response.osl\")\n}\n\nif build.package.phosphorus.hasDevtools ?? true (\n  object devtools @= {\n    main: import(\"./src/devtools/main.osl\"),\n    topbar: import(\"./src/devtools/topbar.osl\"),\n    rightclick: import(\"./src/devtools/rightclick.osl\"),\n    \n    menus: {\n      elements: import(\"./src/devtools/menus/elements.osl\"),\n      console: import(\"./src/devtools/menus/console.osl\"),\n      network: import(\"./src/devtools/menus/network.osl\"),\n      storage: import(\"./src/devtools/menus/storage.osl\"),\n      compiled: import(\"./src/devtools/menus/compiled.osl\")\n    }\n  }\n)\n\nobject browserPages @= {\n  empty: import(\"./src/assets/empty.rwl\"),\n  home: import(\"./src/assets/home.rwl\"),\n  settings: () -> import(\"./src/assets/settings.rwl\")\n}\n\nvoid shared.settings.load()\nvoid shared.config.net.refresh()\n\nvoid layouts.chromeLike.main.init()\n\nif !build.built (\n  // debug tabs\n  local document @= shared.document.Document()\n  void document.loadUrl(shared.url.Url(\"phos://settings\"))\n  //void document.loadUrl(shared.url.Url(\"local://./main.rwl\"))\n  void layouts.shared.state.openTabDocument(document)\n  \n  local document2 @= shared.document.Document()\n  void document2.loadUrl(shared.url.Url(\"local://./test.rwl\"))\n  void layouts.shared.state.openTabDocument(document2)\n  \n  local document3 @= shared.document.Document()\n  void document3.loadUrl(shared.url.Url(\"local://./sidebartest.rwl\"))\n  void layouts.shared.state.openTabDocument(document3)\n) else (\n  local document3 @= shared.document.Document()\n  void document3.loadUrl(shared.url.Url(shared.config.url.browser_scheme ++ \"://home\"))\n  void layouts.shared.state.openTabDocument(document3)\n)\n\nvoid layouts.shared.state.selectTab(1)\n\nvoid window.resize(900,500)\n\ncurrentLayout = build.package.phosphorus.layout ?? \"chromeLike\"\n\nif !build.built (\n  currentLayout = \"summit\"\n)\n\nmainloop:\n  void layouts[currentLayout].main.update()\n  //void layouts.chromeLike.main.update()\n  //void layouts.summit.main.update()\n  \n  // file dropping\n  if file_dropped != 0 (\n    local data @= open(file_dropped,[3,2,1])\n    local path = data[1] ++ \"/\" ++ data[2] ++ data[3]\n    local document @= shared.document.Document()\n    void document.loadUrl(shared.url.Url(\"local://\" ++ path))\n    void layouts.shared.state.openTabDocument(document)\n    file_dropped = 0\n  )",""],[".osl","script","build @= { built: true, package: {\"name\":\"phosphorus\",\"version\":\"1.0.0a\",\"description\":\"rotur web engine\",\"main\":\"script.osl\",\"dependencies\":{},\"tags\":[],\"include\":[\"./main.rwl\",\"./test.rwl\",\"./sidebartest.rwl\"],\"phosphorus\":{\"layout\":\"chromeLike\",\"hasDevtools\":true},\"scripts\":{\"opaljson-summit\":\"osl ./scripts/opal_summit.osl\",\"opaljson-chromeLike\":\"osl ./scripts/opal_chromeLike.osl\",\"opaljson-reset\":\"osl ./scripts/opal_reset.osl\",\"build-summit\":[\"fpp script opaljson-summit\",\"fpp build\",\"rm build/script-summit.osl\",\"mv build/script.osl build/script-summit.osl\",\"echo \\\"summit build complete!\\\"\"],\"build-chromeLike\":[\"fpp script opaljson-chromeLike\",\"fpp build\",\"rm build/script-chromeLike.osl\",\"mv build/script.osl build/script-chromeLike.osl\",\"echo \\\"chromeLike build complete!\\\"\"],\"build\":[\"fpp script build-summit\",\"fpp script build-chromeLike\",\"fpp script opaljson-reset\"]}} }\nopal_imports = {}\ndef import(path) (\n  switch path (\n\ncase \"./src/assets/settings.rwl\"\n  return \"  root {\\n    frame [Horizontal, color=theme:prim] {\\n      section [id=\\\"sidebar\\\", size=150] {\\n        \\n      },\\n      section {\\n        frame [Vertical] {\\n          section [size=40, padding=10] {\\n            \\\"loading...\\\" [\\n              id=\\\"location\\\",\\n              color=theme:text,\\n              size=12, anchor=\\\"l\\\"\\n            ]\\n          },\\n          section [color=theme:back, rounding_tl=10] {\\n            \\n          }\\n        }\\n      }\\n    },\\n    \\n    script {\\n      event(onload) {\\n        setLocation := (text) ~ {\\n          document.getElement(\\\"location\\\").text = text;\\n        };\\n        setLocation(\\\"bleh\\\");\\n        \\n        sidebar := document.getElement(\\\"sidebar\\\");\\n        \\n        categories := $$brwsr.settings.getCategories();\\n        i := 0;\\n        for (category, categories) {\\n          i += 1;\\n          buttonElem := document.createContainer(\\\"button\\\");\\n          \\n          buttonElem.margin = 7.5;\\n          if (i == 1) {\\n            buttonElem.anchor = \\\"tl\\\";\\n            buttonElem.margin_t = 10;\\n          } else {\\n            buttonElem.margin_t = 0;\\n          }\\n          buttonElem.height = 35;\\n          buttonElem.rounding = 10;\\n          buttonElem.hover_color = theme.seco;\\n          buttonElem.id = \\\"cat_\\\" + category;\\n          \\n          titleElem := document.createTextElement(toTitle(category));\\n          titleElem.color = theme.text;\\n          titleElem.size = 11;\\n          \\n          buttonElem.addChild(titleElem);\\n          script := document.createScript(join(\\n            \\\"setLocation := (text) ~ {document.getElement(\\\\\\\"location\\\\\\\").text = text;};\\\\n\\\",\\n            \\\"event(#\\\" + buttonElem.id + \\\":click) {\\\\n\\\",\\n            \\\"  setLocation(\\\\\\\"\\\" + buttonElem.id + \\\"\\\\\\\");\\\\n\\\",\\n            \\\"}\\\\n\\\"\\n          ));\\n          buttonElem.addChild(script);\\n          \\n          sidebar.addChild(buttonElem);\\n        }\\n      }\\n    }\\n  }\"\n\ncase \"./src/devtools/menus/compiled.osl\"\n  class __imports__c2496c7321897b9bfcdc4b07bd6e8f28 (\n    number offsetX = 0\n    boolean exit = false\n    selectedCode = null\n    \n    object highlighting = {\n      program_flow: {\n        color: #ff4b19,\n        names: [\n          \"label\",\n          \n          \"jump\",\n          \"jumpIf\",\n          \"jumpNotIf\"\n        ]\n      },\n      operations: {\n        color: #ff8119,\n        names: [\n          \"call\",\n          \"unary\",\n          \"binary\",\n          \"prop\",\n          \"len\",\n          \n          \"asivar\",\n          \"asiprop\"\n        ]\n      },\n      values: {\n        color: #52e342,\n        names: [\n          \"null\",\n          \"str\",\n          \"bool\",\n          \"num\",\n          \"func\",\n          \"arr\",\n          \"obj\",\n          \"color\"\n        ]\n      },\n      scope: {\n        color: #00edb6,\n        names: [\n          \"get\",\n          \"decl\",\n          \n          \"newScope\",\n          \"popScope\"\n        ]\n      },\n      stack: {\n        color: #cd27e3,\n        names: [\n          \"pop\",\n          \"dupe\"\n        ]\n      }\n    }\n    \n    object colors = {\n      label: #34eb9b,\n      str: #eba434,\n      num: #34eb3a,\n      bool: #537aed,\n      col: #73a7f0,\n      var: #cf8846\n    }\n    \n    def getInst() (\n      return layouts.shared.state.currentDocument.rtrInst\n    )\n    \n    def topbar() (\n      if self.selectedCode == null (\n        self.topbarHeight = -1\n      ) else (\n        self.topbarHeight = null\n        \n        goto frame.left + 10 0\n        square 15 15 0 0 1\n        if mouse_touching (\n          cursor \"pointer\"\n          if onclick (\n            self.exit = true\n            self.topbarHeight = -1\n          )\n        )\n        icon \"left\" .5 : c#shared.theme.text\n        \n        change_x 15\n        \n        c shared.theme.prim\n        pen \"size\" 2\n        change_y 11\n        pen \"down\"\n        change_y -22\n        pen \"up\"\n        change_y 11\n        \n        change_x 7.5\n        drawLoc(self.selectedCode)\n      )\n    )\n    \n    def update() (\n      if !shared.config.browser.phosphorus.useCompiler (\n        goto 0 0\n        centext \"compiler disabled\" 10 : c#shared.theme.prim\n        return\n      )\n      \n      local inst @= self.getInst()\n      \n      if self.selectedCode == null (\n        // selector screen\n        local y = frame.top\n        \n        if inst.compiled != null (\n          for i inst.compiled.len (\n            local comp @= inst.compiled[i]\n            \n            y -= 15\n            goto frame.left + 7.5 y\n            \n            drawLoc(comp)\n            \n            goto frame.right + 16 y\n            square 10 10 12 : chx#-30 c#shared.theme.prim hover_c#shared.theme.seco\n            if mouse_touching (\n              cursor \"pointer\"\n              if onclick (\n                self.selectedCode @= comp\n              )\n            )\n            icon \"open\" .6 : c#shared.theme.text\n            \n            y -= 15\n            goto 0 y\n            pen \"size\" 2\n            line frame.left 0 frame.right 0 : c#shared.theme.prim\n          )\n        ) else (\n          goto 0 0\n          centext \"nothing compiled\" 10 : c#shared.theme.prim\n        )\n      ) else (\n        self.y = frame.top + frame.scroll\n        local start = self.y\n        self.offsetX = 0\n        drawInstructions(self.selectedCode.body, frame.left + 15)\n        self.height = start - self.y - 10\n      )\n      if self.exit (\n        self.exit = false\n        self.selectedCode = null\n      )\n    )\n    \n    def drawLoc(object comp) (\n      local txt = comp.start.loc ?? \"unknown\"\n      txt += comp.start.ln\n      txt ++= \":\"\n      txt ++= comp.start.char\n      txt += \"-\"\n      txt += comp.end.ln\n      txt ++= \":\"\n      txt ++= comp.end.char\n      text txt 10 : c#shared.theme.text\n    )\n    \n    def drawInstructions(array instructions, number x) (\n      for i instructions.len (\n        if instructions[i] != null (\n          drawInstruction(instructions[i], x, instructions, i)\n        )\n      )\n    )\n    \n    def drawInstruction(object instruction, number x, array instructions, number i) (\n      local height = 25\n      instruction.editorX = x\n      \n      self.y -= height / 2\n      instruction.editorY = self.y\n      \n      if instruction.kind == \"popScope\" (\n        self.offsetX -= 10\n      )\n      \n      if !(self.y - height > frame.top or self.y < frame.bottom) (\n        local fromleft = x + self.offsetX - frame.left\n        goto fromleft / 2 self.y\n        square frame.width - fromleft height 0 0 1\n        if mouse_touching (\n          change_x -2.5\n          square frame.width - fromleft - 15 height - 15 10 : c#shared.theme.prim\n        \n          local corresponding = self.getCorresponding(instructions, i)\n          if corresponding != null (\n            // \"arrow\" | \"point\"\n            local look = \"arrow\"\n            c shared.theme.tert\n            goto x + self.offsetX self.y\n            if look == \"point\" (\n              pen \"size\" 7.5\n              pen \"down\"\n              pen \"up\"\n            )\n            pen \"size\" 2.5\n            pen \"down\"\n            goto x + self.offsetX - 7.5 self.y\n            goto x + self.offsetX - 7.5 corresponding.editorY\n            goto x + self.offsetX corresponding.editorY\n            pen \"up\"\n            if look == \"point\" (\n              pen \"size\" 7.5\n              pen \"down\"\n              pen \"up\"\n            )\n            if look == \"arrow\" (\n              change_x 2\n              pen \"down\"\n              change -4 4\n              change 4 -4\n              change -4 -4\n              pen \"up\"\n            )\n          )\n        )\n        \n        goto x + 5 + self.offsetX self.y\n        \n        c shared.theme.text\n        local categories @= self.highlighting.getValues()\n        for i categories.len (\n          if categories[i].names.contains(instruction.kind) (\n            c categories[i].color\n          )\n        )\n        \n        text instruction.kind 9\n        \n        void self.drawData(instruction)\n      )\n      \n      self.y -= height / 2\n      \n      if instruction.kind == \"func\" (\n        drawInstructions(instruction.body, x + 20)\n      )\n      \n      if instruction.kind == \"newScope\" (\n        self.offsetX += 10\n      )\n    )\n    \n    def drawData(object instruction) (\n      switch instruction.kind (\n        case \"label\"\n          drawLabel(instruction.name)\n          break\n        case \"jump\"; case \"jumpIf\"; case \"jumpNotIf\";\n          drawLabel(instruction.label)\n          break\n        \n        case \"call\"\n          drawArgName(\"args\")\n          drawNum(instruction.args)\n          break\n        case \"unary\"; case \"binary\"\n          drawStr(instruction.op)\n          break\n        \n        case \"str\"\n          drawStr(instruction.data)\n          break\n        case \"num\"\n          drawNum(instruction.data)\n          break\n        case \"bool\"\n          drawBool(instruction.data)\n          break\n        case \"func\"\n          drawArgs(instruction.args)\n          break\n        case \"arr\"\n          drawArgName(\"elems\")\n          drawNum(instruction.elems)\n          break\n        case \"obj\"\n          drawArr(instruction.keys)\n          break\n        case \"color\"\n          drawColor(instruction.data)\n          break\n        \n        case \"get\"\n          drawVar(instruction.name)\n          break\n        case \"decl\"\n          drawVar(instruction.name)\n          break\n        \n        case \"asivar\"\n          if instruction.op != null (\n            drawStr(instruction.op)\n          )\n          drawVar(instruction.name)\n          break\n        case \"asiprop\"\n          if instruction.op != null (\n            drawStr(instruction.op)\n          )\n          break\n        \n        case \"dupe\"\n          drawArgName(\"idx\")\n          drawNum(instruction.i)\n          break\n      )\n    )\n    \n    def drawArgName(string name) (\n      text name 9 : c#shared.theme.text chx#7.5\n      text \"=\" 9 : chx#5\n      change_x -2.5\n    )\n    \n    def drawStr(string str) (\n      text str.JsonStringify() 9 : c#self.colors.str chx#7.5\n    )\n    def drawNum(number num) (\n      text num 9 : c#self.colors.num chx#7.5\n    )\n    def drawBool(boolean bool) (\n      text bool.toStr() 9 : c#self.colors.bool chx#7.5\n    )\n    def drawColor(string col) (\n      text col 9 : c#self.colors.col chx#7.5\n    )\n    def drawArr(array arr) (\n      text arr.join(\" \") 9 : c#shared.theme.text chx#7.5\n    )\n    def drawArgs(array args) (\n      text args.map(a -> \"@\" ++ a.name).join(\" \") 9 : c#self.colors.var chx#7.5\n    )\n    def drawVar(string name) (\n      text \"@\" ++ name 9 : c#self.colors.var chx#7.5\n    )\n    def drawLabel(string name) (\n      text \"#\" ++ name 9 : c#self.colors.label chx#7.5\n    )\n    \n    def getCorresponding(array instructions, number i) (\n      local cur @= instructions[i]\n      \n      if cur.kind == \"newScope\" (\n        local depth = 0\n        while i < instructions.len (\n          i ++\n          local instruction @= instructions[i]\n          if instruction.kind == \"newScope\" (\n            depth ++\n          )\n          if instruction.kind == \"popScope\" (\n            if depth == 0 (\n              return instruction\n            )\n            depth --\n          )\n        )\n      )\n      if cur.kind == \"popScope\" (\n        local depth = 0\n        while i > 0 (\n          i --\n          local instruction @= instructions[i]\n          if instruction.kind == \"newScope\" (\n            if depth == 0 (\n              return instruction\n            )\n            depth ++\n          )\n          if instruction.kind == \"popScope\" (\n            depth --\n          )\n        )\n      )\n      \n      if [\"jump\",\"jumpIf\",\"jumpNotIf\"].contains(cur.kind) (\n        for i instructions.len (\n          local instruction @= instructions[i]\n          if instruction.kind == \"label\" (\n            if instruction.name == cur.label (\n              return instruction\n            )\n          )\n        )\n      )\n    )\n  )\n  return __imports__c2496c7321897b9bfcdc4b07bd6e8f28\ncase \"./src/devtools/menus/storage.osl\"\n  class __imports__968375a74382766e626cb371cd10b43a (\n    \n  )\n  return __imports__968375a74382766e626cb371cd10b43a\ncase \"./src/devtools/menus/network.osl\"\n  class __imports__b4ec205ca81f7630cd7f76511fd744fb (\n    \n  )\n  return __imports__b4ec205ca81f7630cd7f76511fd744fb\ncase \"./src/devtools/menus/console.osl\"\n  class __imports__ac7f1c744ff0d794c130cdf96196926d (\n    def getInst() (\n      return layouts.shared.state.currentDocument.rtrInst\n    )\n    \n    def topbar() (\n      local inst @= self.getInst()\n      \n      goto frame.left + 10 0\n      square 15 15 0 0 1\n      if inst != null (\n        if mouse_touching (\n          cursor \"pointer\"\n          if onclick (\n            inst.console @= []\n          )\n        )\n        c shared.theme.text\n      ) else (\n        if mouse_touching (\n          cursor \"not-allowed\"\n        )\n        c shared.theme.seco\n      )\n      icon \"w 2.5 cutcircle 0 0 10 0 180 line -6 -6 6 6\" .7\n    )\n    \n    def update() (\n      local inst @= self.getInst()\n      \n      local y = frame.top + frame.scroll\n      local start = y\n      \n      for ii inst.console.len (\n        local item @= inst.console[ii]\n        local lines @= item[2].wrapText(frame.width - 10 / 10).split(\"\\n\")\n        local height = lines.len * 20\n        \n        local col = null\n        if item[1] == \"err\" or item[1] == \"repl-err\" (\n          col = #f00\n        )\n        \n        local ly = y\n        local sy = y\n        \n        y -= 5\n        y -= height\n        y -= 5\n        \n        if col != null (\n          frame frame.left y frame.right ly (\n            c col\n            pen \"opacity\" 20\n            pen \"size\" 10000\n            pen \"down\"\n            pen \"up\"\n          )\n        )\n        \n        local offsetX = 5\n        \n        if item[1].startsWith(\"repl\") (\n          goto frame.left + offsetX + 5 ly - 15\n          \n          if item[1] == \"repl-in\" (\n            icon \"right\" .5 : c#shared.theme.text\n          )\n          if item[1] == \"repl-ret\" (\n            icon \"left\" .5 : c#shared.theme.text\n          )\n          if item[1] == \"repl-err\" (\n            icon \"left\" .5 : c#shared.theme.text\n          )\n          offsetX += 20\n        )\n        \n        c shared.theme.text\n        for i lines.len (\n          ly -= 10\n          goto frame.left + offsetX ly - 5\n          text lines[i] 10\n          ly -= 10\n        )\n        \n        pen \"size\" 2 : c#shared.theme.prim\n        \n        goto 0 sy\n        line frame.left 0 frame.right 0\n        \n        goto 0 y\n        line frame.left 0 frame.right 0\n      )\n      \n      // repl\n      y -= 15\n      goto frame.left + 12.5 y\n      icon \"right\" .5 : c#shared.theme.text\n      \n      local inputId = \"devtools_repl_\" ++ inst.ouid\n      goto 12.5 y\n      input frame.width - 35 30 inputId null 0 shared.theme.text : c#shared.theme.back\n      \n      if \"enter\".onKeyDown() and inputs.selected.id == inputId (\n        local inp = inputs[inputId]\n        \n        void inst.console.append([\"repl-in\", inp])\n        \n        promiseData = inp\n        promiseData2 @= inst\n        self.runPromise @= Promise.new(def() -> (\n          local parser @= rtr.ast.Parser(\"event(onload){return(\" ++ promiseData ++ \");}\")\n          self.ast @= parser.parse()\n          self.mod @= rtr.main.Module(self.ast)\n          void rtr.apis.main.addToMod(layouts.shared.state.currentDocument, self.mod)\n          void promiseData2.addModule(self.mod)\n          local ret @= mod.runEventRaw({\n            name: \"onload\"\n          }, {})\n          return ret\n        ))\n        \n        inputs[inputId] = \"\"\n      )\n      \n      if self.runPromise != null (\n        local ret @= self.runPromise.worker.return\n        if ret != null (\n          void inst.console.append([\"repl-ret\", ret.stringify(true)])\n          self.runPromise = null\n        )\n      )\n      \n      y -= 15\n      \n      self.height = start - y - 10\n    )\n  )\n  return __imports__ac7f1c744ff0d794c130cdf96196926d\ncase \"./src/devtools/menus/elements.osl\"\n  class __imports__7de0f89117b2e081473955ae82bcf430 (\n    number indent = 20\n    \n    number x = 0\n    number y = 0\n    \n    number maxX = 0\n    \n    def drawElements(array elements) (\n      for i elements.len (\n        if elements[i] != null (\n          drawElement(elements[i])\n        )\n        if i < elements.len (\n          text \",\" 10\n        )\n      )\n    )\n    \n    def drawElement(object element) (\n      if element.children != null or element.kind == \"script\" (\n        self.y -= 15\n        goto 0 self.y\n        \n        element.dvt_open ??= false or true\n        \n        goto self.x self.y\n        square 20 20 0 0 1 : c#fff\n        if mouse_touching (\n          cursor \"pointer\"\n          if onclick (\n            element.dvt_open = !element.dvt_open\n          )\n        )\n        icon element.dvt_open ? \"down\" \"right\" .5 : c#shared.theme.text\n        \n        text element.blockName ?? element.name 10 : chx#15\n        if mouse_touching (\n          cursor \"pointer\"\n          devtools.main.hoveredElement = element.elemI\n          if onclick (\n            element.dvt_open = !element.dvt_open\n          )\n        )\n        \n        drawHeader(element.header)\n        \n        self.y -= 15\n        \n        if element.dvt_open (\n          text \"{\" 10 : chx#10\n          self.maxX = max(self.maxX, x_position)\n          self.x += self.indent\n          \n          if element.kind == \"script\" (\n            local content = element.body\n            local lines @= content.split(\"\\n\")\n            local line_height = 25\n            local height = lines.len - 1 * line_height + 5\n            \n            local cy = self.y - 2.5\n            self.y -= height\n            \n            for i lines.len (\n              cy -= line_height / 2\n              \n              goto self.x cy\n              \n              //self.maxX = max(self.maxX, x_position + (lines[i].len * 10))\n              //text lines[i].trimText(frame.right - x_position - 17.5 / 8) 10 : c#shared.theme.text\n              text lines[i] 10 : c#shared.theme.text\n              \n              cy -= line_height / 2\n            )\n          ) else (\n            drawElements(element.children)\n          )\n          \n          self.x -= self.indent\n          \n          self.y -= 15\n          goto self.x - 5 self.y\n          text \"}\" 10\n          self.y -= 15\n        ) else (\n          if element.kind == \"script\" (\n            text \"{\" 10 : chx#10\n            drawTooLong() : chx#10\n            text \"}\" 10 : chx#10\n          ) else (\n            text \"{\" 10 : chx#10\n            drawMiniChildren(element.children) : chx#10\n            text \"}\" 10 : chx#10\n          )\n          self.maxX = max(self.maxX, x_position)\n        )\n      ) else if element.kind == \"element\" (\n        self.y -= 15\n        goto self.x self.y\n        drawValue(element.value)\n        drawHeader(element.header)\n        local s = x_position\n        self.maxX = max(self.maxX, x_position)\n        local w = x_position - self.x\n        goto x_position + self.x / 2 self.y\n        square w 20 0 0 1\n        if mouse_touching (\n          devtools.main.hoveredElement = element.elemI\n        )\n        goto s self.y\n        self.y -= 15\n      ) else if element.kind == \"icon\" (\n        self.y -= 15\n        goto self.x self.y\n        text \"Icon\" 10\n        drawHeader(element.header)\n        self.maxX = max(self.maxX, x_position)\n        self.y -= 15\n      )\n    )\n    \n    def drawHeader(object header) (\n      if header.flags.len == 0 and header.pairs.len == 0 (\n        return\n      )\n      \n      change_x 7.5\n      text \"[\" 10\n      for i header.flags.len (\n        local flag = header.flags[i]\n        text flag 8\n        if i < header.flags.len or header.pairs.len > 0 (\n          text \", \" 8\n        )\n      )\n      \n      for i header.pairs.len (\n        local pair @= header.pairs[i]\n        text pair[1] 10\n        text \"=\" 8\n        drawValue(pair[2])\n        if i < header.pairs.len (\n          text \", \" 8\n        )\n      )\n      text \"]\" 10\n    )\n    \n    def drawValue(object value) (\n      switch value.type (\n        case \"str\"\n          text value.value.JsonStringify() 10\n          break\n        case \"num\"; case \"color\"\n          text value.value 10\n          break\n        case \"percentage\"\n          text value.value.toStr() ++ \"%\" 10\n          break\n      )\n    )\n    \n    def drawMiniChildren(array children) (\n      if children.len == 0 (\n        change_x -20\n        return\n      )\n      \n      change_x 5\n      for i children.len (\n        drawMiniChild(children[i])\n        if i < children.len (\n          text \", \" 8\n        )\n      )\n      change_x 5\n      \n      change_x -20\n    )\n    \n    def drawMiniChild(object element) (\n      if element.children != null or element.kind == \"script\" (\n        text element.blockName ?? element.name 7\n        text \"{\" 7 : chx#10\n        drawTooLong()\n        text \"}\" 7 : chx#20\n      ) else (\n        text \"Element\" 7\n      )\n    )\n    \n    def drawTooLong() (\n      text \"...\" 8 : chx#5\n      change_x -15\n    )\n    \n    def update() (\n      local document @= layouts.shared.state.currentDocument\n      local elements @= document.rwlInst.elements\n      if typeof(elements) != \"array\" (\n        elements @= []\n      )\n      \n      local s = frame.scroll_h * -1\n      self.x = frame.left + s + 15\n      local startX = self.x\n      self.y = frame.top + frame.scroll\n      local startY = self.y\n      \n      self.width = 0\n      self.maxX = 0\n      \n      if elements != null (\n        drawElements(elements)\n      )\n      \n      //self.width = self.maxX - startX\n      self.width = self.maxX - startX\n      self.height = startY - self.y + 5\n    )\n  )\n  return __imports__7de0f89117b2e081473955ae82bcf430\ncase \"./src/devtools/rightclick.osl\"\n  class __imports__0598a8fc1c085cefe2171384b023fe8b (\n    array topbar_more = [\n      [\"Dock\",\n        {\"left\": def() -> (\n          void shared.settings.set(\"devtools\", \"dockside\", \"l\")\n        )},\n        {\"right\": def() -> (\n          void shared.settings.set(\"devtools\", \"dockside\", \"r\")\n        )}\n      ]\n    ]\n  )\n  return __imports__0598a8fc1c085cefe2171384b023fe8b\ncase \"./src/devtools/topbar.osl\"\n  class __imports__3261b0e52c0051dec0dc6394c943d033 (\n    tabs_scroll = 0\n    tabs_width = 0\n    \n    def update() (\n      square frame.width frame.height 0 0 1\n      if mouse_touching (\n        self.tabs_scroll += scroll.x.velocity + scroll.y.velocity * -1.5 * scroll.multiplier\n      )\n      \n      self.tabs_scroll = min(self.tabs_scroll, self.tabs_width - frame.width)\n      self.tabs_scroll = max(self.tabs_scroll, 0)\n      \n      local x = frame.left - self.tabs_scroll\n      local start = x\n      local menus @= devtools.menus.getEntries()\n      for i menus.len (\n        local menu @= menus[i]\n        \n        local title = menu[1].toTitle()\n        local w = title.len * 8 + 10\n        \n        x += w / 2\n        \n        goto x 0\n        square w - 10 10 10 0 1\n        c devtools.main.menu == menu[1] ? shared.theme.seco shared.theme.prim\n        if mouse_touching (\n          c shared.theme.tert\n          cursor \"pointer\"\n          if onclick (\n            void shared.settings.set(\"devtools\", \"menu\", menu[1])\n          )\n        )\n        pen \"size\" 2\n        line w / -2 -11 w / 2 -11\n        centext title 8 : c#shared.theme.text\n        \n        x += w / 2\n      )\n      self.tabs_width = x - start\n    )\n  )\n  return __imports__3261b0e52c0051dec0dc6394c943d033\ncase \"./src/devtools/main.osl\"\n  class __imports__87f5572a1b07abb6f61e525f0557da7a (\n    string anchor = \"r\"\n    number width = 350\n    boolean open = false\n    \n    number saveWidth = 350\n    number resizingEdge = 0\n    \n    hoveredElement = 0\n    \n    string menu = \"console\"\n    \n    def alwaysUpdate() (\n      self.hoveredElement = 0\n    )\n    \n    def update(array area, array rawArea) (\n      goto rwl.area.centerX(area) rwl.area.centerY(area)\n      square rwl.area.width(area) - 10 rwl.area.height(area) - 10 10 : c#shared.theme.back\n      \n      local h = 25\n      frame area[1] area[4] area[3] area[4] - h (\n        goto 0 -5\n        square frame.width - 10 frame.height 10 : c#shared.theme.prim\n        \n        goto frame.right - 12.5 0\n        icon \"more-vertical\" .5 : c#shared.theme.text\n        if mouse_touching (\n          cursor \"pointer\"\n          if onclick (\n            local p @= Promise.new(() -> (\n              while mouse_down (\n                defer\n              )\n              open_rightclick devtools.rightclick.topbar_more\n            ))\n          )\n        )\n      )\n      frame area[1] area[4] area[3] - 25 area[4] - h (\n        void devtools.topbar.update()\n      )\n      \n      if mouse_y > area[2] and mouse_y < area[4] (\n        if anchor == \"r\" and abs(mouse_x - area[1]) < 5 (\n          cursor \"col-resize\"\n          goto mouse_x mouse_y\n          square 100 100 0 0 1\n          if onclick (\n            self.resizingEdge = 1\n          )\n        )\n        if anchor == \"l\" and abs(mouse_x - area[3]) < 5 (\n          cursor \"col-resize\"\n          goto mouse_x mouse_y\n          square 100 100 0 0 1\n          if onclick (\n            self.resizingEdge = 3\n          )\n        )\n      )\n      \n      if !mouse_down (\n        self.resizingEdge = 0\n      )\n      \n      if self.resizingEdge != 0 (\n        self.width = abs(mouse_x - area[4 - self.resizingEdge])\n      )\n      self.width = min(self.width, rwl.area.width(rawArea) - 200)\n      self.width = max(self.width, 200)\n      \n      local menu @= devtools.menus[self.menu]\n      \n      c shared.theme.prim\n      local topbarH = 0\n      if menu.topbar != null (\n        topbarH = menu.topbarHeight ?? 25\n        frame area[1] area[4] - h area[3] area[4] - h - topbarH (\n          void menu.topbar()\n        )\n        local w = rwl.area.width(area)\n        goto rwl.area.centerX(area) area[4] - h - topbarH\n        pen \"size\" 2\n        line w / -2 -1 w / 2 -1 : c#shared.theme.prim\n        topbarH += 1\n      )\n      \n      c shared.theme.prim\n      local bottombarH = 0\n      if menu.bottombar != null (\n        bottombarH = menu.bottombarHeight ?? 25\n        frame area[1] area[4] - h area[3] area[4] - h - bottombarH (\n          void menu.bottombar()\n        )\n        local w = rwl.area.width(area)\n        goto rwl.area.centerX(area) area[2] + bottombarH\n        pen \"size\" 2\n        line w / -2 1 w / 2 1 : c#shared.theme.prim\n        bottombarH += 1\n      )\n      \n      c shared.theme.prim\n      frame area[1] area[4] - h - topbarH area[3] area[2] + bottombarH [menu.width,menu.height] \"devtools_\" ++ self.menu (\n        if menu != null (\n          if menu.update != null (\n            void menu.update()\n          )\n        ) else (\n          goto 0 0\n          centext \"no open devtools menu\" 9 : c#shared.theme.prim\n        )\n      )\n    )\n  )\n  return __imports__87f5572a1b07abb6f61e525f0557da7a\ncase \"./src/layouts/summit/topbar.osl\"\n  class __imports__6a477e7780a631dfc33d414269cd6008 (\n    def update(array area) (\n      goto rwl.area.centerX(area) rwl.area.centerY(area)\n      square rwl.area.width(area) - 10 rwl.area.height(area) - 10 10 : c#shared.theme.back\n      \n      local btns @= layouts.shared.topbar.defaultButtons\n      void layouts.shared.topbar.winButtons(btns, false)\n      \n      local titlebarX = max(area[1], window.left + 30)\n      goto titlebarX + 10 rwl.area.centerY(area)\n      if layouts.shared.state.currentDocument != null (\n        local icn = layouts.shared.state.currentDocument.getIcon()\n        if icn != null (\n          icon icn 1 : c#fff chx#7.5\n          change_x 17.5\n        )\n        text layouts.shared.state.currentDocument.getTitle() 10 : c#shared.theme.text\n      )\n      \n      frame area[1] area[4] titlebarX area[2] (\n        goto 0 0\n        square frame.width - 5 25 0 0 1\n        if mouse_touching (\n          cursor \"pointer\"\n          if onclick (\n            layouts.summit.sidebar.open = true\n          )\n        )\n        icon \"right\" .6 : c#shared.theme.text chx#5\n      )\n    )\n  )\n  return __imports__6a477e7780a631dfc33d414269cd6008\ncase \"./src/layouts/summit/sidebar.osl\"\n  class __imports__3dfd082eaa91cc9b8340f13c6baac410 (\n    open_width = 250\n    \n    width = 200\n    tar_width = open_width\n    open = true\n    \n    def update(array area) (\n      goto rwl.area.centerX(area) rwl.area.centerY(area)\n      square rwl.area.width(area) - 20 rwl.area.height(area) - 20 10 : c#shared.theme.back\n      \n      frame area[1] + 10 area[4] - 10 area[3] - 10 area[4] - 35 (\n        //square 1000 1000 1000 : c#fff\n        goto frame.right - 12.5 0\n        square 20 20 0 0 1 : c#fff\n        if mouse_touching (\n          cursor \"pointer\"\n          if onclick (\n            self.open = false\n          )\n        )\n        goto frame.right - 12.5 0\n        icon \"left\" .6 : c#shared.theme.text\n        \n        goto frame.left + 12.5 0\n        square 20 20 0 0 1 : c#fff\n        if mouse_touching (\n          cursor \"pointer\"\n          if onclick (\n            void layouts.shared.state.openEmptyTab()\n          )\n        )\n        icon \"add\" .6 : c#shared.theme.text\n      )\n      \n      void layouts.shared.urlbar.update([\n        area[1] + 10,\n        area[4] - 40 - 32.5,\n        area[3] - 10,\n        area[4] - 40 - 2.5\n      ])\n      \n      c shared.theme.prim\n      frame area[1] + 5 area[4] - 40 - 35 area[3] - 5 area[2] + 5 self.height \"browser_sidebar\" (\n        local y = frame.top + frame.scroll\n        local startY = y\n        \n        for i layouts.shared.state.tabs.len (\n          local tab @= layouts.shared.state.tabs[i]\n          \n          local title = tab.document.getTitle()\n          local icon = tab.document.getIcon()\n          y -= 20\n          \n          local close_touching = false\n          \n          goto frame.right - 22.5 y\n          square 15 15 0 0 1\n          local close_touching = mouse_touching\n          \n          goto 0 y\n          c layouts.shared.state.currentTab == i ? shared.theme.seco shared.theme.prim\n          square frame.width - 25 20 15 : hover_c#shared.theme.tert\n          if mouse_touching and !close_touching (\n            cursor \"pointer\"\n            if onclick (\n              void layouts.shared.state.selectTab(i)\n            )\n          )\n          square frame.width - 25 20 10 : c#shared.theme.back\n          \n          goto frame.left + 15 y\n          if icon != null (\n            icon icon .9 : c#user.theme.text chx#7.5\n            change_x 15\n          )\n          text title.trimText(frame.right - x_position / 9 - 4) 9 : c#shared.theme.text tooltip#title\n          \n          goto frame.right - 22.5 y\n          square 15 15 0 0 1\n          if mouse_touching (\n            cursor \"pointer\"\n            if onclick (\n              void layouts.shared.state.closeTab(i)\n              i --\n            )\n          )\n          icon \"close\" .5\n          \n          y -= 20\n        )\n      )\n      self.height = startY - y - 7.5\n      \n      // clicking on the left side of the window opens the sidebar\n      if self.width < 25 (\n        goto window.left 0\n        square 20 window.height 0 0 1\n        if mouse_touching (\n          cursor \"pointer\"\n          if onclick (\n            self.open = true\n          )\n        )\n      )\n      \n      self.tar_width = self.open ? self.open_width 5\n      self.width += self.tar_width - self.width * min(delta_time, 0.02) * 10\n    )\n  )\n  return __imports__3dfd082eaa91cc9b8340f13c6baac410\ncase \"./src/layouts/summit/main.osl\"\n  class __imports__70bd3fa18cef0c20ca734751135b82d8 (\n    def init() (\n      void shared.document.init()\n      void layouts.shared.state.init()\n    )\n    \n    def update() (\n      void shared.theme.load()\n      void shared.input.update()\n      \n      window.show()\n      window_colour = #000\n      \n      glass:frame window.left window.top window.right window.bottom; frame \"clear\"\n      \n      void layouts.shared.state.resetDragbox()\n      \n      layouts.shared.state.dragbox[1][3] = max(layouts.summit.sidebar.width, 30)\n      \n      void layouts.summit.sidebar.update([\n        window.left + layouts.summit.sidebar.width - layouts.summit.sidebar.open_width,\n        window.bottom,\n        window.left + layouts.summit.sidebar.width,\n        window.top\n      ])\n      \n      void layouts.summit.topbar.update([\n        window.left + layouts.summit.sidebar.width,\n        window.top - 37.5,\n        window.right - 5,\n        window.top - 5\n      ])\n      \n      void layouts.shared.view.render([\n        window.left + layouts.summit.sidebar.width,\n        window.bottom + 5,\n        window.right - 5,\n        window.top - 42.5\n      ])\n      \n      void layouts.shared.state.applyDragbox()\n    )\n  )\n  return __imports__70bd3fa18cef0c20ca734751135b82d8\ncase \"./src/layouts/chromeLike/topbar.osl\"\n  class __imports__0f6f8e5da8ad7dfb8f0386ba0c4b7fd4 (\n    def tabs() (\n      local space = window.width - 100 - 17.5 - 15\n      \n      local hovered = false\n      \n      local x = 0\n      local tabMax = space / layouts.shared.state.tabs.len - 5\n      for i layouts.shared.state.tabs.len (\n        local tab @= layouts.shared.state.tabs[i]\n        \n        local title = tab.document.getTitle()\n        local icon = tab.document.getIcon()\n        \n        local pad = 15 + 27.5\n        if icon != null (\n          pad += 20\n        )\n        //local width = title.len * 9 + pad\n        local width = 200\n        //width = max(width, 200)\n        width = min(width, tabMax)\n        \n        local lx = x\n        x += 2.5 + (width / 2)\n        \n        loc 2 2 x + (width / 2) - 17.5 -20\n        square 15 15 0 0 1\n        local close_touching = mouse_touching\n        \n        loc 2 2 x -20\n        \n        square width - 17.5 17.5 15 0 1\n        c mouse_touching ? shared.theme.seco shared.theme.prim\n        if layouts.shared.state.currentTab == i (\n          c shared.theme.tert\n        )\n        square width - 17.5 17.5 15\n        \n        if mouse_touching and !close_touching (\n          layouts.shared.state.dragbox @= [\n            [2, 2, lx, 0],\n            [2, 2, lx + width, -20]\n          ]\n          hovered = true\n          \n          cursor \"pointer\"\n          if onclick (\n            void layouts.shared.state.selectTab(i)\n          )\n        )\n        \n        square width - 17.5 17.5 10 : c#shared.theme.prim\n        \n        if icon != null (\n          lx += 20\n          loc 2 2 lx -20\n          icon icon .9 : c#user.theme.text\n          lx += 5\n        )\n        lx += 10\n        \n        loc 2 2 lx -20\n        text title.trimText(width - pad / 9) 9 : c#shared.theme.text tooltip#title\n        \n        lx += 5\n        loc 2 2 x + (width / 2) - 17.5 -20\n        square 15 15 0 0 1\n        if mouse_touching (\n          cursor \"pointer\"\n          if onclick (\n            void layouts.shared.state.closeTab(i)\n            i --\n          )\n        )\n        icon \"close\" .5\n        \n        x += 2.5 + (width / 2)\n      )\n      \n      x += 17.5\n      loc 2 2 x -20\n      square 17.5 17.5 15 : c#shared.theme.prim hover_c#shared.theme.seco\n      if mouse_touching (\n        cursor \"pointer\"\n        if onclick (\n          void layouts.shared.state.openEmptyTab()\n        )\n      )\n      icon \"add\" .6 : c#user.theme.text\n      x += 20\n      \n      loc -2 2 -90 -20\n      line 0 -20 0 20 : c#shared.theme.prim w#1\n      \n      if !hovered (\n        layouts.shared.state.dragbox[1][3] += x\n      )\n    )\n  )\n  return __imports__0f6f8e5da8ad7dfb8f0386ba0c4b7fd4\ncase \"./src/layouts/chromeLike/main.osl\"\n  class __imports__34355e72215dbff81e1963b1534949ee (\n    def init() (\n      void shared.document.init()\n      void layouts.shared.state.init()\n    )\n    \n    def update() (\n      void shared.theme.load()\n      void shared.input.update()\n    \n      window.show()\n      window_colour = shared.theme.back\n      \n      void layouts.shared.state.resetDragbox()\n    \n      local btns @= layouts.shared.topbar.defaultButtons\n      void layouts.shared.topbar.winButtons(btns, false)\n      \n      void layouts.chromeLike.topbar.tabs()\n      \n      void layouts.shared.urlbar.update([\n        window.left,\n        window.top - 45 - 30,\n        window.right,\n        window.top - 44\n      ])\n      \n      void layouts.shared.view.render([\n        window.left,\n        window.bottom,\n        window.right,\n        window.top - 45 - 32.5\n      ])\n      \n      void layouts.shared.state.applyDragbox()\n    )\n  )\n  return __imports__34355e72215dbff81e1963b1534949ee\ncase \"./src/layouts/shared/view.osl\"\n  class __imports__5228a5cd2bf6a46e3a340119920c2e17 (\n    def render(array area) (\n      local contentArea @= rwl.area.copy(area)\n      \n      if devtools.main.open (\n        local devtoolsData @= devtools.main ?? { width: 0, anchor: \"l\" }\n        \n        local devtoolsArea @= rwl.area.copy(area)\n        switch devtoolsData.anchor (\n          case \"l\"\n            contentArea[1] += devtoolsData.width\n            devtoolsArea[3] = contentArea[1]\n            break\n          case \"r\"\n            contentArea[3] -= devtoolsData.width\n            devtoolsArea[1] = contentArea[3]\n            break\n        )\n      \n        devtoolsArea[1] += 5\n      )\n      \n      if layouts.shared.state.currentDocument != null (\n        void layouts.shared.state.currentDocument.checkResp()\n        void layouts.shared.state.currentDocument.render(contentArea)\n      )\n      \n      if devtools.main != null (\n        void devtools.main.alwaysUpdate()\n      )\n      if devtools.main.open (\n        void devtools.main.update(devtoolsArea, area)\n      )\n    )\n  )\n  return __imports__5228a5cd2bf6a46e3a340119920c2e17\ncase \"./src/layouts/shared/urlbar.osl\"\n  class __imports__e1f3f683350eb46be2bb39ac4a8762b8 (\n    inputId = \"browser_url\"\n    \n    def update(array area) (\n      local defaultText = \"blehh\"\n      \n      goto rwl.area.centerX(area) rwl.area.centerY(area) + 2.5\n      \n      local w = rwl.area.width(area) - 15\n      local h = rwl.area.height(area) - 0\n      \n      square w - 5 h - 18 15 : c#shared.theme.prim\n      input w h - 5 self.inputId defaultText 0 shared.theme.text\n      \n      if inputs.selected.id == self.inputId (\n        if \"enter\".onKeyDown() (\n          void self.goto()\n        )\n      )\n      \n      //void shared.graphics.box(area, #f00)\n    )\n    \n    def goto() (\n      local url = inputs[self.inputId]\n      \n      url @= shared.url.Url(url)\n      \n      if layouts.shared.state.tabs.len == 0 (\n        void layouts.shared.state.openEmptyTab()\n      )\n      \n      local tab @= layouts.shared.state.tabs[layouts.shared.state.currentTab]\n      void tab.redirect(url)\n    )\n  )\n  return __imports__e1f3f683350eb46be2bb39ac4a8762b8\ncase \"./src/layouts/shared/topbar.osl\"\n  class __imports__bce8e403422ca1f602a36f77e9c471c6 (\n    array defaultButtons = [\n      {\n        icon: \"close\",\n        click: window.close\n      },\n      {\n        icon: \"down\",\n        click: window.minimise\n      },\n      {\n        icon: \"maximise\",\n        click: window.fullscreen\n      }\n    ]\n    \n    def winButtons(array buttons, boolean background) (\n      if background (\n        local w = buttons.len * 25\n        \n        loc -2 2 w / -2 - 7.5 -20\n        square w - 5 18 10 : c#shared.theme.prim\n      )\n      \n      loc -2 2 -20 -20\n      change_x 25\n      for i buttons.len (\n        local button @= buttons[i]\n        \n        c shared.theme.text\n        icon button.icon 0.6 * (button.icon_size ?? 1) : hover_size#1.1 chx#-25\n        if mouse_touching (\n          cursor \"pointer\"\n          if onclick (\n            void button.click()\n          )\n        )\n      )\n    )\n  )\n  return __imports__bce8e403422ca1f602a36f77e9c471c6\ncase \"./src/layouts/shared/utils.osl\"\n  class __imports__bd7a86c2700e28469496d9f67248c0b2 (\n    def getContentArea() (\n      return [\n        window.left,\n        window.bottom,\n        window.right,\n        window.top - 50\n      ]\n    )\n  )\n  return __imports__bd7a86c2700e28469496d9f67248c0b2\ncase \"./src/layouts/shared/state.osl\"\n  class __imports__d1763f06b30a5d5d9c10608cf0f00c3e (\n    debug = false\n    \n    def init() (\n      void self.updateTab()\n      void self.selectTab(1)\n      \n      self.tabs @= []\n    )\n    \n    def resetDragbox() (\n      self.dragbox @= [[2,2,0,0],[-2,2,-90,-40]]\n    )\n    \n    def applyDragbox() (\n      window.setDragbox(self.dragbox[1], self.dragbox[2])\n      \n      if self.debug (\n        c #fff\n        loc self.dragbox[1][1] self.dragbox[1][2] self.dragbox[1][3] self.dragbox[1][4]\n        pen \"down\"\n        loc self.dragbox[2][1] self.dragbox[2][2] self.dragbox[2][3] self.dragbox[2][4]\n        pen \"up\"\n      )\n    )\n    \n    def openTabDocument(object document) (\n      local tab @= shared.tab.Tab(document)\n      void self.tabs.append(tab)\n      void self.selectTab(self.tabs.len)\n    )\n    \n    def openEmptyTab() (\n      void self.openTabDocument(shared.document.Document())\n    )\n    \n    def closeTab(number index) (\n      void self.tabs[index].document.close()\n      void self.tabs.delete(index)\n      \n      if index < self.currentTab (\n        self.currentTab --\n      )\n      \n      void self.selectTab(self.currentTab)\n    )\n    \n    def selectTab(number index) (\n      self.currentTab @= index\n      void self.updateTab()\n    )\n    \n    def updateTab() (\n      if self.currentDocument != null (\n        self.currentDocument.focused = false\n      )\n      self.currentDocument @= self.tabs[self.currentTab].document\n      if self.currentDocument.url != null (\n        inputs[layouts.shared.urlbar.inputId] = self.currentDocument.url.format()\n      ) else (\n        inputs[layouts.shared.urlbar.inputId] = \"\"\n      )\n      if inputs.selected.id == layouts.shared.urlbar.inputId (\n       input \"unfocus\"\n      )\n      \n      if self.currentDocument != null (\n        self.currentDocument.focused = true\n        \n        // fix for while workers be goofy\n        void self.currentDocument.createWorker()\n      )\n      //self.currentDocument ??= shared.document.Document()\n    )\n  )\n  return __imports__d1763f06b30a5d5d9c10608cf0f00c3e\ncase \"./src/assets/home.rwl\"\n  return \"  root {\\n    \\\"hi\\\"\\n  }\"\n\ncase \"./src/assets/empty.rwl\"\n  return \"  root {\\n    \\\"grahhh\\\"\\n  }\"\n\ncase \"./src/net/response.osl\"\n  class __imports__f336b41d073413cbdabb122f71c530f0 (\n    class Response (\n      isValid = false\n      \n      def init(object url, string content) (\n        self.url @= url\n        self.content = content\n        \n        self.isFinished = true\n      )\n    )\n    \n    class NoResponse extends Response (\n      \n    )\n    \n    class ValidResponse extends Response (\n      isValid = true\n      \n      def init(object url) (\n        self.url @= url\n        \n        self.isFinished = false\n      )\n      \n      def update() (\n        if self.isFinished (\n          return\n        )\n        local out @= self.fetch()\n        if out != null (\n          self.isFinished = true\n          self.content @= out\n        )\n      )\n    )\n  )\n  return __imports__f336b41d073413cbdabb122f71c530f0\ncase \"./src/net/fetch.osl\"\n  class __imports__d974ce5692d372884f5c4f8f8bf1ab18 (\n    def url(object url) (\n      if url.scheme == \"local\" (\n        //local f @= open(url.domain_name).toStr()\n        // fpp import instead (goes into output)\n        local f @= import(url.domain_name).toStr()\n        local r @= net.response.ValidResponse(url)\n        r.fetch @= def() -> (\n          self.content = self.f\n          self.isFinished = true\n        )\n        r.f @= f\n        return r\n      )\n      if url.scheme == shared.config.url.browser_scheme (\n        local r @= net.response.ValidResponse(url)\n        local page @= browserPages[url.domain_name]\n        if typeof(page) == \"string\" (\n          r.fetch @= def() -> (\n            self.content = self.data\n            self.isFinished = true\n          )\n          r.data @= page\n        ) else (\n          r.fetch @= page ?? (() -> ())\n        )\n        return r\n      )\n    \n      local servers @= shared.config.net.servers\n      local server @= servers[url.scheme]\n      \n      if server == null (\n        local r @= net.response.NoResponse(url, \"scheme '\" ++ url.scheme ++ \"' not found\")\n        return r\n      )\n      \n      local resource = url.domain_top\n      resource ++= \"/\"\n      if url.domain_sub != null (\n        resource ++= url.domain_sub\n        resource ++= \".\"\n      )\n      resource ++= url.domain_name\n      if url.resource != null (\n        resource ++= \"/\"\n        resource ++= url.resource\n      )\n      \n      local tld = server.tlds[url.domain_top]\n      \n      if tld == null (\n        local r @= net.response.NoResponse(url, \"tld '\" ++ url.domain_top ++ \"' not found\")\n        return r\n      )\n      \n      local realUrl = tld ++ \"/\" ++ resource\n      \n      local r @= net.response.ValidResponse(url)\n      r.fetch @= def() -> (\n        local o = self.realUrl.getAsync()\n        if o != \"Loading\" and o != \"404: Not Found\" (\n          self.content = o\n          self.isFinished = true\n        )\n      )\n      r.realUrl = realUrl\n      \n      return r\n    )\n  )\n  return __imports__d974ce5692d372884f5c4f8f8bf1ab18\ncase \"./src/shared/save.osl\"\n  class __imports__adb9c40aa8851930265661f644c37fb1 (\n    def setName(string name) (\n      save name \"set_directory\"\n    )\n    \n    def exists(string fileName) (\n      return fileName.saveExists()\n    )\n    \n    def get(string fileName) (\n      if !self.exists(fileName) (\n        throw fileName ++ \"does not exist\"\n      )\n    \n      return fileName.saveGet().toStr()\n    )\n    \n    def set(string fileName, string data) (\n      save fileName \"set\" data\n    )\n  )\n  return __imports__adb9c40aa8851930265661f644c37fb1\ncase \"./src/shared/settings.osl\"\n  class __imports__b9d870002d9a38c65f33053e346a5da3 (\n    object entries = {\n      devtools: {\n        dockside: {\n          type: \"string\",\n          desc: \"what side devtools is anchored to\",\n          default: \"r\",\n          applySetting: def(string value) -> (\n            devtools.main.anchor = value\n          )\n        },\n        open: {\n          type: \"boolean\",\n          desc: \"if devtools is open or not\",\n          default: false,\n          applySetting: def(boolean value) -> (\n            devtools.main.open = value\n          )\n        },\n        menu: {\n          type: \"string\",\n          desc: \"current open devtools menu\",\n          default: \"console\",\n          applySetting: def(string value) -> (\n            devtools.main.menu = value\n          )\n        }\n      },\n      net: {\n        offline: {\n          type: \"boolean\",\n          desc: \"disables networking\",\n          default: false\n        }\n      }\n    }\n    \n    object _data = {}\n    \n    def load() (\n      local br @= shared.config.browser\n      void shared.save.setName(br.name ++ \"@\" ++ br.save_developer)\n      if !shared.save.exists(\"settings.json\") (\n        void self.write()\n      )\n      self._data @= self.deserialize(shared.save.get(\"settings.json\"))\n      void self.applySettings()\n      void self.write()\n    )\n    \n    def write() (\n      void shared.save.set(\"settings.json\", self.serialize())\n    )\n    \n    def get(string category, string entry) (\n      return self._data[category][entry]\n    )\n    def set(string category, string entry, value) (\n      local entryData @= self.entries[category][entry]\n      if entryData == null (\n        throw \"setting\" + category ++ \"/\" ++ entry + \"doesnt exist\"\n      )\n      \n      if entryData.type != typeof(value) (\n        throw \"expected\" + entry.type + \"for\" + category ++ \"/\" ++ entry + \"but got\" + typeof(value)\n      )\n      self._data[category][entry] @= value\n      void self.write()\n      void self.applySettings()\n    )\n    \n    def applySettings() (\n      local categoryData @= self.entries.getEntries()\n      for categoryI categoryData.len (\n        local category @= categoryData[categoryI]\n        local entryData @= category[2].getEntries()\n        for entryI entryData.len (\n          local entry @= entryData[entryI]\n          local value = self._data[category[1]][entry[1]] ?? entry[2].default\n          if entry[2].applySetting != null (\n            void entry[2].applySetting(value)\n          )\n        )\n      )\n    )\n    \n    def serialize() (\n      local out @= {}\n      local categoryData @= self.entries.getEntries()\n      for categoryI categoryData.len (\n        local category @= categoryData[categoryI]\n        out[category[1]] @= {}\n        local entryData @= category[2].getEntries()\n        for entryI entryData.len (\n          local entry @= entryData[entryI]\n          local value = self._data[category[1]][entry[1]] ?? entry[2].default\n          out[category[1]][entry[1]] @= value\n        )\n      )\n      return out.JsonStringify()\n    )\n    def deserialize(string data) (\n      local raw @= data.JsonParse()\n      \n      local out @= {}\n      local categoryData @= self.entries.getEntries()\n      for categoryI categoryData.len (\n        local category @= categoryData[categoryI]\n        out[category[1]] @= {}\n        local entryData @= category[2].getEntries()\n        for entryI entryData.len (\n          local entry @= entryData[entryI]\n          local value = raw[category[1]][entry[1]] ?? entry[2].default\n          out[category[1]][entry[1]] @= value\n        )\n      )\n      return out\n    )\n  )\n  return __imports__b9d870002d9a38c65f33053e346a5da3\ncase \"./src/shared/input.osl\"\n  class __imports__f477f9b400e164d253c3bfeb6a54c186 (\n    boolean rwlLeftClick = false\n    \n    def reset() (\n      self.rwlLeftClick = false\n    )\n    \n    def update() (\n      self.leftClick = mouse_left and !self.leftDown\n      self.leftDown = mouse_left\n      if self.leftClick (\n        self.rwlLeftClick = true\n      )\n      \n      // TODO: make a keybind system?\n      if \"`\".onKeyDown() (\n        void shared.settings.set(\"devtools\", \"open\", !shared.settings.get(\"devtools\", \"open\"))\n        //devtools.main.open = !devtools.main.open\n      )\n    )\n  )\n  return __imports__f477f9b400e164d253c3bfeb6a54c186\ncase \"./src/shared/tab_worker.osl\"\n  class __imports__ed11349f32bd7389fac05d89b56e016d (\n    def oncreate() (\n      self.ouid = OuidNew()\n    )\n    \n    def onframe() (\n      if self.parseText != null (\n        local parser @= rwl.ast.Parser(self.parseText)\n        if self != null (\n          //log self\n          void self.document.loadAst(parser.parse())\n          self.parseText = null\n        )\n      )\n      if self.document != null and self.document.focused (\n        void self.document.rwlInst.interactUpdate({\n          rtr: self.document.rtrInst\n        })\n        void self.document.rtrUpdate()\n        //void self.document.rwlInst.checkElemUpdate()\n        local mods @= self.document.rtrInst.modules.getValues()\n        for i mods.len (\n          void mods[i].runEventQueue()\n        )\n        void shared.input.reset()\n      )\n    )\n  )\n  return __imports__ed11349f32bd7389fac05d89b56e016d\ncase \"./src/shared/config.osl\"\n  class __imports__9f198a2aa8925b082e5f887a2bba9b67 (\n    class net (\n      servers = {\n        rtr: {\n          url: \"https://web.rotur.dev/\",\n          \n          // <server>/<command>\n          commands: {\n            tlds: \"tlds\"\n          }\n        }\n      }\n      \n      def refresh() (\n        if shared.settings.get(\"net\", \"offline\") (\n          self.servers @= []\n        )\n        \n        for i self.servers.len (\n          local s @= self.servers.getValues()[i]\n          s.tlds @= (s.url ++ s.commands.tlds).httpGet()\n        )\n      )\n    )\n    \n    class url (\n      string browser_scheme = build.package.phosphorus.browser_scheme ?? \"phos\"\n      \n      class defaults (\n        string scheme = \"rtr\"\n        string name = \"unknown\"\n        string top = \"web\"\n      )\n    )\n    \n    class browser (\n      string name = build.package.name ?? \"phosphorus\"\n      array developers = build.package.developers ?? [\"flufi\"]\n      string version = build.package.version ?? \"1.0.0a\"\n      \n      // browserName@developer\n      string save_developer = build.package.save_developer ?? \"rotur\"\n      \n      class phosphorus (\n        string version = \"1.0.0a\"\n        \n        boolean useCanvas = false\n        boolean useCompiler = true\n      )\n    )\n  )\n  return __imports__9f198a2aa8925b082e5f887a2bba9b67\ncase \"./src/shared/theme.osl\"\n  class __imports__5876b7f6fcd5ce7f0fafd1a44ec4bd74 (\n    def load() (\n      self.back = user.theme.background\n      self.prim = user.theme.primary\n      self.seco = user.theme.secondary\n      self.tert = user.theme.tertiary\n      self.text = user.theme.text\n      self.accent = global_accent\n    )\n    \n    load()\n  )\n  return __imports__5876b7f6fcd5ce7f0fafd1a44ec4bd74\ncase \"./src/shared/url.osl\"\n  class __imports__a1d00c2cd890aa6e92598446ff24f924 (\n    class Url (\n      def init(string text) (\n        void self.parse(text)\n      )\n      \n      def parse(string text) (\n        self.text = text\n        local s @= text.match(\"/^((\\\\w+):\\\\/\\\\/)/\")\n        local match @= text.match(\"/^((\\\\w+):\\\\/\\\\/)?(((\\\\w+)\\\\.)?(\\\\w+)(\\\\.(\\\\w+))?\\\\/?(([\\\\/w]+)?(\\\\/(\\\\w+\\\\.\\\\w+))?))\\\\/?/\")\n        \n        self.scheme = match[3] ?? s[3] ?? shared.config.url.defaults.scheme\n        \n        if self.scheme == \"local\" (\n          self.domain_name = text.trim(\"local://\".len + 1, -1)\n          local usrPath = \"origin/(c) users/\" ++ username\n          if self.domain_name.toLower().startsWith(usrPath.toLower()) (\n            self.domain_name = \"~\" ++ self.domain_name.trim(usrPath.len + 1, -1)\n          )\n          self.domain_top = null\n          self.domain_sub = null\n          self.path = null\n          self.params @= {}\n          self.resource = null\n          self.text = \"local://\" ++ self.domain_name\n          return\n        )\n        \n        if match[9] != null (\n          local domain_name = match[7]\n          local domain_top = match[9]\n          local domain_sub = match[6]\n        ) else (\n          if match[6] != null (\n            local domain_name = match[6]\n            local domain_top = match[7]\n            local domain_sub = null\n          ) else (\n            local domain_name = match[7]\n            local domain_top = null\n            local domain_sub = null\n          )\n        )\n        \n        self.domain_name = domain_name ?? shared.config.url.defaults.name\n        self.domain_top = domain_top ?? shared.config.url.defaults.top\n        self.domain_sub = domain_sub\n        self.path = match[13]\n        self.params @= {}\n        self.resource = match[10] ?? \"index.rwl\"\n        \n        if self.scheme == shared.config.url.browser_scheme (\n          self.domain_top = null\n        )\n      )\n      \n      def format() (\n        if self.scheme == \"local\" (\n          return self.text\n        )\n        local sub = self.domain_sub != null ? self.domain_sub ++ \".\" \"\"\n        local top = self.domain_top != null ? \".\" ++ self.domain_top \"\"\n        local txt = self.scheme ++ \"://\" ++ sub ++ domain_name ++ top\n        if self.path != null (\n          txt ++= \"/\" ++ self.path\n        )\n        if self.resource != \"index.rwl\" (\n          txt ++= \"/\" ++ self.resource\n        )\n        return txt\n      )\n      \n      def getTitle() (\n        if self.scheme == \"local\" (\n          return self.domain_name.split(\"/\")[-1].split(\".\")[1]\n        )\n        return self.domain_name\n      )\n    )\n  )\n  return __imports__a1d00c2cd890aa6e92598446ff24f924\ncase \"./src/shared/tab.osl\"\n  class __imports__0ffc38803b2c8e6e0623c0ea1ffbcc28 (\n    class Tab (\n      def init(object document) (\n        self.document @= document\n      )\n      \n      def redirect(object url) (\n        void self.document.loadUrl(url)\n        void layouts.shared.state.updateTab()\n      )\n    )\n  )\n  return __imports__0ffc38803b2c8e6e0623c0ea1ffbcc28\ncase \"./src/shared/document.osl\"\n  class __imports__af13446f70bd7836009892ffef4b5078 (\n    class Document (\n      def init() (\n        void self.createInsts()\n        \n        self.started = false\n        self.shouldBeAlive = false\n        self.focused = false\n      )\n      \n      def close() (\n        void self.killWorker()\n      )\n      \n      def createWorker() (\n        //log \"create worker\"\n        void self.killWorker()\n        self.worker @= worker(shared.tab_worker)\n        self.worker.document @= self\n        self.shouldBeAlive = true\n      )\n      \n      def killWorker() (\n        if self.worker != null (\n          //log \"kill worker\"\n          if self.worker.kill == null (\n            return\n          )\n          void self.worker.kill()\n          self.worker = null\n          self.shouldBeAlive = false\n        )\n      )\n      \n      def createInsts() (\n        self.title = \"New Tab\"\n        if self.url != null (\n          self.title = self.url.getTitle()\n        )\n        self.icon = null\n        \n        self.rtrInst @= rtr.main.RTR()\n        self.rwlInst @= rwl.main.RWL(shared.document.empty, self.rtrInst)\n      )\n      \n      def updateInsts() (\n        // inject apis\n        void rtr.apis.main.addToInst(self, self.rtrInst)\n      )\n      \n      def update(array area) (\n        void self.rwlInst.update(area)\n      )\n      \n      def rtrUpdate() (\n        if !self.started and self.rwlInst.hasUpdated (\n          void self.rtrInst.startModules()\n          self.started = true\n        )\n      )\n      \n      def render(array area) (\n        if self.worker != null (\n          self.worker.area @= area\n          if !self.worker.alive and self.shouldBeAlive (\n            //void self.createWorker()\n            //self.rwlInst.errored = true\n            //self.rwlInst.errormsg = \"tab worker died, check js console\"\n          )\n        )\n        \n        goto rwl.area.centerX(area) rwl.area.centerY(area)\n        square rwl.area.width(area) - 10 rwl.area.height(area) - 10 10 : c#shared.theme.back\n        \n        if self.loading (\n          goto rwl.area.centerX(area) rwl.area.centerY(area)\n          direction timer * 720\n          icon \"sync\" .75 : c#shared.theme.text\n          direction 90\n          return\n        )\n        \n        //log self.rwlInst\n        void self.rwlInst.render(area)\n      )\n      \n      def checkResp() (\n        if self.resp == null (\n          self.loading = false\n          return\n        )\n        \n        if self.resp.isFinished (\n          if self.resp.isValid (\n            self.loading = false\n            \n            void self.createInsts()\n            void self.loadText(self.resp.content)\n            \n            self.resp = null\n          )\n        ) else (\n          self.loading = true\n          void self.resp.update()\n        )\n      )\n      \n      def loadAst(object ast) (\n        void self.createInsts()\n        void self.rwlInst.loadFromAst(ast)\n        void self.updateInsts()\n        self.started = false\n      )\n      \n      def loadText(string text) (\n        void self.createWorker()\n        self.worker.parseText = text\n      )\n      \n      def loadUrl(object url) (\n        self.url @= url\n        void self.createInsts()\n        self.resp @= net.fetch.url(url)\n      )\n      \n      def getIcon() (\n        return self.icon\n      )\n      def getTitle() (\n        return self.title\n      )\n    )\n    \n    def init() (\n      local parser @= rwl.ast.Parser(import(\"./src/assets/empty.rwl\"))\n      self.empty @= parser.parse()\n    )\n  )\n  return __imports__af13446f70bd7836009892ffef4b5078\ncase \"./src/shared/utils.osl\"\n  class __imports__ace3e4fea1b83d3f4a6cf8da09fee544 (\n    def removeIndents(str) (\n      local lines @= str.split(\"\\n\")\n      local indent = null\n      for i lines.len (\n        local l2 = lines[i].match(\"/^( *)(.+)$/\")\n        if l2[2].len > 0 (\n          indent = min(indent ?? 9999, l2[2].len)\n        )\n      )\n      for i lines.len (\n        lines[i] = lines[i].trim(indent + 1, -1)\n      )\n      return lines.join(\"\\n\")\n    )\n    \n    def jsFunc(string js) (\n      local f @= js.eval()\n      local f2 @= () -> ()\n      f2.code @= f\n      return f2\n    )\n  )\n  return __imports__ace3e4fea1b83d3f4a6cf8da09fee544\ncase \"./src/shared/graphics.osl\"\n  class __imports__8840a5e065c53e817186a2216f863bca (\n    _canvasID = null\n    _canvas = null\n    \n    def init() (\n      if shared.config.browser.phosphorus.useCanvas (\n        self._canvasID = OuidNew()\n        self._canvas @= shared.canvas.createCanvas(self._canvasID, window.width, window.height)\n        log self\n      )\n    )\n    \n    // cursor\n    cursor_x = 0\n    cursor_y = 0\n    def goto(number x, number y) (\n      self.cursor_x = x\n      self.cursor_y = y\n    )\n    \n    def change_x(number x) (\n      self.cursor_x += x\n    )\n    def change_y(number y) (\n      self.cursor_y += y\n    )\n    def change(number x, number y) (\n      self.cursor_x += x\n      self.cursor_y += y\n    )\n    \n    // utils\n    def getTextWidth(string text) (\n      return text.len\n    )\n    \n    // rendering\n    def box(array area, string color) (\n      c color\n      pen \"size\" 1\n      goto area[1] area[2]\n      pen \"down\"\n      goto area[3] area[2]\n      goto area[3] area[4]\n      goto area[1] area[4]\n      goto area[1] area[2]\n      pen \"up\"\n    )\n    \n    def filledBox(array area, rounding, string color) (\n      local x = rwl.area.centerX(area)\n      local y = rwl.area.centerY(area)\n      local w = rwl.area.width(area)\n      local h = rwl.area.height(area)\n      \n      if typeof(rounding) == \"number\" (\n        rounding @= [rounding,rounding,rounding,rounding]\n      )\n      \n      c color\n      \n      if typeof(rounding) == \"number\" (\n        goto x y\n        frame area[1] area[4] area[3] area[2] (\n          local r = max(rounding * 2 - 10, 0)\n          square w - r h - r r\n        )\n      ) else if typeof(rounding) == \"array\" (\n        // could rework this to have it be corner - rounding for pos\n        // so it would have higher parity with canvas?\n        x = round(x)\n        y = round(y)\n        local hw = w / 2\n        local hh = h / 2\n        goto x y\n        //local r = min(rounding[1] * 2, min(w, h) / 2)\n        frame area[1] y x area[2] (\n          local r = max(rounding[1] * 2, 0)\n          goto frame.left + hw frame.bottom + hh\n          square frame.width * 2 - r frame.height * 2 - r r\n        )\n        frame x y area[3] area[2] (\n          local r = max(rounding[2] * 2, 0)\n          goto frame.right - hw frame.bottom + hh\n          square frame.width * 2 - r frame.height * 2 - r r\n        )\n        frame area[1] area[4] x y (\n          local r = max(rounding[3] * 2, 0)\n          goto frame.left + hw frame.top - hh\n          square frame.width * 2 - r frame.height * 2 - r r\n        )\n        frame x area[4] area[3] y (\n          local r = max(rounding[4] * 2, 0)\n          goto frame.right - hw frame.top - hh\n          square frame.width * 2 - r frame.height * 2 - r r\n        )\n      )\n    )\n    \n    def filledTransparentArea(array area, string color, number opacity) (\n      frame area[1] area[4] area[3] area[2] (\n        c color\n        pen \"opacity\" opacity\n        pen \"size\" 9999\n        goto 0 0\n        pen \"down\"\n        pen \"up\"\n      )\n    )\n    \n    def ctext(string text, number size, string color) (\n      void ptext(text, self.cursor_x, self.cursor_y, size, color)\n    )\n    def ptext(string text, number x, number y, number size, string color) (\n      goto x y\n      text text size : c#color\n    )\n    \n    def cicon(string src, number size, string color) (\n      void picon(text, self.cursor_x, self.cursor_y, size, color)\n    )\n    def picon(string src, number x, number y, number size, string color) (\n      goto x y\n      icon src size : c#color\n    )\n  )\n  return __imports__8840a5e065c53e817186a2216f863bca\ncase \"./src/rtr/apis/browser.osl\"\n  class __imports__7fe61a304bd2774f13f2fe6e50c50f2a (\n    def addToMod(object doc, object mod) (\n      void mod.declScopeVar(\"$$brwsr\", rtr.value.RTRObjValue({\n        settings: rtr.value.RTRObjValue({\n          getCategories: rtr.value.RTROslFuncValue(def() -> (\n            return rtr.value.RTRArrValue(shared.settings.entries.getKeys().map(c -> rtr.value.RTRStrValue(c)))\n          )),\n          getCategory: rtr.value.RTROslFuncValue(def() -> (\n          \n          ))\n        })\n      }))\n    )\n  )\n  return __imports__7fe61a304bd2774f13f2fe6e50c50f2a\ncase \"./src/rtr/apis/rwl.osl\"\n  class __imports__da08879ce20a927bf625b809217d8644 (\n    class RTRDocument extends rtr.value.RTRValue (\n      def init(object doc) (\n        self.doc @= doc\n      )\n    \n      def getRtrType() (\n        return rtr.value.RTRTypeValue({\n          name: \"document\"\n        })\n      )\n      \n      def getItem(key) (\n        switch key.stringify() (\n          // values\n          case \"title\"\n            return rtr.value.RTRStrValue(self.doc.title)\n          case \"icon\"\n            if self.doc.icon == null (\n              return rtr.value.RTRNullValue()\n            )\n            return rtr.value.RTRStrValue(self.doc.icon)\n          case \"root\"\n            local elems @= self.doc.rwlInst.elements\n            for i elems.len (\n              local elem @= elems[i]\n              if elem.name == \"RWLRoot\" (\n                return rtr.apis.rwl.RTRElement(elem)\n              )\n            )\n            return rtr.value.RTRNullValue()\n          \n          // methods\n          case \"redirect\"\n            return rtr.value.RTROslFuncValue(def(args, _inst, doc) -> (\n              void doc.doc.loadUrl(shared.url.Url(args[1].stringify()))\n              void layouts.shared.state.updateTab()\n            ), self)\n          case \"getElement\"\n            return rtr.value.RTROslFuncValue(def(args, _inst, doc) -> (\n              local elem @= doc.doc.rwlInst.getElement(args[1].stringify())\n              if elem == null (\n                return rtr.value.RTRNullValue()\n              )\n              return rtr.apis.rwl.RTRElement(elem)\n            ), self)\n          case \"createTextElement\"\n            return rtr.value.RTROslFuncValue(def(args, _inst) -> (\n              return rtr.apis.rwl.RTRElement(rwl.main.RWLElement(rtr.apis.rwl.rtrValueToRwlValue(args[1]), { flags: [], pairs: [] }))\n            ))\n          case \"createScript\"\n            return rtr.value.RTROslFuncValue(def(args, _inst, doc) -> (\n              local elem @= rwl.main.RWLScript(args[1].stringify(), { flags: [], pairs: [] }, doc.doc.rwlInst)\n              void rtr.apis.main.addToMod(doc.doc, elem.mod)\n              void elem.start()\n              return rtr.apis.rwl.RTRElement(elem)\n            ), self)\n          case \"createContainer\"\n            return rtr.value.RTROslFuncValue(def(args, _inst) -> (\n              local kind = args[1].stringify()\n              switch kind (\n                case \"frame\"\n                  return rtr.apis.rwl.RTRElement(rwl.main.RWLFrame([], { flags: [], pairs: [] }))\n                case \"section\"\n                  return rtr.apis.rwl.RTRElement(rwl.main.RWLSection([], { flags: [], pairs: [] }))\n                case \"button\"\n                  return rtr.apis.rwl.RTRElement(rwl.main.RWLButton([], { flags: [], pairs: [] }))\n                \n                default\n                  throw \"unknown container type\" + kind\n              )\n              return rtr.apis.rwl.RTRElement(rwl.main.RWLElement(rtr.apis.rwl.rtrValueToRwlValue(args[1]), { flags: [], pairs: [] }))\n            ))\n          \n          default\n            throw \"unknown property\" + key.stringify() + \"on document\"\n        )\n      )\n      \n      def setItem(key, value) (\n        switch key.stringify() (\n          case \"title\"\n            self.doc.title = value.stringify()\n            break\n          case \"icon\"\n            self.doc.icon = value.stringify()\n            break\n          default\n            throw \"cannot set property\" + key.stringify() + \"on document\"\n        )\n      )\n    )\n    \n    class RTRElement extends rtr.value.RTRValue (\n      isRwlElem = true\n      \n      def init(object elem) (\n        self.elem @= elem\n      )\n    \n      def getRtrType() (\n        return rtr.value.RTRTypeValue({\n          name: \"element\"\n        })\n      )\n      \n      def stringify() (\n        local txt = (self.elem.blockName ?? self.elem.kind).toStr()\n        if self.elem.id != null (\n          txt ++= \":\" ++ self.elem.id\n        )\n        return \"<\" ++ txt ++ \">\"\n      )\n      \n      def getItem(key) (\n        local k = key.stringify()\n        \n        switch k (\n          case \"toggleFlag\"\n            return rtr.value.RTROslFuncValue(def(args, _inst, elem) -> (\n              local flags @= elem.elem.header.flags\n              local name = args[1].stringify()\n              \n              if flags.contains(name) (\n                void flags.delete(flags.index(name))\n              ) else (\n                void flags.append(name)\n              )\n              \n              elem.elem.needsUpdate = true\n              void elem.elem.checkUpdate()\n            ), self)\n          case \"addFlag\"\n            return rtr.value.RTROslFuncValue(def(args, _inst, elem) -> (\n              local flags @= elem.elem.header.flags\n              local name = args[1].stringify()\n              \n              if !flags.contains(name) (\n                void flags.append(name)\n              )\n              \n              elem.elem.needsUpdate = true\n              void elem.elem.checkUpdate()\n            ), self)\n          case \"removeFlag\"\n            return rtr.value.RTROslFuncValue(def(args, _inst, elem) -> (\n              local flags @= elem.elem.header.flags\n              local name = args[1].stringify()\n              \n              if flags.contains(name) (\n                void flags.delete(flags.index(name))\n              )\n              \n              elem.elem.needsUpdate = true\n              void elem.elem.checkUpdate()\n            ), self)\n          case \"hasFlag\"\n            return rtr.value.RTROslFuncValue(def(args, _inst, elem) -> (\n              local flags @= elem.elem.header.flags\n              local name = args[1].stringify()\n              \n              return rtr.value.RTRBoolValue(flags.contains(name))\n            ), self)\n          \n          case \"addChild\"\n            return rtr.value.RTROslFuncValue(def(args, _inst, elem) -> (\n              if elem.elem.children == null (\n                throw elem.kind + \"cannot contain children\"\n              )\n              if !args[1].isRwlElem (\n                throw \"argument is not rwl element\"\n              )\n              void elem.elem.children.append(args[1].elem)\n              \n              void elem.elem.updateParentFromCache()\n            ), self)\n          case \"popChild\"\n            return rtr.value.RTROslFuncValue(def(args, _inst, elem) -> (\n              if elem.elem.children == null (\n                throw elem.kind + \"doesnt contain children\"\n              )\n              local idx = args.len > 0 ? args[1].numbify() 1\n              local out @= elem.elem.children[idx]\n              if out != null (\n                out @= rtr.apis.rwl.RTRElement(out)\n              ) else (\n                out @= rtr.value.RTRNullValue()\n              )\n              void elem.elem.children.delete(idx)\n              \n              void elem.elem.updateParentFromCache()\n              return out\n            ), self)\n        )\n        \n        for i self.elem.header.pairs.len (\n          local pair @= self.elem.header.pairs[i]\n          if pair[1] == k (\n            return rtr.apis.rwl.rwlValueToRtrValue(pair[2])\n          )\n        )\n        return rtr.value.RTRNullValue()\n      )\n      \n      def setItem(key, value) (\n        local k = key.stringify()\n        local v @= rtr.apis.rwl.rtrValueToRwlValue(value)\n        \n        if k == \"text\" and self.elem.name == \"RWLElement\" (\n          self.elem.value @= v\n          void self.elem.updateFromCache()\n          return\n        )\n        \n        for i self.elem.header.pairs.len (\n          local pair @= self.elem.header.pairs[i]\n          if pair[1] == k (\n            pair[2] @= v\n            void self.elem.updateParentFromCache()\n            return\n          )\n        )\n        \n        void self.elem.header.pairs.append([\n          k, v\n        ])\n        \n        void self.elem.updateParentFromCache()\n      )\n    )\n    \n    def rwlValueToRtrValue(object val) (\n      switch val.type (\n        case \"str\"\n          return rtr.value.RTRStrValue(val.value)\n        case \"num\"\n          return rtr.value.RTRNumValue(val.value)\n        // percentage\n        // color\n      )\n      \n      return rtr.value.RTRNullValue()\n    )\n    \n    def rtrValueToRwlValue(object val) (\n      local type @= val.getRtrType()\n      \n      switch type.data.name (\n        case \"str\"\n          return rwl.value.RWLStrValue(val.value)\n        case \"num\"\n          return rwl.value.RWLNumValue(val.value)\n        case \"color\"\n          return rwl.value.RWLColorValue(val.value)\n      )\n      \n      throw \"cannot set\" + type.stringify() + \"as rwl property\"\n    )\n    \n    // applies rwl related apis to rtr\n    def addToMod(object doc, object mod) (\n      void mod.declScopeVar(\"document\", RTRDocument(doc))\n      void mod.declScopeVar(\"theme\", rtr.value.RTRObjValue({\n        back: rtr.value.RTRColorValue(shared.theme.back),\n        prim: rtr.value.RTRColorValue(shared.theme.prim),\n        seco: rtr.value.RTRColorValue(shared.theme.seco),\n        tert: rtr.value.RTRColorValue(shared.theme.tert),\n        text: rtr.value.RTRColorValue(shared.theme.text),\n        accent: rtr.value.RTRColorValue(shared.theme.accent),\n      }))\n    )\n  )\n  return __imports__da08879ce20a927bf625b809217d8644\ncase \"./src/rtr/apis/main.osl\"\n  class __imports__60f47f43e26f20419434c17601b19cbc (\n    // applies apis to rtr\n    def addToInst(object doc, object rtrInst) (\n      local mods @= rtrInst.modules.getValues()\n      for i mods.len (\n        addToMod(doc, mods[i])\n      )\n    )\n    \n    def addToMod(object doc, object mod) (\n      void rtr.apis.rwl.addToMod(doc, mod)\n      void rtr.apis.browser.addToMod(doc, mod)\n    )\n  )\n  return __imports__60f47f43e26f20419434c17601b19cbc\ncase \"./src/rtr/instruction.osl\"\n  class __imports__63f619ecaeba64e54adfad70c460fe06 (\n    // program flow\n    def label(string name) (\n      return { kind: \"label\", name }\n    )\n    def jump(string label) (\n      return { kind: \"jump\", label }\n    )\n    def jumpIf(string label) (\n      return { kind: \"jumpIf\", label }\n    )\n    def jumpNotIf(string label) (\n      return { kind: \"jumpNotIf\", label }\n    )\n    \n    // operations\n    def callOp(number amount) (\n      return { kind: \"call\", args: amount }\n    )\n    def unary(string op) (\n      return { kind: \"unary\", op }\n    )\n    def binary(string op) (\n      return { kind: \"binary\", op }\n    )\n    def prop() (\n      return { kind: \"prop\" }\n    )\n    def len() (\n      return { kind: \"len\" }\n    )\n    \n    // values\n    def null() (\n      return { kind: \"null\" }\n    )\n    def str(string data) (\n      return { kind: \"str\", data }\n    )\n    def num(number data) (\n      return { kind: \"num\", data }\n    )\n    def bool(boolean data) (\n      return { kind: \"bool\", data }\n    )\n    def func(array body, array args) (\n      return { kind: \"func\", body, args }\n    )\n    def arr(number elems) (\n      return { kind: \"arr\", elems }\n    )\n    def obj(array keys) (\n      return { kind: \"obj\", keys }\n    )\n    def color(string data) (\n      return { kind: \"color\", data }\n    )\n    \n    // scope\n    def get(string name) (\n      return { kind: \"get\", name }\n    )\n    def decl(string name) (\n      return { kind: \"decl\", name }\n    )\n    def newScope() (\n      return { kind: \"newScope\" }\n    )\n    def popScope() (\n      return { kind: \"popScope\" }\n    )\n    \n    // assignments\n    def asivar(string name, op) (\n      return { kind: \"asivar\", name, op }\n    )\n    def asiprop(op) (\n      return { kind: \"asiprop\", op }\n    )\n    \n    // stack\n    def pop() (\n      return { kind: \"pop\" }\n    )\n    def dupe(number i) (\n      return { kind: \"dupe\", i }\n    )\n  )\n  return __imports__63f619ecaeba64e54adfad70c460fe06\ncase \"./src/rtr/compiler.osl\"\n  class __imports__bf40e68b061a1d99656fd4525ccf9d7b (\n    lbli = 0\n    \n    def getLabelName() (\n      self.lbli ++\n      return self.lbli.toStr()\n    )\n    \n    def compileBlock(object block) (\n      local instructions @= []\n      //log \"blk\" block\n      for i block.elements.len (\n        local out @= compileStatement(block.elements[i])\n        if typeof(out) != \"array\" and out.isError (\n          return out\n        )\n        \n        instructions ++= out\n      )\n      return instructions\n    )\n    \n    def compileStatement(object statement) (\n      //log \"stat\" statement\n      switch statement.kind (\n        case \"expression\"\n          local out @= compileExpression(statement.expr)\n          if typeof(out) != \"array\" and out.isError (\n            return out\n          )\n          \n          out += rtr.instruction.pop()\n          return out\n        case \"block\"\n          local body @= compileBlock(statement.body)\n          if typeof(body) != \"array\" and body.isError (\n            return body\n          )\n          \n          local out @= []\n          \n          out += rtr.instruction.newScope()\n          out ++= body\n          out += rtr.instruction.popScope()\n          \n          return out\n        \n        case \"branch\"\n          local out @= []\n          local hasElse = statement.elifs.len > 0 or statement.elseBody != null\n          \n          local endLbl = getLabelName()\n          local elseLbl = hasElse ? getLabelName() endLbl\n          \n          local cond @= compileExpression(statement.cond)\n          if typeof(cond) != \"array\" and cond.isError (\n            return cond\n          )\n          out ++= cond\n          out += rtr.instruction.jumpNotIf(elseLbl)\n          local body @= compileStatement(statement.body)\n          if typeof(body) != \"array\" and body.isError (\n            return body\n          )\n          out ++= body\n          if hasElse (\n            out += rtr.instruction.jump(endLbl)\n          )\n          \n          for i statement.elifs.len (\n            local elif @= statement.elifs[i]\n            local isLast = i == statement.elifs.len and statement.elseBody == null\n            out += rtr.instruction.label(elseLbl)\n            elseLbl = isLast ? endLbl getLabelName()\n            \n            local cond @= compileExpression(elif.cond)\n            if typeof(cond) != \"array\" and cond.isError (\n              return cond\n            )\n            out ++= cond\n            out += rtr.instruction.jumpNotIf(elseLbl)\n            local body @= compileStatement(elif.body)\n            if typeof(body) != \"array\" and body.isError (\n              return body\n            )\n            out ++= body\n            if !(i == statement.elifs.len and statement.elseBody == null) (\n              out += rtr.instruction.jump(endLbl)\n            )\n          )\n          \n          if statement.elseBody != null (\n            out += rtr.instruction.label(elseLbl)\n            local body @= compileStatement(statement.elseBody)\n            if typeof(body) != \"array\" and body.isError (\n              return body\n            )\n            out ++= body\n          )\n          out += rtr.instruction.label(endLbl)\n          return out\n        \n        case \"while\"\n          local out @= []\n          \n          local startLbl @= getLabelName()\n          local endLbl @= getLabelName()\n          \n          out += rtr.instruction.label(startLbl)\n          local cond @= compileExpression(statement.cond)\n          if typeof(cond) != \"array\" and cond.isError (\n            return cond\n          )\n          out ++= cond\n          out += rtr.instruction.jumpNotIf(endLbl)\n          \n          local body @= compileStatement(statement.body)\n          if typeof(body) != \"array\" and body.isError (\n            return body\n          )\n          out ++= body\n          \n          out += rtr.instruction.jump(startLbl)\n          out += rtr.instruction.label(endLbl)\n          return out\n        case \"until\"\n          local out @= []\n          \n          local startLbl @= getLabelName()\n          local endLbl @= getLabelName()\n          \n          out += rtr.instruction.label(startLbl)\n          local cond @= compileExpression(statement.cond)\n          if typeof(cond) != \"array\" and cond.isError (\n            return cond\n          )\n          out ++= cond\n          out += rtr.instruction.jumpIf(endLbl)\n          \n          local body @= compileStatement(statement.body)\n          if typeof(body) != \"array\" and body.isError (\n            return body\n          )\n          out ++= body\n          \n          out += rtr.instruction.jump(startLbl)\n          out += rtr.instruction.label(endLbl)\n          return out\n        case \"repeat\"\n          local out @= []\n          \n          local startLbl @= getLabelName()\n          local endLbl @= getLabelName()\n          \n          out += rtr.instruction.num(1)\n          out += rtr.instruction.label(startLbl)\n          out += rtr.instruction.dupe(-1)\n          local amt @= compileExpression(statement.amount)\n          if typeof(amt) != \"array\" and amt.isError (\n            return amt\n          )\n          out ++= amt\n          out += rtr.instruction.binary(\">\")\n          out += rtr.instruction.jumpIf(endLbl)\n          \n          out ++= compileStatement(statement.body)\n          \n          out += rtr.instruction.num(1)\n          out += rtr.instruction.binary(\"+\")\n          out += rtr.instruction.jump(startLbl)\n          out += rtr.instruction.label(endLbl)\n          out += rtr.instruction.pop()\n          return out\n        case \"for\"\n          local out @= []\n          \n          local startLbl @= getLabelName()\n          local endLbl @= getLabelName()\n          local arr @= compileExpression(statement.arr)\n          if typeof(arr) != \"array\" and arr.isError (\n            return arr\n          )\n          out ++= arr\n          out += rtr.instruction.num(0)\n          out += rtr.instruction.label(startLbl)\n          out += rtr.instruction.dupe(-2)\n          out += rtr.instruction.len()\n          out += rtr.instruction.dupe(-2)\n          out += rtr.instruction.binary(\"<=\")\n          out += rtr.instruction.jumpIf(endLbl)\n          out += rtr.instruction.dupe(-2)\n          out += rtr.instruction.dupe(-2)\n          out += rtr.instruction.prop()\n          out += rtr.instruction.newScope()\n          out += rtr.instruction.decl(statement.var)\n          out += rtr.instruction.pop()\n          \n          out ++= compileStatement(statement.body)\n          \n          out += rtr.instruction.popScope()\n          out += rtr.instruction.num(1)\n          out += rtr.instruction.binary(\"+\")\n          out += rtr.instruction.jump(startLbl)\n          out += rtr.instruction.label(endLbl)\n          out += rtr.instruction.pop()\n          out += rtr.instruction.pop()\n          return out\n        \n        default\n          return rtr.error.Error(\"UnknownStatementKind\", { kind: statement.kind })\n      )\n      \n      return []\n    )\n    \n    def compileExpression(object expression) (\n      //log \"expr\" expression\n      switch expression.kind (\n        case \"call\"\n          local func @= compileExpression(expression.func)\n          if typeof(func) != \"array\" and func.isError (\n            return func\n          )\n          \n          local args @= []\n          for i expression.args.len (\n            local out @= compileExpression(expression.args[i])\n            if typeof(out) != \"array\" and out.isError (\n              return out\n            )\n            \n            args ++= out\n          )\n          local out @= []\n          out ++= func\n          out ++= args\n          out += rtr.instruction.callOp(expression.args.len)\n          return out\n        case \"decl\"\n          local val @= compileExpression(expression.val)\n          if typeof(val) != \"array\" and val.isError (\n            return val\n          )\n          \n          local out @= val\n          out += rtr.instruction.decl(expression.tar)\n          return out\n        case \"asi\"\n          local val @= compileExpression(expression.val)\n          if typeof(val) != \"array\" and val.isError (\n            return val\n          )\n          local out @= val\n          switch expression.tar.kind (\n            case \"var\"\n              void out.append(rtr.instruction.asivar(expression.tar.name, expression.op))\n              return out\n            case \"prop\"\n              out ++= compileExpression(expression.tar.obj)\n              if typeof(expression.tar.key) == \"string\" (\n                out += rtr.instruction.str(expression.tar.key)\n              ) else (\n                out ++= compileExpression(expression.tar.key)\n              )\n              void out.append(rtr.instruction.asiprop(expression.op))\n              return out\n          )\n          \n          return [rtr.instruction.null()]\n        case \"unary\"\n          local val @= compileExpression(expression.expr)\n          \n          local out @= []\n          out ++= val\n          out += rtr.instruction.unary(expression.type)\n          \n          return out\n        case \"binary\"\n          local left @= compileExpression(expression.left)\n          if typeof(left) != \"array\" and left.isError (\n            return left\n          )\n          local right @= compileExpression(expression.right)\n          if typeof(right) != \"array\" and right.isError (\n            return right\n          )\n          \n          local out @= []\n          out ++= left\n          out ++= right\n          out += rtr.instruction.binary(expression.op)\n          \n          return out\n        case \"var\"\n          if [\"true\",\"false\"].contains(expression.name) (\n            return [rtr.instruction.bool(expression.name == \"true\")]\n          )\n          return [rtr.instruction.get(expression.name)]\n        case \"prop\"\n          local out @= []\n          out ++= compileExpression(expression.obj)\n          if typeof(expression.key) == \"string\" (\n            out += rtr.instruction.str(expression.key)\n          ) else (\n            out ++= compileExpression(expression.key)\n          )\n          out += rtr.instruction.prop()\n          return out\n        \n        case \"str\"\n          return [rtr.instruction.str(expression.val)]\n        case \"num\"\n          return [rtr.instruction.num(expression.val)]\n        case \"func\"\n          return [rtr.instruction.func(compileStatement(expression.body), expression.args)]\n        case \"arr\"\n          local out @= []\n          for i expression.elems.len (\n            out ++= compileExpression(expression.elems[i])\n          )\n          out += rtr.instruction.arr(expression.elems.len)\n          return out\n        case \"obj\"\n          local out @= []\n          local keys @= []\n          for i expression.pairs.len (\n            out ++= compileExpression(expression.pairs[i].value)\n            void keys.append(expression.pairs[i].name)\n          )\n          out += rtr.instruction.obj(keys)\n          return out\n        case \"color\"\n          return [rtr.instruction.color(expression.val)]\n        \n        default\n          log expression\n          return rtr.error.Error(\"UnknownExpressionKind\", { kind: expression.kind })\n      )\n      \n      return [rtr.instruction.null()]\n    )\n  )\n  return __imports__bf40e68b061a1d99656fd4525ccf9d7b\ncase \"./src/rtr/value.osl\"\n  class __imports__b2506e9c8a1f71d53780de64c11f25a1 (\n    class RTRValue (\n      def callFunc() (\n        throw \"cannot call\" + self.stringify(true) + \"as function\"\n      )\n    \n      def getRtrType() (\n        throw self.name + \"has not implemented getRtrType()\"\n        return rtr.value.RTRTypeValue({\n          name: \"?\"\n        })\n      )\n    \n      def stringify() (\n        return \"<\" ++ self.getRtrType().getName() ++ \">\"\n      )\n      def numbify() (\n        return NaN\n      )\n      def boolify() (\n        return true\n      )\n      def arrify() (\n        return []\n      )\n      def length() (\n        return 0\n      )\n      def getItem(key) (\n        return null\n      )\n      def setItem(key, value) (\n        throw \"cannot set items on\" + self.stringify(true)\n      )\n      def keys() (\n        return []\n      )\n      def values() (\n        return []\n      )\n      def has(key) (\n        return false\n      )\n      def isEqual(other) (\n        return self.getRtrType().isEqual(other.getRtrType())\n      )\n    )\n    \n    class RTRTypeValue (\n      def init(object data) (\n        self.data @= data\n      )\n      \n      def stringify() (\n        return self.getName()\n      )\n      def getName() (\n        if self.data.name != null (\n          return self.data.name\n        )\n        return \"?\"\n      )\n      def isEqual(object other) (\n        return self.data.name == other.data.name\n      )\n    )\n    \n    class RTRLiteralValue extends RTRValue (\n      boolean isLiteral = true\n    )\n    \n    class RTRStrValue extends RTRLiteralValue (\n      def init(string value) (\n        self.value @= value\n      )\n      \n      def getRtrType() (\n        return rtr.value.RTRTypeValue({\n          name: \"str\"\n        })\n      )\n      \n      def stringify(format) (\n        return format ? self.value.JsonStringify() self.value\n      )\n      def numbify() (\n        return self.value.toNum()\n      )\n      def boolify() (\n        return self.value.len > 0\n      )\n      def arrify() (\n        return self.value.split(\"\").map(e -> rtr.value.RTRStrValue(e))\n      )\n      def length() (\n        return self.value.len\n      )\n      def getItem(index) (\n        return rtr.value.RTRStrValue(self.value[index.numbify() + 1])\n      )\n      def isEqual(other) (\n        return self.getRtrType().isEqual(other.getRtrType()) and self.value === other.value\n      )\n    )\n    \n    class RTRNumValue extends RTRLiteralValue (\n      def init(number value) (\n        self.value @= value\n      )\n      \n      def getRtrType() (\n        return rtr.value.RTRTypeValue({\n          name: \"num\"\n        })\n      )\n      \n      def stringify() (\n        return self.value.toStr()\n      )\n      def numbify() (\n        return self.value\n      )\n      def boolify() (\n        return self.value > 0\n      )\n      def arrify() (\n        return self.value.toStr().split(\"\").map(e -> rtr.value.RTRStrValue(e))\n      )\n      def length() (\n        return self.value.toStr().length\n      )\n      def getItem(index) (\n        return self.value.toStr()[index.numbify() + 1]\n      )\n      def isEqual(other) (\n        return self.getRtrType().isEqual(other.getRtrType()) and self.value === other.value\n      )\n    )\n    \n    class RTRBoolValue extends RTRLiteralValue (\n      def init(boolean value) (\n        self.value @= value\n      )\n      \n      def getRtrType() (\n        return rtr.value.RTRTypeValue({\n          name: \"bool\"\n        })\n      )\n      \n      def stringify() (\n        return self.value.toStr()\n      )\n      def numbify() (\n        return self.value.toNum()\n      )\n      def boolify() (\n        return self.value\n      )\n      def isEqual(other) (\n        return self.getRtrType().isEqual(other.getRtrType()) and self.value === other.value\n      )\n    )\n    \n    class RTRColorValue extends RTRLiteralValue (\n      def init(string value) (\n        self.value @= value\n      )\n      \n      def getRtrType() (\n        return rtr.value.RTRTypeValue({\n          name: \"color\"\n        })\n      )\n      \n      def stringify() (\n        return self.value.toStr()\n      )\n      def boolify() (\n        return !!self.value\n      )\n      def isEqual(other) (\n        return self.getRtrType().isEqual(other.getRtrType()) and self.value === other.value\n      )\n    )\n    \n    class RTRFuncValue extends RTRValue (\n      def getRtrType() (\n        return rtr.value.RTRTypeValue({\n          name: \"func\"\n        })\n      )\n    )\n    \n    class RTROslFuncValue extends RTRFuncValue (\n      def init(func, extra) (\n        self.func @= func\n        self.extra @= extra\n      )\n      \n      def callFunc(object inst, array args) (\n        return self.func(args, inst, extra) ?? rtr.value.RTRNullValue()\n      )\n    )\n    class RTRAstFuncValue extends RTRFuncValue (\n      def init(array args, object body) (\n        self.args @= args\n        self.body @= body\n      )\n      \n      def callFunc(object inst, array args) (\n        local s @= {}\n        for i self.args.len (\n          local a @= self.args[i]\n          local v @= args[i] ?? rtr.value.RTRNullValue()\n          s[a.name] @= [v, {}]\n        )\n        \n        void inst.newScope(s)\n        void inst.declScopeVar(\"@return\", 0)\n        \n        local exprOut @= inst.runStatement(self.body)\n        \n        local ret @= inst.getScopeVar(\"@return\") ?? 0\n        if ret == 0 (\n          ret @= exprOut\n        )\n        \n        void inst.popScope()\n        \n        return ret\n      )\n    )\n    class RTRBytecodeFuncValue extends RTRFuncValue (\n      def init(array args, array body) (\n        self.args @= args\n        self.body @= body\n      )\n      \n      def callFunc(object inst, array args) (\n        local s @= {}\n        for i self.args.len (\n          local a @= self.args[i]\n          local v @= args[i] ?? rtr.value.RTRNullValue()\n          s[a.name] @= [v, {}]\n        )\n        \n        void inst.newScope(s)\n        \n        local exprOut @= inst.runInstructions(self.body)\n        \n        void inst.popScope()\n        \n        return exprOut\n      )\n    )\n    \n    class RTRNullValue extends RTRValue (\n      def getRtrType() (\n        return rtr.value.RTRTypeValue({\n          name: \"null\"\n        })\n      )\n      \n      def boolify() (\n        return false\n      )\n      def isEqual(other) (\n        return self.getRtrType().isEqual(other.getRtrType()) and self.value === other.value\n      )\n    )\n    \n    class RTRArrValue extends RTRValue (\n      def init(array elements) (\n        self.elements @= elements\n      )\n      \n      def getRtrType() (\n        return rtr.value.RTRTypeValue({\n          name: \"arr\"\n        })\n      )\n      \n      def stringify() (\n        local el @= self.elements.map(e -> e.stringify(true))\n        return \"[\" ++ el.join(\", \") ++ \"]\"\n      )\n      def boolify() (\n        return self.elements.len > 0\n      )\n      def arrify() (\n        return self.elements\n      )\n      def length() (\n        return self.elements.len\n      )\n      def keys() (\n        local arr2 @= []\n        for i self.elements.len (\n          void arr2.append(i - 1)\n        )\n        return arr2\n      )\n      def values() (\n        return self.elements\n      )\n      def getItem(index) (\n        return self.elements[index.numbify() + 1]\n      )\n      // setItem\n    )\n    \n    class RTRObjValue extends RTRValue (\n      def init(object value) (\n        self.value @= value\n      )\n      \n      def getRtrType() (\n        return rtr.value.RTRTypeValue({\n          name: \"obj\"\n        })\n      )\n      \n      def stringify() (\n        local el @= self.value.getEntries().map(e -> e[1] ++ \":\" + e[2].stringify(true))\n        return \"{\" ++ el.join(\", \") ++ \"}\"\n      )\n      def boolify() (\n        return self.value.getKeys().len > 0\n      )\n      def arrify() (\n        return self.value.getKeys().map(e -> rtr.value.RTRStrValue(e))\n      )\n      def length() (\n        return self.value.getKeys().len\n      )\n      def keys() (\n        return self.value.getKeys()\n      )\n      def values() (\n        return self.value.getValues()\n      )\n      def has(key) (\n        return self.value.getKeys().contains(key)\n      )\n      def getItem(key) (\n        return self.value[key.stringify()]\n      )\n      def setItem(key, value) (\n        self.value[key.stringify()] @= value\n      )\n    )\n  )\n  return __imports__b2506e9c8a1f71d53780de64c11f25a1\ncase \"./src/rtr/error.osl\"\n  class __imports__a51b04c580d521af176787ba84843c9a (\n    object Errors = {\n      CannotAssign: def(data) -> (\n        return \"cannot assign to\" + data.kind\n      ),\n    \n      // instructions\n      UnknownInstructionKind: def(data) -> (\n        return \"unknown instruction kind:\" + data.kind\n      ),\n      \n      // compiler\n      UnknownStatementKind: def(data) -> (\n        return \"unknown statement kind:\" + data.kind\n      ),\n      UnknownExpressionKind: def(data) -> (\n        return \"unknown expression kind:\" + data.kind\n      )\n    }\n    \n    class Error (\n      boolean isError = true\n      \n      def init(string type, object data) (\n        self.type = type\n        self.data @= data\n        \n        local err @= rtr.error.Errors[type]\n        if err == null (\n          self.type = \"UnknownErrorType\"\n          self.txt = \"unknown error type\" + type\n          return\n        )\n        self.txt = err(data)\n      )\n      \n      def stringify() (\n        return \"Error<\" ++ self.type ++ \">:\\n\" ++ self.txt.split(\"\\n\").map(l -> \"    \" ++ l).join(\"\\n\")\n      )\n    )\n  )\n  return __imports__a51b04c580d521af176787ba84843c9a\ncase \"./src/rtr/ast.osl\"\n  class __imports__2691a00e099698fa56c4748f2551eb65 (\n    class Parser (\n      def init(string text, scriptLocation) (\n        self.scriptLocation @= scriptLocation\n        void self.tokenise(text)\n      )\n      \n      def parse() (\n        self.pointer = 1\n        local out @= self.blockContent(true)\n        \n        if !self.atEnd() (\n          throw \"unexpected token\" + self.peek()\n        )\n        \n        return { elements: out }\n      )\n      \n      def peek(amount) (\n        amount ??= 1\n        return self.tokens[self.pointer + amount - 1]\n      )\n      def consume() (\n        local tkn = self.peek()\n        self.pointer ++\n        return tkn\n      )\n      def consumeWhitespace() (\n        while self.peek().match(\"/^\\\\s$/\") != null (\n          void self.consume()\n        )\n      )\n      def atEnd() (\n        return self.pointer >= self.tokens.len\n      )\n      def expect(string token) (\n        local tkn @= self.consume()\n        if tkn != token (\n          throw \"expected '\" ++ token ++ \"' got '\" ++ tkn ++ \"'\"\n        )\n        return tkn\n      )\n      def expects(array tokens) (\n        local tkn @= self.consume()\n        if !tokens.contains(tkn) (\n          throw \"expected '\" ++ tokens.join(\" or \") ++ \"' got '\" ++ tkn ++ \"'\"\n        )\n        return tkn\n      )\n      def expectText() (\n        local tkn @= self.consume()\n        if !tkn.match(\"/^[a-zA-Z_0-9]+$/\") (\n          throw \"identifier must consist of letters or _\"\n        )\n        return tkn\n      )\n      def getPos() (\n        local ln = 1\n        local col = 0\n        local char = 0\n        local i = self.pointer\n        for t self.pointer (\n          col ++\n          char += self.tokens[t].len\n          if self.tokens[t] == \"\\n\" (\n            ln ++\n            col = 0\n            char = 0\n          )\n        )\n        return { ln, col, char, i, loc: self.scriptLocation }\n      )\n      \n      def tokenise(string text) (\n        self.tokens @= []\n        local splitChars @= [\n          \"(\",\")\",\n          \"[\",\"]\",\n          \"{\",\"}\",\n          \",\",\";\",\":\",\"=\",\".\",\"#\",\n          \"+\",\"-\",\"*\",\"/\",\"%\",\"^\",\n          \"\\\\\",\n          \"'\",\"\\\"\",\"`\",\n          \" \",\"\\n\",\n          \"!\",\"?\"\n        ]\n        local buf = \"\"\n        for i text.len (\n          if splitChars.contains(text[i]) (\n            if buf.len > 0 (\n              void self.tokens.append(buf)\n            )\n            void self.tokens.append(text[i])\n            buf = \"\"\n          ) else (\n            buf ++= text[i]\n          )\n        )\n        if buf.len > 0 (\n          self.tokens.append(buf)\n        )\n      )\n      \n      // statements\n      def blockContent(top) (\n        local statements @= []\n        local end = self.peek() == \"}\" or self.atEnd()\n        while !end (\n          if top (\n            local out @= self.topLevelStatement()\n          ) else (\n            local out @= self.statement()\n          )\n          if out != null (\n            void statements.append(out)\n          )\n          void self.consumeWhitespace()\n          if self.peek() == \";\" (\n            void self.consume()\n          )\n          if self.peek() == \"}\" or self.atEnd() (\n            end = true\n          )\n        )\n        return statements\n      )\n      \n      def topLevelStatement() (\n        void self.consumeWhitespace()\n        \n        if self.peek() == \"event\" (\n          return self.event()\n        )\n        \n        void self.consumeWhitespace()\n        \n        // global parsing\n        local ptr = self.pointer\n        \n        local start @= self.getPos()\n        local name = self.consume()\n        if name.match(\"/^[a-zA-Z_0-9]+$/\") != null (\n          void self.consumeWhitespace()\n          if self.peek() == \":\" (\n            void self.consume()\n            void self.expect(\"=\")\n            void self.consumeWhitespace()\n            local expr @= self.expression()\n            void self.expect(\";\")\n            return {\n              kind: \"global\",\n              name,\n              val: expr,\n              auto: true,\n              start, end: self.getPos()\n            }\n          )\n          if self.peek() == \"=\" (\n            void self.consume()\n            local expr @= self.expression()\n            void self.expect(\";\")\n            return {\n              kind: \"global\",\n              name,\n              val: expr,\n              start, end: self.getPos()\n            }\n          )\n        )\n        \n        self.pointer = ptr\n        \n        void self.consumeWhitespace()\n        \n        throw \"unexpected token '\" ++ self.peek() ++ \"'\"\n      )\n      \n      def event() (\n        local start @= self.getPos()\n        void self.expect(\"event\")\n        void self.consumeWhitespace()\n        void self.expect(\"(\")\n        void self.consumeWhitespace()\n        local target @= self.eventTarget()\n        void self.consumeWhitespace()\n        void self.expect(\")\")\n        void self.consumeWhitespace()\n        local body @= self.block()\n        \n        return {\n          kind: \"event\",\n          target,\n          body,\n          start, end: self.getPos()\n        }\n      )\n      \n      def statement(noSemicolon) (\n        void self.consumeWhitespace()\n        \n        // statements\n        if self.peek() == \"{\" (\n          local start @= self.getPos()\n          local body @= self.block()\n          return {\n            kind: \"block\",\n            body,\n            start, end: self.getPos()\n          }\n        )\n        \n        if self.peek() == \"if\" (\n          local start @= self.getPos()\n          void self.consume()\n          void self.consumeWhitespace()\n          void self.expect(\"(\")\n          local ifCond @= self.expression()\n          void self.expect(\")\")\n          void self.consumeWhitespace()\n          local ifBody @= self.statement()\n          \n          local elifs @= []\n          \n          void self.consumeWhitespace()\n          while self.peek() == \"elif\" (\n            void self.consume()\n            void self.consumeWhitespace()\n            void self.expect(\"(\")\n            local elifCond @= self.expression()\n            void self.expect(\")\")\n            void self.consumeWhitespace()\n            local elifBody @= self.statement()\n            \n            void elifs.append({\n              cond: elifCond,\n              body: elifBody\n            })\n            void self.consumeWhitespace()\n          )\n          \n          local elseBody = null\n          void self.consumeWhitespace()\n          if self.peek() == \"else\" (\n            void self.consume()\n            void self.consumeWhitespace()\n            local elseBody @= self.statement()\n          )\n          \n          return {\n            kind: \"branch\",\n            cond: ifCond,\n            body: ifBody,\n            elifs,\n            elseBody,\n            start, end: self.getPos()\n          }\n        )\n        \n        if [\"while\",\"until\"].contains(self.peek()) (\n          local start @= self.getPos()\n          local kind @= self.consume()\n          void self.consumeWhitespace()\n          void self.expect(\"(\")\n          local cond @= self.expression()\n          void self.expect(\")\")\n          void self.consumeWhitespace()\n          local body @= self.statement()\n          \n          return {\n            kind,\n            cond,\n            body,\n            start, end: self.getPos()\n          }\n        )\n        \n        if self.peek() == \"repeat\" (\n          local start @= self.getPos()\n          void self.consume()\n          void self.consumeWhitespace()\n          void self.expect(\"(\")\n          local amount @= self.expression()\n          void self.expect(\")\")\n          void self.consumeWhitespace()\n          local body @= self.statement()\n          \n          return {\n            kind: \"repeat\",\n            amount,\n            body,\n            start, end: self.getPos()\n          }\n        )\n        \n        if self.peek() == \"for\" (\n          local start @= self.getPos()\n          void self.consume()\n          void self.consumeWhitespace()\n          void self.expect(\"(\")\n          local var @= self.expectText()\n          void self.consumeWhitespace()\n          void self.expect(\",\")\n          void self.consumeWhitespace()\n          local arr @= self.expression()\n          void self.expect(\")\")\n          void self.consumeWhitespace()\n          local body @= self.statement()\n          return {\n            kind: \"for\",\n            var,\n            arr,\n            body,\n            start, end: self.getPos()\n          }\n        )\n        \n        local expr @= self.expression()\n        if expr != null (\n          void self.consumeWhitespace()\n          if !noSemicolon (\n            void self.expect(\";\")\n          )\n          \n          return {\n            kind: \"expression\",\n            expr\n          }\n        ) else (\n          throw \"unexpected token '\" ++ self.peek() ++ \"'\"\n        )\n      )\n      \n      def block() (\n        local start @= self.getPos()\n        void self.expect(\"{\")\n        void self.consumeWhitespace()\n        local elements @= self.blockContent()\n        void self.consumeWhitespace()\n        void self.expect(\"}\")\n        return { elements, start, end: self.getPos() }\n      )\n      \n      // event targets\n      def eventTarget() (\n        local start @= self.getPos()\n        \n        local target @= self.target()\n        \n        void self.consumeWhitespace()\n        \n        if self.peek() == \":\" (\n          void self.consume()\n          local eventName = self.expectText()\n          return {\n            kind: \"property\",\n            target,\n            eventName,\n            start, end: self.getPos()\n          }\n        )\n        \n        self.pointer = start.i\n        \n        return {\n          kind: \"global\",\n          target: self.expectText(),\n          start, end: self.getPos()\n        }\n      )\n      \n      // targets\n      def target() (\n        local start @= self.getPos()\n        \n        if self.peek() == \"*\" (\n          void self.consume()\n          return {\n            kind: \"any\"\n          }\n        )\n        \n        local kind = \"element\"\n        \n        if self.peek() == \"#\" (\n          void self.consume()\n          void self.consumeWhitespace()\n          kind = \"id\"\n        )\n        \n        local name = self.expectText()\n        \n        return {\n          kind,\n          name\n        }\n      )\n      \n      // expressions\n      def expression() (\n        return self.declare()\n      )\n      \n      def declare() (\n        if self.peek().match(\"/^[a-zA-Z_]\\\\w*$/\") != null (\n          local start @= self.getPos()\n          local ptr = self.pointer\n          local tar = self.consume()\n          void self.consumeWhitespace()\n          if self.peek() == \":\" and self.peek(2) == \"=\" (\n            void self.consume()\n            void self.consume()\n            void self.consumeWhitespace()\n            \n            local val @= self.expression()\n            \n            return {\n              kind: \"decl\",\n              tar,\n              val,\n              start, end: self.getPos()\n            }\n          )\n          self.pointer = ptr\n        )\n        \n        return self.assignment()\n      )\n      \n      def assignment() (\n        local start @= self.getPos()\n        local expr @= self.equality()\n        void self.consumeWhitespace()\n        \n        local op = null\n        \n        if self.peek() ++ self.peek(2) == \"??\" and self.peek(3) == \"=\" (\n          op = self.peek() ++ self.peek(2)\n        )\n        \n        if self.peek(2) == \"=\" and [\"+\",\"-\",\"*\",\"/\",\"%\",\"^\"].contains(self.peek()) (\n          op = self.peek()\n        )\n        \n        if op != null or self.peek() == \"=\" (\n          if op != null (\n            loop op.len (\n              void self.consume()\n            )\n          )\n          void self.consume()\n          void self.consumeWhitespace()\n          \n          local val @= self.expression()\n          \n          return {\n            kind: \"asi\",\n            op,\n            tar: expr,\n            val,\n            start, end: self.getPos()\n          }\n        )\n        \n        return expr\n      )\n      \n      def equality() (\n        local expr @= self.comparison()\n        void self.consumeWhitespace()\n        \n        while [\"==\",\"!=\"].contains(self.peek() ++ self.peek(2)) (\n          local op @= self.consume() ++ self.consume()\n          local right @= self.comparison()\n          expr @= {\n            kind: \"binary\",\n            op,\n            left: expr,\n            right\n          }\n        )\n        \n        return expr\n      )\n      \n      def comparison() (\n        local expr @= self.term()\n        \n        local end = false\n        while !end (\n          void self.consumeWhitespace()\n          if [\">\",\"<\"].contains(self.peek()) (\n            local op @= self.consume()\n            local isEql = self.peek() == \"=\"\n            if isEql (\n              op ++= self.consume()\n            )\n            \n            local right @= self.factor()\n            \n            expr @= {\n              kind: \"binary\",\n              op,\n              left: expr,\n              right\n            }\n          ) else (\n            end = true\n          )\n        )\n        \n        return expr\n      )\n      \n      def term() (\n        local expr @= self.factor()\n        void self.consumeWhitespace()\n        \n        while [\"+\",\"-\"].contains(self.peek()) and self.peek(2) != \"=\" (\n          local op @= self.consume()\n          local right @= self.factor()\n          expr @= {\n            kind: \"binary\",\n            op,\n            left: expr,\n            right\n          }\n          void self.consumeWhitespace()\n        )\n        \n        return expr\n      )\n      \n      def factor() (\n        local expr @= self.otherBinary()\n        void self.consumeWhitespace()\n        \n        while [\"*\",\"/\"].contains(self.peek()) and self.peek(2) != \"=\" (\n          local op @= self.consume()\n          local right @= self.otherBinary()\n          expr @= {\n            kind: \"binary\",\n            op,\n            left: expr,\n            right\n          }\n          void self.consumeWhitespace()\n        )\n        \n        return expr\n      )\n      \n      def otherBinary() (\n        local expr @= self.coalescence()\n        void self.consumeWhitespace()\n        \n        while [\"%\",\"^\"].contains(self.peek()) and self.peek(2) != \"=\" (\n          local op @= self.consume()\n          local right @= self.coalescence()\n          expr @= {\n            kind: \"binary\",\n            op,\n            left: expr,\n            right\n          }\n          void self.consumeWhitespace()\n        )\n        \n        return expr\n      )\n      \n      def coalescence() (\n        local expr @= self.unary()\n        void self.consumeWhitespace()\n        \n        while self.peek() ++ self.peek(2) == \"??\" and self.peek(3) != \"=\" (\n          local op @= self.consume() ++ self.consume()\n          local right @= self.unary()\n          expr @= {\n            kind: \"binary\",\n            op,\n            left: expr,\n            right\n          }\n          void self.consumeWhitespace()\n        )\n        \n        return expr\n      )\n      \n      def unary() (\n        if self.peek(2) != \"=\" (\n          switch self.peek() (\n            case \"-\"; case \"+\"; case \"!\"; case \"?\"\n              return {\n                kind: \"unary\",\n                type: self.consume(),\n                expr: self.callExpr()\n              }\n          )\n        )\n        \n        return self.callExpr()\n      )\n      \n      def callExpr() (\n        local start @= self.getPos()\n        local expr @= self.func()\n        \n        if self.peek() == \"(\" (\n          void self.consume()\n          \n          local args @= []\n          local end = self.peek() == \")\"\n          while !end (\n            local out @= self.expression()\n            if out != null (\n              void args.append(out)\n            )\n            void self.consumeWhitespace()\n            if self.peek() == \",\" (\n              void self.consume()\n            )\n            void self.consumeWhitespace()\n            if self.peek() == \")\" or self.atEnd() (\n              end = true\n            )\n          )\n          void self.expect(\")\")\n          \n          return {\n            kind: \"call\",\n            args,\n            func: expr,\n            start, end: self.getPos()\n          }\n        )\n        \n        return expr\n      )\n      \n      def func() (\n        local start @= self.getPos()\n        \n        local is = false\n        if self.peek() == \"(\" (\n          local end = false\n          local depth = 0\n          while !end (\n            local tkn @= self.consume()\n            if tkn == \"(\" (\n              depth ++\n            )\n            if tkn == \")\" (\n              depth --\n            )\n            \n            if tkn == \")\" and depth == 0 (\n              end = true\n              is = true\n            )\n            if self.atEnd() (\n              end = true\n            )\n          )\n        )\n        void self.consumeWhitespace()\n        if is and self.peek() == \"~\" (\n          self.pointer = start.i\n          \n          local args @= []\n          void self.consume()\n          void self.consumeWhitespace()\n          local end = self.peek() == \")\"\n          if self.peek() == \")\" (\n            void self.consume()\n          )\n          while !end (\n            local tkn @= self.expectText()\n            void args.append({\n              name: tkn\n            })\n            \n            void self.consumeWhitespace()\n            local ntkn = self.expects([\",\",\")\"])\n            void self.consumeWhitespace()\n            if ntkn == \")\" or self.atEnd() (\n              end = true\n            )\n          )\n          void self.consumeWhitespace()\n          void self.expect(\"~\")\n          void self.consumeWhitespace()\n          local body @= self.statement(true)\n          return {\n            kind: \"func\",\n            args,\n            body,\n            start, end: self.getPos()\n          }\n        )\n        self.pointer = start.i\n        \n        return self.objProperty()\n      )\n      \n      def objProperty() (\n        local expr @= self.primary()\n        void self.consumeWhitespace()\n        \n        while (self.peek() == \"[\" or self.peek() == \".\") and !self.atEnd() (\n          if self.peek() == \"[\" (\n            void self.consume()\n            local key @= self.expression()\n            void self.expect(\"]\")\n          ) else if self.peek() == \".\" (\n            void self.consume()\n            local key @= self.expectText()\n          ) else (\n            throw \"unexpected token '\" ++ self.peek() ++ \"'\"\n          )\n          expr @= {\n            kind: \"prop\",\n            obj: expr,\n            key\n          }\n          if self.peek() == \"(\" (\n            void self.consume()\n            \n            local args @= []\n            local end = self.peek() == \")\"\n            while !end (\n              local out @= self.expression()\n              if out != null (\n                void args.append(out)\n              )\n              void self.consumeWhitespace()\n              if self.peek() == \",\" (\n                void self.consume()\n              )\n              void self.consumeWhitespace()\n              if self.peek() == \")\" or self.atEnd() (\n                end = true\n              )\n            )\n            void self.expect(\")\")\n            \n            expr @= {\n              kind: \"call\",\n              args,\n              func: expr\n            }\n          )\n          void self.consumeWhitespace()\n        )\n        \n        return expr\n      )\n      \n      def primary() (\n        void self.consumeWhitespace()\n        \n        if self.peek() == \"(\" (\n          void self.consume()\n          local expr @= self.expression()\n          void self.expect(\")\")\n          return expr\n        )\n        \n        if self.peek() == \"[\" (\n          return self.arr()\n        )\n        \n        if self.peek() == \"{\" (\n          return self.obj()\n        )\n        \n        if self.peek() == \"#\" (\n          return self.color()\n        )\n        \n        if [\"'\",\"\\\"\",\"`\"].contains(self.peek()) (\n          return self.str()\n        )\n        \n        if self.peek().match(\"/^[0-9]+$/\") != null (\n          return self.num()\n        )\n        \n        if self.peek().match(\"/^[a-zA-Z_\\\\$][\\\\w\\\\s\\\\$]*$/\") != null (\n          local start @= self.getPos()\n          return {\n            kind: \"var\",\n            name: self.consume(),\n            start, end: self.getPos()\n          }\n        )\n        \n        throw \"unexpected token '\" ++ self.peek() ++ \"'\"\n      )\n      \n      def arr() (\n        void self.expect(\"[\")\n        void self.consumeWhitespace()\n        \n        local elems @= []\n        \n        local end = self.peek() == \"]\"\n        while !end (\n          local expr @= self.expression()\n          void elems.append(expr)\n          \n          void self.consumeWhitespace()\n          if self.peek() == \"]\" or self.atEnd() (\n            end = true\n          ) else (\n            void self.expect(\",\")\n          )\n          void self.consumeWhitespace()\n        )\n        \n        void self.expect(\"]\")\n        \n        return {\n          kind: \"arr\",\n          elems\n        }\n      )\n      \n      def obj() (\n        void self.expect(\"{\")\n        void self.consumeWhitespace()\n        \n        local pairs @= []\n        \n        local end = self.peek() == \"}\"\n        while !end (\n          void self.consumeWhitespace()\n          local name @= self.expectText()\n          void self.consumeWhitespace()\n          void self.expect(\":\")\n          void self.consumeWhitespace()\n          local value @= self.expression()\n          \n          void pairs.append({ name, value })\n          \n          void self.consumeWhitespace()\n          if self.peek() == \"}\" (\n            end = true\n          ) else (\n            void self.expect(\",\")\n          )\n        )\n        void self.expect(\"}\")\n        \n        return {\n          kind: \"obj\",\n          pairs\n        }\n      )\n      \n      def color() (\n        local start @= self.getPos()\n        void self.expect(\"#\")\n        local value = self.consume()\n        if ![3,6].contains(value.len) (\n          throw \"hex values can only be 3 or 6 characters long\"\n        )\n        return {\n          kind: \"color\",\n          val: \"#\" ++ value,\n          start, end: self.getPos()\n        }\n      )\n      \n      def str() (\n        local start @= self.getPos()\n        local q @= self.expects([\"'\",\"\\\"\",\"`\"])\n        local content = \"\"\n        local end = false\n        while (!end) (\n          local tkn @= self.peek()\n          if tkn == \"\\\\\" (\n            void self.consume()\n            local tkn = self.consume()\n            local char = tkn[1]\n            switch char (\n              case \"n\"\n                char = \"\\n\"\n                break\n            )\n            content ++= char ++ tkn.trim(2,-1)\n            continue\n          )\n          \n          if q == tkn (\n            end = true\n          ) else (\n            content ++= self.consume()\n          )\n          if self.atEnd() (\n            end = true\n          )\n        )\n        void self.expect(q)\n        return {\n          kind: \"str\",\n          val: content,\n          start, end: self.getPos()\n        }\n      )\n      \n      def num() (\n        if self.peek().match(\"/^[0-9]+$/\") == null (\n          throw \"unexpected token '\" ++ self.peek() ++ \"'\"\n        )\n        \n        local start @= self.getPos()\n        local val @= self.consume()\n        \n        if self.peek() == \".\" (\n          val ++= self.consume()\n          if self.peek().match(\"/^[0-9]+$/\") == null (\n            throw \"unexpected token '\" ++ self.peek() ++ \"'\"\n          )\n          val ++= self.consume()\n        )\n        \n        val @= val.toNum()\n        \n        return {\n          kind: \"num\",\n          val,\n          start, end: self.getPos()\n        }\n      )\n    )\n  )\n  return __imports__2691a00e099698fa56c4748f2551eb65\ncase \"./src/rtr/main.osl\"\n  class __imports__954b63a69b7120a02fa83923726ef587 (\n    class Module (\n      def init(object ast) (\n        void self.loadFromAst(ast)\n        void self.initScope()\n        void self.defScope()\n        \n        self.eventQueue @= []\n        self.initTopDone = false\n        \n        // only used in bytecode\n        self.returnVal = null\n      )\n      def loadFromAst(object ast) (\n        self.ast @= ast\n        \n        self.events @= []\n        self.eventList @= []\n        for i self.ast.elements.len (\n          local topLevel @= self.ast.elements[i]\n          if topLevel.kind == \"event\" (\n            if topLevel.target.kind == \"global\" (\n              if self.eventList.contains(topLevel.target.target) (\n                throw topLevel.target.target + \"event already exists on module\"\n              )\n              void self.eventList.append(topLevel.target.target)\n            )\n            void self.events.append([\n              topLevel.target,\n              topLevel\n            ])\n          )\n        )\n      )\n      def initTop() (\n        if self.initTopDone (\n          return\n        )\n        self.initTopDone = true\n        \n        self.ast @= ast\n        \n        void self.newScope({})\n        for i self.ast.elements.len (\n          local topLevel @= self.ast.elements[i]\n          if topLevel.kind == \"global\" (\n            local val @= self.runExpression(topLevel.val)\n            local meta = null\n            if topLevel.auto (\n              meta @= {\n                type: val.getRtrType()\n              }\n            )\n            void self.declScopeVar(topLevel.name, val, meta)\n          )\n        )\n      )\n      \n      def initScope() (\n        self.scope @= []\n      )\n      def newScope(object vars) (\n        void self.scope.append(vars)\n      )\n      def popScope() (\n        return self.scope.pop()\n      )\n      def defScope() (\n        // helper funcs\n        local cFunc @= def(name, content) -> (\n          void self.setScopeVar(name, rtr.value.RTROslFuncValue(content))\n        )\n        \n        void self.newScope({})\n        \n        void self.setScopeVar(\"true\", rtr.value.RTRBoolValue(true))\n        void self.setScopeVar(\"false\", rtr.value.RTRBoolValue(false))\n        \n        cFunc(\"log\", def(args, inst) -> (\n          local txt = args.map(a -> a.stringify()).join(\" \")\n          log txt\n          void inst.inst.console.append([\"log\", txt])\n        ))\n        cFunc(\"error\", def(args, inst) -> (\n          local txt = args.map(a -> a.stringify()).join(\" \")\n          void inst.inst.console.append([\"err\", txt])\n          throw txt\n        ))\n        cFunc(\"return\", def(args, inst) -> (\n          local val @= args[1]\n          val ??= rtr.value.RTRNullValue()\n          void inst.setScopeVar(\"@return\", val)\n          inst.returnVal @= val\n        ))\n        cFunc(\"typeof\", def(args) -> (\n          local val @= args[1] ?? rtr.value.RTRNullValue()\n          return val.getRtrType()\n        ))\n        cFunc(\"length\", def(args) -> (\n          return rtr.value.RTRNumValue(args[1].length())\n        ))\n        \n        // mathematical\n        cFunc(\"min\", def(args) -> (\n          local v = args[1].numbify()\n          for i args.len - 1 (\n            local a @= args[i + 1].numbify()\n            v = min(v, a)\n          )\n          return rtr.value.RTRNumValue(v)\n        ))\n        cFunc(\"max\", def(args) -> (\n          local v = args[1].numbify()\n          for i args.len - 1 (\n            local a @= args[i + 1].numbify()\n            v = max(v, a)\n          )\n          return rtr.value.RTRNumValue(v)\n        ))\n        \n        cFunc(\"abs\", def(args) -> (\n          return rtr.value.RTRNumValue(args[1].numbify().abs())\n        ))\n        cFunc(\"sqrt\", def(args) -> (\n          return rtr.value.RTRNumValue(args[1].numbify().sqrt())\n        ))\n        \n        cFunc(\"round\", def(args) -> (\n          return rtr.value.RTRNumValue(args[1].numbify().round())\n        ))\n        cFunc(\"floor\", def(args) -> (\n          return rtr.value.RTRNumValue(args[1].numbify().floor())\n        ))\n        cFunc(\"ceil\", def(args) -> (\n          return rtr.value.RTRNumValue(args[1].numbify().ceiling())\n        ))\n        \n        // string\n        cFunc(\"join\", def(args) -> (\n          local txt = \"\"\n          for i args.len (\n            txt ++= args[i].stringify()\n          )\n          return rtr.value.RTRStrValue(txt)\n        ))\n        cFunc(\"split\", def(args) -> (\n          return rtr.value.RTRArrValue(args[1]\n            .stringify()\n            .split(args[2].stringify())\n            .map(e -> rtr.value.RTRStrValue(e)))\n        ))\n        \n        cFunc(\"chr\", def(args) -> (\n          return rtr.value.RTRStrValue(args[1].numbify().chr())\n        ))\n        cFunc(\"ord\", def(args) -> (\n          return rtr.value.RTRNumValue(args[1].stringify().ord())\n        ))\n        \n        cFunc(\"toUpper\", def(args) -> (\n          return rtr.value.RTRStrValue(args[1].stringify().toUpper())\n        ))\n        cFunc(\"toLower\", def(args) -> (\n          return rtr.value.RTRStrValue(args[1].stringify().toLower())\n        ))\n        cFunc(\"toTitle\", def(args) -> (\n          return rtr.value.RTRStrValue(args[1].stringify().toTitle())\n        ))\n        \n        // array\n        cFunc(\"item\", def(args) -> (\n          return args[1].getItem(args[2])\n        ))\n        cFunc(\"range\", def(args) -> (\n          return rtr.value.RTRArrValue((args[1].numbify() to args[2].numbify()).map(e -> rtr.value.RTRNumValue(e)))\n        ))\n        \n        // object\n        cFunc(\"keys\", def(args) -> (\n          return rtr.value.RTRArrValue(args[1].keys().map(e -> rtr.value.RTRStrValue(e)))\n        ))\n        cFunc(\"values\", def(args) -> (\n          return rtr.value.RTRArrValue(args[1].values())\n        ))\n        cFunc(\"has\", def(args) -> (\n          return rtr.value.RTRBoolValue(args[1].has(args[2].stringify()))\n        ))\n        cFunc(\"obj\", def() -> (\n          return rtr.value.RTRObjValue({})\n        ))\n        \n        // logical\n        cFunc(\"all\", def(args) -> (\n          return rtr.value.RTRBoolValue(args.every(a -> a.boolify()))\n        ))\n        cFunc(\"any\", def(args) -> (\n          return rtr.value.RTRBoolValue(args.some(a -> a.boolify()))\n        ))\n        cFunc(\"not\", def(args) -> (\n          return rtr.value.RTRBoolValue(!args[1].boolify())\n        ))\n      )\n      def getScopeVarRaw(string key) (\n        for rawI self.scope.len (\n          local layer @= self.scope[self.scope.len - rawI + 1]\n          if layer[key] != null (\n            return layer[key]\n          )\n        )\n        return null\n      )\n      def getScopeVar(string key) (\n        return self.getScopeVarRaw(key)[1]\n      )\n      def getScopeVarMeta(string key) (\n        return self.getScopeVarRaw(key)[2]\n      )\n      def setScopeVar(string key, val, meta) (\n        meta ??= {}\n        for rawI self.scope.len (\n          local layer @= self.scope[self.scope.len - rawI + 1]\n          if layer[key] != null (\n            layer[key] @= [val, layer[key][2] ++ meta]\n            return\n          )\n        )\n        void self.declScopeVar(key, val, meta)\n      )\n      def declScopeVar(string key, val, meta) (\n        self.scope[self.scope.len][key] @= [val, meta]\n      )\n      \n      def findEligible(object target) (\n        local evs @= []\n        \n        for i self.events.len (\n          local ev @= self.events[i][2]\n          \n          if target.element != null (\n            if ev.target.kind == \"property\" and ev.target.eventName == target.name (\n              if ev.target.target.kind == \"id\" (\n                if ev.target.target.name == target.element.id (\n                  void evs.append(ev)\n                )\n              )\n            )\n          ) else if typeof(ev.target.target) == \"string\" (\n            if ev.target.target == target.name (\n              void evs.append(ev)\n            )\n          )\n        )\n        \n        return evs\n      )\n      \n      def runEvents(object target, object data) (\n        void self.eventQueue.append([\n          \"events\",\n          target,\n          data\n        ])\n      )\n      def runEvent(object target, object data) (\n        void self.eventQueue.append([\n          \"event\",\n          target,\n          data\n        ])\n      )\n      \n      def runEventQueue() (\n        for i self.eventQueue.len (\n          local ev @= self.eventQueue.shift()\n          \n          if ev[1] == \"events\" (\n            void self.runEventsRaw(ev[2], ev[3])\n          )\n          if ev[1] == \"event\" (\n            void self.runEventRaw(ev[2], ev[3])\n          )\n        )\n      )\n      \n      def runEventsRaw(object target, object data) (\n        local evs @= self.findEligible(target)\n        \n        void self.initTop()\n        local p @= performance\n        for i evs.len (\n          void self.runBlock(evs[i].body)\n        )\n        log \"exec time\" performance - p\n      )\n      def runEventRaw(object target, object data) (\n        local ev @= self.findEligible(target)[1]\n        \n        if ev == null (\n          return rtr.value.RTRNullValue()\n        )\n        \n        void self.initTop()\n        local p @= performance\n        local out @= self.runBlock(ev.body)\n        log \"exec time\" performance - p\n        return out\n      )\n      def runBlock(object block) (\n        if shared.config.browser.phosphorus.useCompiler and block.compile == null (\n          local start = performance\n          local compileOut @= rtr.compiler.compileBlock(block)\n          if typeof(compileOut) != \"array\" and compileOut.isError (\n            block.compile = false\n          ) else (\n            block.compile @= compileOut\n          )\n          self.inst.compiled ??= []\n          void self.inst.compiled.append({\n            body: compileOut,\n            start: block.start,\n            end: block.end,\n            ast: block,\n            time: performance - start\n          })\n        )\n        if block.compile != null (\n          return self.runInstructions(block.compile)\n        )\n        \n        local elements @= block.elements\n        local outVal @= rtr.value.RTRNullValue()\n        void self.newScope({})\n        for i elements.len (\n          local out @= self.runStatement(elements[i])\n          if self.getScopeVar(\"@return\") ?? 0 != 0 (\n            outVal @= self.getScopeVar(\"@return\")\n            break\n          )\n        )\n        void self.popScope()\n        return outVal\n      )\n      def runStatement(object statement) (\n        switch statement.kind (\n          case \"expression\"\n            return self.runExpression(statement.expr)\n          case \"block\"\n            return self.runBlock(statement.body)\n          \n          case \"branch\"\n            if self.runExpression(statement.cond).boolify() (\n              return self.runStatement(statement.body)\n            )\n            for i statement.elifs.len (\n              local elif @= statement.elifs[i]\n              if self.runExpression(elif.cond).boolify() (\n                return self.runStatement(elif.body)\n              )\n            )\n            if statement.elseBody != null (\n              return self.runStatement(statement.elseBody)\n            )\n            return rtr.value.RTRNullValue()\n          \n          case \"while\"\n            local iters = 0\n            while self.runExpression(statement.cond).boolify() and self.getScopeVar(\"@return\") ?? 0 == 0 and iters < 999999 (\n              void self.runStatement(statement.body)\n              iters ++\n            )\n            return rtr.value.RTRNullValue()\n          case \"until\"\n            local iters = 0\n            while !self.runExpression(statement.cond).boolify() and self.getScopeVar(\"@return\") ?? 0 == 0 and iters < 999999 (\n              void self.runStatement(statement.body)\n              iters ++\n            )\n            return rtr.value.RTRNullValue()\n          case \"repeat\"\n            loop self.runExpression(statement.amount).numbify() (\n              void self.runStatement(statement.body)\n            )\n            return rtr.value.RTRNullValue()\n          case \"for\"\n            local arr @= self.runExpression(statement.arr).arrify()\n            for i arr.len (\n              void self.newScope({})\n              void self.declScopeVar(statement.var, arr[i])\n              void self.runStatement(statement.body)\n              void self.popScope()\n            )\n            return rtr.value.RTRNullValue()\n          \n          default\n            throw \"unknown statement type\" + statement.kind\n        )\n      )\n      def runExpression(object expression) (\n        switch expression.kind (\n          case \"call\"\n            local func @= self.runExpression(expression.func)\n            local args @= []\n            for i expression.args.len (\n              void args.append(self.runExpression(expression.args[i]))\n            )\n            return func.callFunc(self, args) ?? rtr.value.RTRNullValue()\n          case \"decl\"\n            local val @= self.runExpression(expression.val)\n            \n            void self.declScopeVar(expression.tar, val, {\n              type: val.getRtrType()\n            })\n            \n            return val\n          case \"asi\"\n            local val @= self.runExpression(expression.val)\n            \n            local existingMeta = null\n            local existing = null\n            switch expression.tar.kind (\n              case \"var\"\n                existingMeta @= self.getScopeVarMeta(expression.tar.name)\n                existing @= self.getScopeVar(expression.tar.name)\n                break\n              case \"prop\"\n                existing @= self.runExpression(expression.tar)\n                break\n            )\n            \n            if expression.op != null (\n              val @= self.runBinary(existing, expression.op, val)\n            )\n            \n            switch expression.tar.kind (\n              case \"var\"\n                if existingMeta != null (\n                  local curType @= val.getRtrType()\n                  if existingMeta.type != null (\n                    if !existingMeta.type.isEqual(curType) (\n                      throw \"cannot assign\" + curType.stringify() + \"to\" + existingMeta.type.stringify() + \"variable\" \n                    )\n                  )\n                )\n                void self.setScopeVar(expression.tar.name, val)\n                break\n              case \"prop\"\n                local obj @= self.runExpression(expression.tar.obj)\n                local key @= expression.tar.key\n                if typeof(key) == \"string\" (\n                  key @= rtr.value.RTRStrValue(key)\n                ) else (\n                  key @= self.runExpression(key)\n                )\n                void obj.setItem(key, val)\n                break\n              default\n                throw \"cannot assign to\" + expression.tar.kind\n            )\n            \n            return val\n          case \"unary\"\n            local val @= self.runExpression(expression.expr)\n            return self.runUnary(expression.type, val)\n          case \"binary\"\n            local left @= self.runExpression(expression.left)\n            local right @= self.runExpression(expression.right)\n            return self.runBinary(left, expression.op, right)\n          \n          case \"var\"\n            local val @= self.getScopeVar(expression.name)\n            return val ?? rtr.value.RTRNullValue()\n          case \"prop\"\n            local obj @= self.runExpression(expression.obj)\n            local key @= expression.key\n            if typeof(key) == \"string\" (\n              key @= rtr.value.RTRStrValue(key)\n            ) else (\n              key @= self.runExpression(key)\n            )\n            return obj.getItem(key) ?? rtr.value.RTRNullValue()\n          \n          case \"str\"\n            return rtr.value.RTRStrValue(expression.val)\n          case \"num\"\n            return rtr.value.RTRNumValue(expression.val)\n          case \"func\"\n            return rtr.value.RTRAstFuncValue(expression.args, expression.body)\n          case \"arr\"\n            return rtr.value.RTRArrValue(expression.elems.map(e -> self.runExpression(e)))\n          case \"obj\"\n            local val @= {}\n            for i expression.pairs.len (\n              local pair @= expression.pairs[i]\n              val[pair.name] @= self.runExpression(pair.value)\n            )\n            return rtr.value.RTRObjValue(val)\n          case \"color\"\n            return rtr.value.RTRColorValue(expression.val)\n          \n          default\n            throw \"unknown expression type\" + expression.kind\n        )\n      )\n      def runUnary(string op, object val) (\n        switch op (\n          case \"-\"\n            return rtr.value.RTRNumValue(-val.numbify())\n          case \"+\"\n            return rtr.value.RTRNumValue(val.numbify())\n          case \"!\"\n            return rtr.value.RTRBoolValue(!val.boolify())\n          case \"?\"\n            return rtr.value.RTRBoolValue(val.boolify())\n        )\n        return rtr.value.RTRNullValue()\n      )\n      def runBinary(object left, string op, object right) (\n        local numT @= rtr.value.RTRNumValue.getRtrType()\n        switch op (\n          case \"+\"\n            if left.getRtrType().isEqual(numT) and right.getRtrType().isEqual(numT) (\n              return rtr.value.RTRNumValue(left.numbify() + right.numbify())\n            )\n            return rtr.value.RTRStrValue(left.stringify() ++ right.stringify())\n          case \"-\"\n            if left.getRtrType().isEqual(numT) and right.getRtrType().isEqual(numT) (\n              return rtr.value.RTRNumValue(left.numbify() - right.numbify())\n            )\n            return rtr.value.RTRNumValue(NaN)\n          case \"*\"\n            if left.getRtrType().isEqual(numT) and right.getRtrType().isEqual(numT) (\n              return rtr.value.RTRNumValue(left.numbify() * right.numbify())\n            )\n            return rtr.value.RTRNumValue(NaN)\n          case \"/\"\n            if left.getRtrType().isEqual(numT) and right.getRtrType().isEqual(numT) (\n              return rtr.value.RTRNumValue(left.numbify() / right.numbify())\n            )\n            return rtr.value.RTRNumValue(NaN)\n          case \"%\"\n            if left.getRtrType().isEqual(numT) and right.getRtrType().isEqual(numT) (\n              return rtr.value.RTRNumValue(left.numbify() % right.numbify())\n            )\n            return rtr.value.RTRNumValue(NaN)\n          case \"^\"\n            if left.getRtrType().isEqual(numT) and right.getRtrType().isEqual(numT) (\n              return rtr.value.RTRNumValue(left.numbify() ^ right.numbify())\n            )\n            return rtr.value.RTRNumValue(NaN)\n          \n          case \"==\"\n            return rtr.value.RTRBoolValue(left.isEqual(right))\n          case \"!=\"\n            return rtr.value.RTRBoolValue(left.isEqual(right))\n          \n          case \">\"\n            return rtr.value.RTRBoolValue(left.numbify() > right.numbify())\n          case \"<\"\n            return rtr.value.RTRBoolValue(left.numbify() < right.numbify())\n          case \">=\"\n            return rtr.value.RTRBoolValue(left.numbify() >= right.numbify())\n          case \"<=\"\n            return rtr.value.RTRBoolValue(left.numbify() <= right.numbify())\n        \n          case \"??\"\n            return left.getRtrType().data.name == \"null\" ? right left\n        )\n        \n        return rtr.value.RTRNullValue()\n      )\n      \n      def runInstructions(array instructions) (\n        self.stack ??= []\n        \n        local labels @= {}\n        \n        for i instructions.len (\n          local instruction @= instructions[i]\n          if instruction.kind == \"label\" (\n            labels[instruction.name] = i\n          )\n        )\n        \n        local i = 0\n        local iters = 0\n        while i < instructions.len and iters < 1000 (\n          i ++\n          iters ++\n          local instruction @= instructions[i]\n          //log i iters instruction self.stack.map(s -> s.stringify())\n          switch instruction.kind (\n            case \"label\"; break\n            case \"jump\"\n              i = labels[instruction.label] ?? i\n              break\n            case \"jumpIf\"\n              local val @= self.stack.pop() ?? rtr.value.RTRNullValue()\n              if val.boolify() (\n                i = labels[instruction.label] ?? i\n              )\n              break\n            case \"jumpNotIf\"\n              local val @= self.stack.pop() ?? rtr.value.RTRNullValue()\n              if !val.boolify() (\n                i = labels[instruction.label] ?? i\n              )\n              break\n            \n            case \"call\"\n              local args @= []\n              loop instruction.args (\n                void args.prepend(self.stack.pop() ?? rtr.value.RTRNullValue())\n              )\n              local func @= self.stack.pop() ?? rtr.value.RTRNullValue()\n              local out @= func.callFunc(self, args) ?? rtr.value.RTRNullValue()\n              if self.returnVal != null (\n                local out @= self.returnVal\n                self.returnVal = null\n                return out\n              )\n              void self.stack.append(out)\n              break\n            case \"unary\"\n              local val @= self.stack.pop() ?? rtr.value.RTRNullValue()\n              void self.stack.append(self.runUnary(instruction.op, val))\n              break\n            case \"binary\"\n              local right @= self.stack.pop() ?? rtr.value.RTRNullValue()\n              local left @= self.stack.pop() ?? rtr.value.RTRNullValue()\n              void self.stack.append(self.runBinary(left, instruction.op, right))\n              break\n            case \"prop\"\n              local key @= self.stack.pop() ?? rtr.value.RTRNullValue()\n              local obj @= self.stack.pop() ?? rtr.value.RTRNullValue()\n              void self.stack.append(obj.getItem(key))\n              break\n            case \"len\"\n              local obj @= self.stack.pop() ?? rtr.value.RTRNullValue()\n              void self.stack.append(rtr.value.RTRNumValue(obj.length()))\n              break\n              \n            case \"null\"\n              void self.stack.append(rtr.value.RTRNullValue())\n              break\n            case \"str\"\n              void self.stack.append(rtr.value.RTRStrValue(instruction.data))\n              break\n            case \"bool\"\n              void self.stack.append(rtr.value.RTRBoolValue(instruction.data))\n              break\n            case \"num\"\n              void self.stack.append(rtr.value.RTRNumValue(instruction.data))\n              break\n            case \"func\"\n              void self.stack.append(rtr.value.RTRBytecodeFuncValue(instruction.args, instruction.body))\n              break\n            case \"arr\"\n              local elems @= []\n              loop instruction.elems (\n                void elems.prepend(self.stack.pop() ?? rtr.value.RTRNullValue())\n              )\n              void self.stack.append(rtr.value.RTRArrValue(elems))\n              break\n            case \"obj\"\n              local values @= []\n              loop instruction.keys.len (\n                void values.prepend(self.stack.pop() ?? rtr.value.RTRNullValue())\n              )\n              \n              local obj @= {}\n              for obji values.len (\n                obj[instruction.keys[obji]] @= values[obji]\n              )\n              void self.stack.append(rtr.value.RTRObjValue(obj))\n              break\n            case \"color\"\n              void self.stack.append(rtr.value.RTRColorValue(instruction.data))\n              break\n            \n            case \"get\"\n              local val @= self.getScopeVar(instruction.name) ?? rtr.value.RTRNullValue()\n              void self.stack.append(val)\n              break\n            case \"decl\"\n              local val @= self.stack[-1] ?? rtr.value.RTRNullValue()\n              void self.declScopeVar(instruction.name, val, {\n                type: val.getRtrType()\n              })\n              break\n            case \"newScope\"\n              void self.newScope({})\n              break\n            case \"popScope\"\n              void self.popScope()\n              break\n            \n            case \"asivar\"\n              local val @= self.stack[-1] ?? rtr.value.RTRNullValue()\n              \n              local existingMeta @= self.getScopeVarMeta(instruction.name)\n              local existing @= self.getScopeVar(instruction.name)\n              \n              if instruction.op != null (\n                val @= self.runBinary(existing, instruction.op, val)\n              )\n              \n              local curType @= val.getRtrType()\n              if existingMeta.type != null (\n                if !existingMeta.type.isEqual(curType) (\n                  // replace with return err\n                  throw \"cannot assign\" + curType.stringify() + \"to\" + existingMeta.type.stringify() + \"variable\" \n                )\n              )\n              \n              void self.setScopeVar(instruction.name, val)\n              break\n            case \"asiprop\"\n              local key @= self.stack.pop() ?? rtr.value.RTRNullValue()\n              local obj @= self.stack.pop() ?? rtr.value.RTRNullValue()\n              \n              local val @= self.stack[-1] ?? rtr.value.RTRNullValue()\n              if instruction.op != null (\n                val @= self.runBinary(obj.getItem(key), instruction.op, val)\n              )\n              \n              void obj.setItem(key, val)\n              break\n            \n            case \"pop\"\n              void self.stack.pop()\n              break\n            case \"dupe\"\n              void self.stack.append(self.stack[instruction.i])\n              break\n            \n            default\n              return rtr.error.Error(\"UnknownInstructionKind\", { kind: instruction.kind })\n          )\n          \n        )\n        \n        return rtr.value.RTRNullValue()\n      )\n    )\n    \n    class RTR (\n      def init() (\n        self.modules @= {}\n        self.console @= []\n        self.ouid = OuidNew()\n        \n        self.started = false\n      )\n    \n      def addModule(object mod) (\n        local key @= OuidNew()\n        mod.inst @= self\n        self.modules[key] @= mod\n        return key\n      )\n      \n      def startModules() (\n        if !self.started (\n          self.started = true\n          void self.runEvent({\n           name: \"onload\"\n          }, {})\n        )\n      )\n      \n      def runEvent(object target, object data) (\n        local mods @= self.modules.getValues()\n        for i mods.len (\n          void mods[i].runEvent(target, data)\n        )\n      )\n      def runEvents(object target, object data) (\n        local mods @= self.modules.getValues()\n        for i mods.len (\n          void mods[i].runEvents(target, data)\n        )\n      )\n    )\n  )\n  return __imports__954b63a69b7120a02fa83923726ef587\ncase \"./src/rwl/ast.osl\"\n  class __imports__823191bbaeb9397e6eaf51c446a37c4c (\n    class Parser (\n      def init(string text) (\n        void self.tokenise(text)\n      )\n      \n      def parse() (\n        self.pointer = 1\n        \n        local out @= {\n          elements: self.blockContent()\n        }\n        \n        if !self.atEnd() (\n          throw \"unexpected token '\" ++ self.peek() ++ \"'\"\n        )\n        \n        return out\n      )\n      \n      def peek() (\n        return self.tokens[self.pointer]\n      )\n      def consume() (\n        local tkn = self.peek()\n        self.pointer ++\n        return tkn\n      )\n      def consumeWhitespace() (\n        while self.peek().match(\"/^\\\\s$/\") != null (\n          void self.consume()\n        )\n      )\n      def consumeSpaces() (\n        local txt = \"\"\n        while self.peek() == \" \" (\n          txt ++= self.consume()\n        )\n        return txt\n      )\n      def atEnd() (\n        return self.pointer >= self.tokens.len\n      )\n      def expect(string token) (\n        local tkn @= self.consume()\n        if tkn != token (\n          throw \"expected '\" ++ token ++ \"' got '\" ++ tkn ++ \"'\"\n        )\n        return tkn\n      )\n      def expects(array tokens) (\n        local tkn @= self.consume()\n        if !tokens.contains(tkn) (\n          throw \"expected '\" ++ tokens.join(\" or \") ++ \"' got '\" ++ tkn ++ \"'\"\n        )\n        return tkn\n      )\n      def expectText() (\n        local tkn @= self.consume()\n        if !tkn.match(\"/^[a-zA-Z_0-9]+$/\") (\n          throw \"identifier must consist of letters or _\"\n        )\n        return tkn\n      )\n      def getPos() (\n        local ln = 1\n        local col = 0\n        local i = self.pointer\n        for t self.pointer (\n          col ++\n          if self.tokens[t] == \"\\n\" (\n            ln ++\n            col = 0\n          )\n        )\n        return { ln, col, i }\n      )\n      \n      def tokenise(string text) (\n        self.tokens @= []\n        local splitChars @= [\n          // rwl\n          \"{\",\"}\",\n          \"[\",\"]\",\n          \",\",\n          \" \",\n          \"\\n\",\n          \"/\",\"\\\\\",\"*\",\n          \"'\",\"\\\"\",\"`\",\n          \":\",\"#\",\"%\",\"=\",\n          // rtr\n          \"(\",\")\",\n          \"[\",\"]\",\n          \"{\",\"}\",\n          \",\",\";\",\":\",\"=\",\".\",\n          \"+\",\"-\",\"*\",\"/\",\"%\",\"^\",\n          \"\\\\\",\n          \"'\",\"\\\"\",\"`\",\n          \" \",\"\\n\",\n          \"!\",\"?\"\n        ]\n        local buf = \"\"\n        for i text.len (\n          if splitChars.contains(text[i]) (\n            if buf.len > 0 (\n              void self.tokens.append(buf)\n            )\n            void self.tokens.append(text[i])\n            buf = \"\"\n          ) else (\n            buf ++= text[i]\n          )\n        )\n        if buf.len > 0 (\n          self.tokens.append(buf)\n        )\n      )\n      \n      // statements\n      def blockContent() (\n        local statements @= []\n        local end = false\n        while !end (\n          local out @= self.statement()\n          if out != null (\n            void statements.append(out)\n          )\n          void self.consumeWhitespace()\n          if self.peek() == \"}\" or self.atEnd() (\n            end = true\n          ) else (\n            void self.expect(\",\")\n          )\n        )\n        return statements\n      )\n      \n      def statement() (\n        void self.consumeWhitespace()\n        \n        local start @= self.getPos()\n        local tkn @= self.peek()\n        \n        // void elements\n        if [\"icon\",\"image\"].contains(tkn) (\n          void self.consume()\n          void self.consumeWhitespace()\n          local header @= self.header()\n          \n          return {\n            data: {\n              header\n            },\n            kind: tkn,\n            start, end: self.getPos()\n          }\n        )\n        \n        // block\n        if tkn.match(\"/^[a-zA-Z]+$/\") != null (\n          return self.blockStatement()\n        )\n        \n        // element\n        local value @= self.value()\n        if value != null (\n          void self.consumeWhitespace()\n          local header @= self.header()\n          \n          return {\n            data: {\n              value,\n              header\n            },\n            kind: \"element\",\n            start, end: self.getPos()\n          }\n        )\n      )\n      \n      def blockStatement() (\n        local start @= self.getPos()\n        local key @= self.consume()\n        \n        void self.consumeWhitespace()\n        \n        local header @= self.header()\n        header.key = key\n        \n        void self.consumeWhitespace()\n        \n        if key == \"script\" (\n          local content = \"\"\n          local spaceContent = \"\"\n          void self.expect(\"{\")\n          local end = false\n          local depth = 1\n          local stringType = null\n          while !end (\n            local tkn @= self.peek()\n            \n            if tkn == \"'\" (\n              if stringType == \"'\" (\n                stringType = null\n              ) else if stringType == null (\n                stringType = \"'\"\n              )\n            )\n            \n            if tkn == \"\\\"\" (\n              if stringType == \"\\\"\" (\n                stringType = null\n              ) else if stringType == null (\n                stringType = \"\\\"\"\n              )\n            )\n            \n            if tkn == \"`\" (\n              if stringType == \"`\" (\n                stringType = null\n              ) else if stringType == null (\n                stringType = \"`\"\n              )\n            )\n            \n            if stringType == null (\n              if tkn == \"{\" (\n                depth ++\n              )\n              if tkn == \"}\" (\n                depth --\n              )\n            )\n            \n            if self.atEnd() or (tkn == \"}\" and depth == 0 and stringType == null) (\n              end = true\n            ) else (\n              if tkn == \"\\n\" (\n                spaceContent = \"\"\n                void self.consume()\n                if content != \"\" (\n                  content ++= \"\\n\"\n                )\n              ) else if tkn == \" \" (\n                spaceContent ++= self.consume()\n              ) else (\n                content ++= spaceContent\n                content ++= self.consume()\n                spaceContent = \"\"\n              )\n            )\n          )\n          void self.expect(\"}\")\n        ) else (\n          local content @= self.block()\n        )\n        \n        return {\n          kind: \"block\",\n          data: {\n            header,\n            content\n          },\n          start, end: self.getPos()\n        }\n      )\n      \n      def block() (\n        local start @= self.getPos()\n        void self.expect(\"{\")\n        void self.consumeWhitespace()\n        local elements @= self.blockContent()\n        void self.consumeWhitespace()\n        void self.expect(\"}\")\n        return { elements, start, end: self.getPos() }\n      )\n      \n      // header stuff\n      def header() (\n        local start @= self.getPos()\n        local attributes @= []\n        if self.peek() == \"[\" (\n          void self.expect(\"[\")\n          local end = self.peek() == \"]\"\n          while !end (\n            local out @= self.headerItem()\n            if out != null (\n              void attributes.append(out)\n            )\n            void self.consumeWhitespace()\n            if self.peek() == \",\" (\n              void self.consume()\n            )\n            if self.peek() == \"]\" or self.atEnd() (\n              end = true\n            )\n          )\n          void self.expect(\"]\")\n        )\n        \n        return { attributes, start, end: self.getPos() }\n      )\n      def headerItem() (\n        void self.consumeWhitespace()\n        local start @= self.getPos()\n        local tkn @= self.consume()\n        void self.consumeWhitespace()\n        if self.peek() == \"=\" (\n          if tkn.match(\"/^[a-zA-Z_]+$/\") == null (\n            throw \"attribute key must consist of letters or _\"\n          )\n          void self.consume()\n          local value @= self.value()\n          return {\n            kind: \"key\",\n            key: tkn,\n            value,\n            start, end: self.getPos()\n          }\n        )\n        if tkn.match(\"/^[a-zA-Z_]+$/\") != null (\n          return {\n            kind: \"flag\",\n            data: tkn,\n            start, end: self.getPos()\n          }\n        )\n      )\n      \n      // values\n      def value() (\n        if [\"'\",\"\\\"\",\"`\"].contains(self.peek()) (\n          return self.str()\n        )\n        \n        if self.peek().match(\"/^[0-9]+$/\") != null (\n          return self.num()\n        )\n        \n        if self.peek() == \"#\" (\n          return self.color()\n        )\n        \n        if self.peek().match(\"/^\\\\w+$/\") != null (\n          return self.property()\n        )\n      )\n      \n      def str() (\n        local start @= self.getPos()\n        local q @= self.expects([\"'\",\"\\\"\",\"`\"])\n        local content = \"\"\n        local end = false\n        while !end (\n          local tkn @= self.peek()\n          if tkn == \"\\\\\" (\n            void self.consume()\n            local tkn = self.consume()\n            local char = tkn[1]\n            switch char (\n              case \"n\"\n                char = \"\\n\"\n                break\n            )\n            content ++= char ++ tkn.trim(2,-1)\n            continue\n          )\n          \n          if q == tkn (\n            end = true\n          ) else (\n            content ++= self.consume()\n          )\n          if self.atEnd() (\n            end = true\n          )\n        )\n        void self.expect(q)\n        return {\n          type: \"str\",\n          value: content,\n          start, end: self.getPos()\n        }\n      )\n      \n      // and percentage\n      def num() (\n        if self.peek().match(\"/^[0-9]+$/\") == null (\n          throw \"unexpected token '\" ++ self.peek() ++ \"'\"\n        )\n        \n        local start @= self.getPos()\n        \n        local value @= self.consume().toNum()\n        \n        local type = \"num\"\n        \n        if self.peek() == \"%\" (\n          void self.consume()\n          type = \"percentage\"\n        )\n        \n        return {\n          type,\n          value,\n          start, end: self.getPos()\n        }\n      )\n      \n      def color() (\n        local start @= self.getPos()\n        void self.expect(\"#\")\n        local value = self.consume()\n        if ![3,6].contains(value.len) (\n          throw \"hex values can only be 3 or 6 characters long\"\n        )\n        return {\n          type: \"color\",\n          value: \"#\" ++ value,\n          start, end: self.getPos()\n        }\n      )\n      \n      def property() (\n        local start @= self.getPos()\n        local source = self.consume()\n        if source.match(\"/^[a-zA-Z_]+$/\") == null (\n          throw \"source must consist of letters or _\"\n        )\n        \n        void self.consumeWhitespace()\n        void self.expect(\":\")\n        void self.consumeWhitespace()\n        \n        local name = self.consume()\n        if name.match(\"/^[a-zA-Z_]+$/\") == null (\n          throw \"name must consist of letters or _\"\n        )\n        \n        return {\n          type: \"property\",\n          source,\n          name,\n          start, end: self.getPos()\n        }\n      )\n    )\n  )\n  return __imports__823191bbaeb9397e6eaf51c446a37c4c\ncase \"./src/rwl/debug.osl\"\n  class __imports__a02a29842cf0d752bb9291888afe9568 (\n    def box(array area, color) (\n      if !rwl.main.debug (\n        return\n      )\n      void shared.graphics.box(area, color ?? #f00)\n    )\n  )\n  return __imports__a02a29842cf0d752bb9291888afe9568\ncase \"./src/rwl/value.osl\"\n  class __imports__b6b9b465fcf5c8c4f9d5fe786e8bce9c (\n    class RWLValue (\n      \n    )\n    \n    class RWLStrValue extends RWLValue (\n      type = \"str\"\n      def init(string value) (\n        self.value @= value\n      )\n    )\n    \n    class RWLNumValue extends RWLValue (\n      type = \"num\"\n      def init(number value) (\n        self.value @= value\n      )\n    )\n    \n    class RWLPercentageValue extends RWLValue (\n      type = \"percentage\"\n      def init(number value) (\n        self.value @= value\n      )\n    )\n    \n    class RWLColorValue extends RWLValue (\n      type = \"color\"\n      def init(string value) (\n        self.value @= value\n      )\n    )\n    \n    def AstToValue(ast) (\n      switch ast.type (\n        case \"str\"\n          return rwl.value.RWLStrValue(ast.value)\n        case \"num\"\n          return rwl.value.RWLNumValue(ast.value)\n        case \"percentage\"\n          return rwl.value.RWLPercentageValue(ast.value)\n        case \"color\"\n          return rwl.value.RWLColorValue(ast.value)\n        case \"property\"\n          switch ast.source (\n            case \"theme\"\n              local col = shared.theme[ast.name]\n              if typeof(col) == \"string\" (\n                return rwl.value.RWLColorValue(col)\n              )\n              break\n            default\n              return rwl.error.Error(\"UnknownPropertySource\", {\n                source: ast.source\n              })\n          )\n          return rwl.error.Error(\"UnknownProperty\", {\n            property: ast.name,\n            source: ast.source\n          })\n        default\n          return rwl.error.Error(\"UnknownValueType\", {\n            valueType: ast.type\n          })\n      )\n    )\n  )\n  return __imports__b6b9b465fcf5c8c4f9d5fe786e8bce9c\ncase \"./src/rwl/error.osl\"\n  class __imports__c17b91d805bd65a760423a0b948a2c09 (\n    object Errors = {\n      UnknownElementKind: def(data) -> (\n        return \"unknown element kind:\" + data.elementKind\n      ),\n      UnknownAttributeKind: def(data) -> (\n        return \"unknown attribute kind:\" + data.attributeKind\n      ),\n      \n      UnknownValueType: def(data) -> (\n        return \"unknown value type:\" + data.valueType\n      ),\n      UnknownBlockType: def(data) -> (\n        return \"unknown block type:\" + data.blockType\n      ),\n      \n      InvalidAnchorName: def(data) -> (\n        return \"unknown anchor name\" + data.name\n      ),\n      InvalidAlignmentName: def(data) -> (\n        return \"unknown anchor name\" + data.name\n      ),\n      \n      InvalidElemType: def(data) -> (\n        return \"cannot have\" + data.valueType + \"as element\"\n      ),\n      \n      ValueTypeMismatch: def(data) -> (\n        if typeof(data.wanted) == \"string\" (\n          data.wanted @= [data.wanted]\n        )\n        local forCtx = \"\"\n        if data.attr != null (\n          forCtx += \"for\" + data.attr\n        )\n        return \"wanted\" + data.wanted.join(\" or \") + \"got\" + data.got ++ forCtx\n      ),\n      \n      UnknownProperty: def(data) -> (\n        return \"unknown property\" + data.property + \"on\" + data.source\n      ),\n      UnknownPropertySource: def(data) -> (\n        return \"unknown source\" + data.source\n      ),\n      \n      ElemInFrame: def(data) -> (\n        return \"element in a frame, only sections are allowed directly in frames\"\n      ),\n      \n      NoScriptType: def(data) -> (\n        return \"no script type attribute\"\n      ),\n      InvalidScriptType: def(data) -> (\n        return \"unknown script type\" + data.type\n      ),\n      InvalidScriptAttrType: def(data) -> (\n        return \"unknown script type attribute type\" + data.type\n      ),\n      \n      NoIconSrc: def(data) -> (\n        return \"icon has no src\"\n      )\n    }\n    \n    class Error (\n      boolean isError = true\n      \n      def init(string type, object data) (\n        self.type = type\n        self.data @= data\n        \n        local err @= rwl.error.Errors[type]\n        if err == null (\n          self.type = \"UnknownErrorType\"\n          self.txt = \"unknown error type\" + type\n          return\n        )\n        self.txt = err(data)\n      )\n      \n      def stringify() (\n        return \"Error<\" ++ self.type ++ \">:\\n\" ++ self.txt.split(\"\\n\").map(l -> \"    \" ++ l).join(\"\\n\")\n      )\n    )\n  )\n  return __imports__c17b91d805bd65a760423a0b948a2c09\ncase \"./src/rwl/area.osl\"\n  class __imports__51b19cf190821eee598f3dc8fa9be944 (\n    def copy(area) (\n      return [area[1], area[2], area[3], area[4]]\n    )\n    \n    def centerX(area) (\n      return area[1] + area[3] / 2\n    )\n    \n    def centerY(area) (\n      return area[2] + area[4] / 2\n    )\n    \n    def width(area) (\n      return area[3] - area[1]\n    )\n    \n    def height(area) (\n      return area[4] - area[2]\n    )\n    \n    def pad(area, pad) (\n      return [\n        area[1] + pad[1],\n        area[2] + pad[2],\n        area[3] - pad[3],\n        area[4] - pad[4]\n      ]\n    )\n    \n    def margin(area, mar) (\n      return [\n        area[1] - mar[1],\n        area[2] - mar[2],\n        area[3] + mar[3],\n        area[4] + mar[4]\n      ]\n    )\n  )\n  return __imports__51b19cf190821eee598f3dc8fa9be944\ncase \"./src/rwl/config.osl\"\n  class __imports__997006161a7103fcb97a4e4d8f4a25b1 (\n    goob = \"hi\"\n  )\n  return __imports__997006161a7103fcb97a4e4d8f4a25b1\ncase \"./src/rwl/main.osl\"\n  class __imports__b471b13f60903428337025313115b852 (\n    debug = false\n    \n    class RWLNode (\n      // global attributes\n      def initGlobal() (\n        self.elemI = rwl.main.elemI\n        rwl.main.elemI ++\n        self.updateGlobal()\n      )\n      def updateGlobal(area, context) (\n        self.id = null\n        \n        local id @= self.expectOnHeader(\"id\", \"str\")\n        if id.isError (\n          return id\n        )\n        if id != null (\n          self.id = id.value\n        )\n        \n        self.cu_area @= area\n        self.cu_context @= context\n        void self.checkUpdate()\n      )\n      \n      def updateFromCache() (\n        if self.cu_area != null (\n          void self.update(self.cu_area, self.cu_context)\n        )\n      )\n      \n      def updateParentFromCache() (\n        if self.parent != null and self.parent.name != null (\n          void self.parent.updateFromCache()\n        ) else (\n          void self.updateFromCache()\n        )\n      )\n      \n      def checkUpdate() (\n        if self.needsUpdate (\n          self.needsUpdate = false\n          void self.updateFromCache()\n        )\n        \n        // used when this was a branch like system\n        //if self.children != null (\n        //  for i self.children.len (\n        //    void self.children[i].checkUpdate()\n        //  )\n        //)\n      )\n      \n      def update() (\n        \n      )\n      \n      def topUpdate() (\n        \n      )\n      \n      def interactUpdate() (\n        \n      )\n      \n      def render() (\n        \n      )\n      \n      def renderDevtools() (\n        \n      )\n      \n      def expectOnHeader(string key, string type) (\n        for attrI self.header.pairs.len (\n          local attr @= self.header.pairs[attrI]\n          if attr[2].isError (\n            return attr[2]\n          )\n          if attr[1] == key (\n            if attr[2].type != type (\n              return rwl.error.Error(\"ValueTypeMismatch\", {\n                wanted: type,\n                got: attr[2].type\n              })\n            ) else (\n              return attr[2]\n            )\n          )\n        )\n        return null\n      )\n      \n      def getAreaKeys(string name, pairs) (\n        local l = 0\n        local r = 0\n        local b = 0\n        local t = 0\n        \n        pairs ??= self.header.pairs\n        for pairI pairs.len (\n          local pair @= pairs[pairI]\n          local n = pair[1]\n          local value @= pair[2]\n          \n          if n == name (\n            l = value.value\n            r = value.value\n            b = value.value\n            t = value.value\n          ) else if n == name ++ \"_x\" (\n            l = value.value\n            r = value.value\n          ) else if n == name ++ \"_y\" (\n            b = value.value\n            t = value.value\n          ) else if n == name ++ \"_l\" or n == name ++ \"_left\" (\n            l = value.value\n          ) else if n == name ++ \"_r\" or n == name ++ \"_right\" (\n            r = value.value\n          ) else if n == name ++ \"_b\" or n == name ++ \"_bottom\" (\n            b = value.value\n          ) else if n == name ++ \"_t\" or n == name ++ \"_top\" (\n            t = value.value\n          )\n        )\n        \n        return [l, b, r, t]\n      )\n      \n      def getPadding(pairs) (\n        return self.getAreaKeys(\"padding\", pairs)\n      )\n      def getMargin(pairs) (\n        return self.getAreaKeys(\"margin\", pairs)\n      )\n    )\n    \n    class RWLContainer extends RWLNode (\n      kind = \"block\"\n      def init(array children, object header) (\n        self.children @= children\n        self.header @= header\n        void self.initGlobal()\n      )\n      \n      def update(array area, object context) (\n        void self.updateBackgroundColor()\n        void self.updateBackground(area)\n        void self.updateGlobal(area, context)\n        \n        local childArea @= rwl.area.pad(area, self.getPadding())\n        \n        self.area @= area\n        self.childArea @= childArea\n        \n        return rwl.main.UpdateElements(self.children, childArea, {\n          anchorX: \"c\",\n          anchorY: \"c\",\n          color: \"#fff\",\n          inst: context.inst\n        }, self)\n      )\n      \n      def interactUpdate(object context) (\n        for i self.children.len (\n          void self.children[i].interactUpdate(context)\n        )\n      )\n      \n      def updateBackgroundColor() (\n        local color @= self.expectOnHeader(\"color\", \"color\")\n        \n        if color != null (\n          self.color @= color.value\n        )\n      )\n      \n      def updateBackground(array area) (\n        self.area @= area\n        \n        local allRounding @= self.expectOnHeader(\"rounding\", \"num\")\n        \n        local rounding @= allRounding.value ?? 0\n        \n        local corners @= [\"bl\",\"br\",\"tl\",\"tr\"]\n        for i corners.len (\n          local corner @= self.expectOnHeader(\"rounding_\" ++ corners[i], \"num\")\n          if corner != null (\n            if typeof(rounding) != \"array\" (\n              rounding @= []\n              loop i - 1 (\n                void rounding.append(allRounding.value ?? 0)\n              )\n            )\n            void rounding.append(corner.value ?? 0)\n          ) else (\n            void rounding.append(allRounding.value ?? 0)\n          )\n        )\n        self.rounding @= rounding\n        \n        void self.updateBackgroundColor()\n      )\n      \n      def render() (\n        if self.header.flags.contains(\"Hidden\") (\n          void self.renderDevtools()\n          return\n        )\n        \n        void self.renderBackground()\n        if rwl.main.debug (\n          void rwl.debug.box(self.area, #f00)\n          void rwl.debug.box(self.childArea, #0f0)\n        )\n        void rwl.main.RenderElements(self.children)\n        void self.renderDevtools()\n      )\n      \n      def renderDevtools() (\n        if self.elemI == devtools.main.hoveredElement (\n          self.childArea ??= self.area\n          \n          // left\n          void shared.graphics.filledTransparentArea([\n            self.area[1],\n            self.area[2],\n            self.childArea[1],\n            self.area[4]\n          ], #f0f, 20)\n          // right\n          void shared.graphics.filledTransparentArea([\n            self.childArea[3],\n            self.area[2],\n            self.area[3],\n            self.area[4]\n          ], #f0f, 20)\n          // top\n          void shared.graphics.filledTransparentArea([\n            self.childArea[1],\n            self.childArea[4],\n            self.childArea[3],\n            self.area[4]\n          ], #f0f, 20)\n          // bottom\n          void shared.graphics.filledTransparentArea([\n            self.childArea[1],\n            self.area[2],\n            self.childArea[3],\n            self.childArea[2]\n          ], #f0f, 20)\n          \n          if self.fullArea != null (\n            // left\n            void shared.graphics.filledTransparentArea([\n              self.fullArea[1],\n              self.fullArea[2],\n              self.area[1],\n              self.fullArea[4]\n            ], #0f0, 20)\n            // right\n            void shared.graphics.filledTransparentArea([\n              self.area[3],\n              self.fullArea[2],\n              self.fullArea[3],\n              self.fullArea[4]\n            ], #0f0, 20)\n            // top\n            void shared.graphics.filledTransparentArea([\n              self.area[1],\n              self.area[4],\n              self.area[3],\n              self.fullArea[4]\n            ], #0f0, 20)\n            // bottom\n            void shared.graphics.filledTransparentArea([\n              self.area[1],\n              self.fullArea[2],\n              self.area[3],\n              self.area[2]\n            ], #0f0, 20)\n          )\n          \n          if self.name != \"RWLFrame\" (\n            void shared.graphics.filledTransparentArea(self.childArea, #0ff, 20)\n          )\n        )\n      )\n      \n      def renderBackground() (\n        if self.color != null (\n          void shared.graphics.filledBox(self.area, self.rounding, self.color)\n        )\n      )\n    )\n    \n    class RWLRoot extends RWLContainer (\n      blockName = \"root\"\n      \n      def init(array children, object header) (\n        self.children @= children\n        self.header @= header\n        void self.initGlobal()\n      )\n    )\n    \n    class RWLFrame extends RWLContainer (\n      blockName = \"frame\"\n      \n      def init(array children, object header) (\n        self.children @= children\n        self.header @= header\n        void self.initGlobal()\n      )\n      \n      def update(array area, object context) (\n        void self.updateBackgroundColor()\n        void self.updateBackground(area)\n        void self.updateGlobal(area, context)\n        \n        local dir = \"x\"\n        local flipped = false\n        for flagI self.header.flags.len (\n          switch self.header.flags[flagI] (\n            case \"Horizontal\"\n              dir = \"x\"\n              break\n            case \"Vertical\"\n              dir = \"y\"\n              break\n            case \"Flipped\"\n              flipped = !flipped\n              break\n          )\n        )\n        \n        local amount = 0\n        if dir == \"x\" (\n          local total = rwl.area.width(area)\n        ) else if dir == \"y\" (\n          local total = rwl.area.height(area)\n        )\n        \n        local frameContext @= {\n          inst: context.inst\n        }\n        \n        for i self.children.len (\n          local child @= self.children[i]\n          \n          // defaults to remaining\n          local size = total - amount\n          local pairs @= child.header.pairs\n          for pairI pairs.len (\n            local pair @= pairs[pairI]\n            local value @= pair[2]\n            if pair[1] == \"size\" or (pair[1] == \"width\" and dir == \"x\") or (pair[1] == \"height\" and dir == \"y\") (\n              switch value.type (\n                case \"num\"\n                  size = value.value\n                  break\n                case \"percentage\"\n                  size = value.value / 100 * (total - amount)\n                  break\n                default\n                  return rwl.error.Error(\"ValueTypeMismatch\", {\n                    wanted: [\"num\", \"percentage\"],\n                    got: value.type\n                  })\n              )\n              break\n            )\n          )\n          \n          if dir == \"x\" (\n            local childArea @= [\n              flipped ? (area[3] - amount - size) (area[1] + amount),\n              area[2],\n              flipped ? (area[3] - amount) (area[1] + amount + size),\n              area[4]\n            ]\n          ) else if dir == \"y\" (\n            local childArea @= [\n              area[1],\n              flipped ? (area[2] + amount) (area[4] - amount - size),\n              area[3],\n              flipped ? (area[2] + amount + size) (area[4] - amount)\n            ]\n          )\n          \n          child.fullArea @= childArea\n          \n          childArea @= rwl.area.pad(childArea, self.getMargin(pairs))\n          \n          if child.kind == \"block\" (\n            local out @= child.update(childArea, frameContext)\n            if out.isError (\n              return out\n            )\n          ) else if [\"icon\"].contains(child.kind) (\n            void child.update(childArea, frameContext)\n          ) else (\n            return rwl.error.Error(\"ElemInFrame\", {})\n          )\n          amount += size\n        )\n        if dir == \"x\" (\n          self.usedArea @= [\n            flipped ? (area[3] - amount) (area[1]),\n            area[2],\n            flipped ? (area[3]) (area[1] + amount),\n            area[4]\n          ]\n          self.unusedArea @= [\n            flipped ? (area[1]) (area[1] + amount),\n            area[2],\n            flipped ? (area[3] - amount) (area[3]),\n            area[4]\n          ]\n        ) else if dir == \"y\" (\n          self.usedArea @= [\n            area[1],\n            flipped ? (area[2]) (area[4] - amount),\n            area[3],\n            flipped ? (area[2] + amount) (area[4])\n          ]\n          self.unusedArea @= [\n            area[1],\n            flipped ? (area[2] + amount) (area[2]),\n            area[3],\n            flipped ? (area[4]) (area[4] - amount)\n          ]\n        )\n      )\n      \n      def render() (\n        if self.header.flags.contains(\"Hidden\") (\n          void self.renderFrameDevtools()\n          return\n        )\n        \n        void self.renderBackground()\n        void rwl.main.RenderElements(self.children)\n        void self.renderFrameDevtools()\n      )\n      \n      def renderFrameDevtools() (\n        if self.elemI == devtools.main.hoveredElement (\n          void shared.graphics.filledTransparentArea(self.usedArea, #0ff, 20)\n          void shared.graphics.filledTransparentArea(self.unusedArea, #00f, 20)\n        )\n      )\n    )\n    \n    class RWLSection extends RWLContainer (\n      blockName = \"section\"\n      \n      def init(array children, object header) (\n        self.children @= children\n        self.header @= header\n        void self.initGlobal()\n      )\n    )\n    \n    class RWLPositionedContainer extends RWLContainer (\n      def update(array containerArea, object context) (\n        void self.updateGlobal(containerArea, context)\n        \n        local height = self.expectOnHeader(\"height\", \"num\").value ?? 20\n        \n        local margin @= self.getMargin()\n        local padding @= self.getPadding()\n        \n        local anchor @= self.expectOnHeader(\"anchor\", \"str\")\n        if anchor.isError (\n          return anchor\n        )\n        anchor = anchor[\"value\"]\n        \n        if context.x == null or context.y == null (\n          anchor ??= \"c\"\n        )\n        \n        if anchor != null (\n          if [\"tl\",\"t\",\"tr\",\n              \"l\",\"c\",\"r\",\n              \"bl\",\"b\",\"br\",\n              \"top left\", \"top\", \"top right\",\n              \"left\", \"center\", \"right\",\n              \"bottom left\", \"bottom\", \"bottom right\"].contains(anchor).not() (\n            return rwl.error.Error(\"InvalidAnchorName\", {\n              name: anchor\n            })\n          )\n          \n          local anchorX = rwl.area.centerX(containerArea)\n          local anchorY = rwl.area.centerY(containerArea) + (height / 2)\n          local anchorXType = \"c\"\n          local anchorYType = \"c\"\n          \n          if anchor.endsWith(\"l\") or anchor.endsWith(\"left\") (\n            anchorXType = \"l\"\n          )\n          if anchor.endsWith(\"r\") or anchor.endsWith(\"right\") (\n            anchorXType = \"r\"\n          )\n          \n          if anchor.startsWith(\"t\") or anchor.endsWith(\"top\") (\n            anchorY = containerArea[4]\n            anchorYType = \"t\"\n          )\n          if anchor.startsWith(\"b\") or anchor.endsWith(\"bottom\") (\n            anchorY = containerArea[2] + height + margin[2] + margin[4]\n            anchorYType = \"b\"\n          )\n          \n          context.x = anchorX\n          context.y = anchorY\n          context.anchorX = anchorXType\n          context.anchorY = anchorYType\n        )\n        context.y -= height / (context.anchorY == \"b\" ? -2 2) + (context.anchorY == \"b\" ? -margin[2] margin[4])\n        \n        local area @= [\n          containerArea[1] + margin[1],\n          context.y - (height / 2),\n          containerArea[3] - margin[3],\n          context.y + (height / 2)\n        ]\n        self.fullArea @= [\n          containerArea[1],\n          context.y - (height / 2) - margin[2],\n          containerArea[3],\n          context.y + (height / 2) + margin[4]\n        ]\n        \n        context.y -= height / (context.anchorY == \"b\" ? -2 2) + (context.anchorY == \"c\" ? 0 context.anchorY == \"b\" ? -margin[4] margin[2])\n        \n        void self.updateBackground(area)\n        \n        local childArea @= rwl.area.pad(area, padding)\n        \n        self.childArea @= childArea\n        \n        return rwl.main.UpdateElements(self.children, childArea, {\n          anchorX: \"c\",\n          anchorY: \"c\",\n          color: \"#fff\",\n          inst: context.inst\n        }, self)\n      )\n      \n      def render() (\n        if self.header.flags.contains(\"Hidden\") (\n          void self.renderDevtools()\n          return\n        )\n        \n        void self.renderBackground()\n        if rwl.main.debug (\n          void rwl.debug.box(self.area, #f00)\n          void rwl.debug.box(self.childArea, #0f0)\n          void rwl.debug.box(self.outArea, #00f)\n        )\n        void rwl.main.RenderElements(self.children)\n        void self.renderDevtools()\n      )\n    )\n    \n    class RWLButton extends RWLPositionedContainer (\n      blockName = \"button\"\n      \n      def init(array children, object header) (\n        self.children @= children\n        self.header @= header\n        void self.initGlobal()\n      )\n      \n      def isHovered() (\n        return mouse_x > self.area[1] and mouse_y > self.area[2] and mouse_x < self.area[3] and mouse_y < self.area[4]\n      )\n      \n      def updateBackgroundColor() (\n        local color @= self.expectOnHeader(\"color\", \"color\")\n        if color.isError (\n          return color\n        )\n        if color != null (\n          self.color @= color.value\n        )\n        \n        local hover_color @= self.expectOnHeader(\"hover_color\", \"color\")\n        if hover_color.isError (\n          return hover_color\n        )\n        if hover_color != null (\n          self.hover_color @= hover_color.value\n        )\n      )\n      \n      def renderBackground() (\n        local hov = self.isHovered()\n        \n        local col = self.color\n        if self.hover_color != null and hov (\n          col = self.hover_color\n        )\n        if col != null (\n          void shared.graphics.filledBox(self.area, self.rounding, col)\n        )\n        \n        //void shared.graphics.box(self.area, #fff)\n      )\n      \n      def interactUpdate(object context) (\n        if self.isHovered() (\n          // rework to use actual ordering system / order elemI on elem creation\n          //log context.topI self.elemI\n          if context.topI < self.elemI (\n            context.top @= self\n            context.topI = self.elemI\n          )\n        )\n      )\n      \n      def topUpdate(object context) (\n        //log \"hi\" context shared.input.rwlLeftClick\n        if shared.input.rwlLeftClick (\n          void context.rtr.runEvents({\n            name: \"click\",\n            element: self\n          }, {})\n        )\n      )\n    )\n    \n    class RWLScript extends RWLNode (\n      blockName = \"script\"\n      kind = \"script\"\n      \n      def init(body, object header, object inst) (\n        self.body @= body\n        self.header @= header\n        \n        void self.parse()\n        void self.makeModule(inst)\n      )\n      \n      def parse() (\n        self.ast @= null\n        // TODO: try\n        local parser @= rtr.ast.Parser(body)\n        self.ast @= parser.parse()\n      )\n      \n      def makeModule(object inst) (\n        if self.ast != null (\n          self.mod @= rtr.main.Module(self.ast)\n          void inst.rtrInst.addModule(self.mod)\n        )\n      )\n      \n      def update(array area, object context) (\n        if self.mod != null (\n          void self.mod.runEvent({\n            name: \"onupdate\"\n          }, {})\n        )\n      )\n      \n      def start() (\n        void self.mod.runEvent({\n          name: \"onload\",\n        }, {})\n      )\n    )\n    \n    class RWLElement extends RWLNode (\n      kind = \"element\"\n      def init(object value, object header) (\n        self.value @= value\n        self.header @= header\n        void self.initGlobal()\n      )\n      \n      def update(array area, object context) (\n        void self.updateGlobal(area, context)\n        local text = null\n        \n        switch self.value.type (\n          case \"str\"; case \"num\"\n            text = self.value.value.toStr()\n            break\n        )\n        \n        if text == null (\n          return rwl.error.Error(\"InvalidElemType\", {\n            valueType: self.value.type\n          })\n        )\n        \n        // font\n        //<font>\n        local size @= self.expectOnHeader(\"size\", \"num\")\n        if size.isError (\n          return size\n        )\n        size = size[\"value\"] ?? 10\n        \n        local spacing @= self.expectOnHeader(\"spacing\", \"num\")\n        if spacing.isError (\n          return spacing\n        )\n        spacing = spacing[\"value\"] ?? 1\n        \n        local line_height @= self.expectOnHeader(\"line_height\", \"num\")\n        if line_height.isError (\n          return line_height\n        )\n        line_height = spacing[\"line_height\"] ?? 1\n        \n        // positioning\n        local margin @= self.getMargin()\n        \n        local anchor @= self.expectOnHeader(\"anchor\", \"str\")\n        if anchor.isError (\n          return anchor\n        )\n        anchor = anchor[\"value\"]\n        \n        if context.x == null or context.y == null (\n          anchor ??= \"c\"\n        )\n        \n        if anchor != null (\n          if [\"tl\",\"t\",\"tr\",\n              \"l\",\"c\",\"r\",\n              \"bl\",\"b\",\"br\",\n              \"top left\", \"top\", \"top right\",\n              \"left\", \"center\", \"right\",\n              \"bottom left\", \"bottom\", \"bottom right\"].contains(anchor).not() (\n            return rwl.error.Error(\"InvalidAnchorName\", {\n              name: anchor\n            })\n          )\n          \n          local anchorX = rwl.area.centerX(area)\n          local anchorY = rwl.area.centerY(area) + (line_height * 1 * size)\n          local anchorXType = \"c\"\n          local anchorYType = \"c\"\n          \n          if anchor.endsWith(\"l\") or anchor.endsWith(\"left\") (\n            anchorX = area[1] + margin[1]\n            anchorXType = \"l\"\n          )\n          if anchor.endsWith(\"r\") or anchor.endsWith(\"right\") (\n            anchorX = area[3] - margin[3]\n            anchorXType = \"r\"\n          )\n          \n          if anchor.startsWith(\"t\") or anchor.endsWith(\"top\") (\n            anchorY = area[4]\n            anchorYType = \"t\"\n          )\n          if anchor.startsWith(\"b\") or anchor.endsWith(\"bottom\") (\n            anchorY = area[2]\n            anchorYType = \"b\"\n          )\n          \n          context.x = anchorX\n          context.y = anchorY\n          context.anchorX = anchorXType\n          context.anchorY = anchorYType\n        )\n        \n        local boxAlignment = context.anchorX\n        \n        local alignment @= self.expectOnHeader(\"alignment\", \"str\")\n        if alignment.isError (\n          return alignment\n        )\n        alignment = alignment[\"value\"]\n        if alignment != null (\n          if [\"l\",\"c\",\"r\",\n              \"left\", \"center\", \"right\"].contains(alignment).not() (\n            return rwl.error.Error(\"InvalidAlignmentName\", {\n              name: anchor\n            })\n          )\n          \n          if alignment.endsWith(\"l\") or alignment.endsWith(\"left\") (\n            alignment = \"l\"\n          )\n          if alignment.endsWith(\"r\") or alignment.endsWith(\"right\") (\n            alignment = \"r\"\n          )\n        )\n        alignment ??= boxAlignment\n        \n        // appearance\n        //<link>\n        //<decoration>\n        local color @= self.expectOnHeader(\"color\", \"color\")\n        if color.isError (\n          return color\n        )\n        color = color.value\n        if color != null (\n          context.color = color\n        )\n        color ??= context.color\n        \n        local linesr @= text.split(\"\\n\")\n        local width = 0\n        for lineI linesr.len (\n          width = max(width, linesr[lineI].len * size * spacing)\n        )\n        local height = lines.len * line_height * 2 * size\n        \n        local x = context.x\n        if boxAlignment == \"l\" (\n          x += width / 2\n        )\n        if boxAlignment == \"r\" (\n          x += width / -2\n        )\n        \n        context.y -= height / (context.anchorY == \"b\" ? -2 2) + (context.anchorY == \"b\" ? -margin[2] margin[4])\n        \n        self.lines @= []\n        //log self.lines\n        local y = context.y + (height / 2)\n        for lineI linesr.len (\n          y -= size * line_height\n          local lineW = shared.graphics.getTextWidth(linesr[lineI]) * size\n          local lx = x\n          if alignment == \"l\" (\n            lx += width / -2\n          )\n          if alignment == \"r\" (\n            lx += width / 2 - lineW\n          )\n          if alignment == \"c\" (\n            // account for char spacing\n            lx += lineW * -.5\n          )\n          //log self\n          self.lines ??= []\n          void self.lines.append([linesr[lineI], lx, y, size, color])\n          y -= size * line_height\n        )\n        \n        self.debugArea @= [\n          x - (width / 2),\n          context.y - (height / 2),\n          x + (width / 2),\n          context.y + (height / 2)\n        ]\n        self.margin @= margin\n        \n        context.y -= height / (context.anchorY == \"b\" ? -2 2) + (context.anchorY == \"b\" ? -margin[4] margin[2])\n      )\n      \n      def render() (\n        if self.header.flags.contains(\"Hidden\") (\n          void self.renderDevtools()\n          return\n        )\n        \n        for lineI self.lines.len (\n          local line @= self.lines[lineI]\n          void shared.graphics.ptext(line[1], line[2], line[3], line[4], line[5])\n        )\n        \n        void rwl.debug.box(self.debugArea ?? [])\n        void self.renderDevtools()\n      )\n      \n      def renderDevtools() (\n        if self.elemI == devtools.main.hoveredElement (\n          void shared.graphics.filledTransparentArea(self.debugArea, #0ff, 20)\n          \n          local fullArea = rwl.area.margin(self.debugArea, self.margin)\n         \n          if fullArea != null (\n            // left\n            void shared.graphics.filledTransparentArea([\n              fullArea[1],\n              fullArea[2],\n              self.debugArea[1],\n              fullArea[4]\n            ], #f0f, 20)\n            // right\n            void shared.graphics.filledTransparentArea([\n              self.debugArea[3],\n              fullArea[2],\n              fullArea[3],\n              fullArea[4]\n            ], #f0f, 20)\n            // top\n            void shared.graphics.filledTransparentArea([\n              self.debugArea[1],\n              self.debugArea[4],\n              self.debugArea[3],\n              fullArea[4]\n            ], #f0f, 20)\n            // bottom\n            void shared.graphics.filledTransparentArea([\n              self.debugArea[1],\n              fullArea[2],\n              self.debugArea[3],\n              self.debugArea[2]\n            ], #f0f, 20)\n          )\n        )\n      )\n    )\n    \n    class RWLIcon extends RWLNode (\n      kind = \"icon\"\n      \n      def update(array area, object context) (\n        local scale @= self.expectOnHeader(\"scale\", \"num\")\n        if scale.isError (\n          return scale\n        )\n        self.scale = size.value ?? 1\n        \n        local src @= self.expectOnHeader(\"src\", \"str\")\n        if src.isError (\n          return src\n        )\n        if src == null (\n          return rwl.error.Error(\"NoIconSrc\", {})\n        )\n        self.src = src.value\n        \n        local color @= self.expectOnHeader(\"color\", \"color\")\n        if color.isError (\n          return color\n        )\n        self.color = color.value\n        \n        // TODO: anchors?\n        self.x = rwl.area.centerX(area)\n        self.y = rwl.area.centerY(area)\n      )\n      \n      def render() (\n        if self.header.flags.contains(\"Hidden\") (\n          void self.renderDevtools()\n          return\n        )\n        \n        void shared.graphics.picon(self.src, self.x, self.y, self.scale, self.color ?? \"#fff\")\n        void self.renderDevtools()\n      )\n      \n      def init(object header) (\n        self.header @= header\n      )\n    )\n    \n    def UpdateElements(array elements, array area, object context, object parentElem) (\n      for i elements.len (\n        elements[i].parent @= parentElem\n        local out @= elements[i].update(area, context)\n        if out.isError (\n          return out\n        )\n      )\n    )\n    \n    def RenderElements(array elements) (\n      for i elements.len (\n        //void\n        void elements[i].render()\n        void\n      )\n    )\n    \n    elemI = 0\n    def AstToElement(ast, object inst) (\n      def AstToHeader(header) (\n        local flags @= []\n        local pairs @= []\n        for attrI header.attributes.len (\n          local attr @= header.attributes[attrI]\n          switch attr.kind (\n            case \"flag\"\n              flags.append(attr.data)\n              break\n            case \"key\"\n              void pairs.append([attr.key, rwl.value.AstToValue(attr.value)])\n              break\n          )\n        )\n        return { flags, pairs }\n      )\n      //log \"a\" ast\n      local header @= AstToHeader(ast.data.header)\n      \n      switch ast.kind (\n        case \"block\"\n          if ast.data.header.key != \"script\" (\n            local children @= AstsToElements(ast.data.content.elements, inst)\n          )\n          if typeof(children) != \"array\" and children[\"isError\"] (\n            return children\n          )\n          switch ast.data.header.key (\n            // top level\n            case \"root\"\n              return rwl.main.RWLRoot(children, header)\n            \n            // normal\n            case \"frame\"\n              return rwl.main.RWLFrame(children, header)\n            case \"section\"\n              return rwl.main.RWLSection(children, header)\n            \n            case \"script\"\n              return rwl.main.RWLScript(shared.utils.removeIndents(ast.data.content), header, inst)\n            \n            case \"button\"\n              return rwl.main.RWLButton(children, header)\n            \n            default\n              return rwl.error.Error(\"UnknownBlockType\", {\n                blockType: ast.data.header.key\n              })\n              break\n          )\n          break\n        \n        case \"element\"\n          return rwl.main.RWLElement(rwl.value.AstToValue(ast.data.value), header)\n        \n        case \"icon\"\n          return rwl.main.RWLIcon(header)\n        \n        default\n          return rwl.error.Error(\"UnknownElementKind\", {\n            elementKind: ast.kind\n          })\n          break\n      )\n    )\n    \n    def AstsToElements(elements, object inst) (\n      local elems @= []\n      for i elements.len (\n        local out @= AstToElement(elements[i], inst)\n        if out.isError (\n          return out\n        )\n        void elems.append(out)\n      )\n      return elems\n    )\n    \n    class RWL (\n      def init(object ast, object rtrInst) (\n        self.rtrInst @= rtrInst\n        self.errored = false\n        self.needsUpdate = true\n        self.hasUpdated = false\n        \n        self._lastW = 0\n        self._lastH = 0\n        self._lastX = 0\n        self._lastY = 0\n        \n        void self.loadFromAst(ast)\n      )\n      \n      def loadFromAst(object ast) (\n        self.ast @= ast\n        self.elements @= rwl.main.AstsToElements(ast.elements, self)\n        \n        if typeof(self.elements) != \"array\" and self.elements.isError (\n          error self.elements.stringify()\n          self.errored = true\n          return\n        )\n      )\n      \n      def update(array area) (\n        self.hasUpdated = true\n        if self.errored (\n          return\n        )\n        \n        local out @= rwl.main.UpdateElements(self.elements, area, {\n          inst: self,\n          root: true\n        }, {})\n        if out.isError (\n          error out.stringify()\n          self.errored = true\n          self.errormsg = out.stringify()\n        )\n      )\n      \n      def checkUpdate(array area) (\n        local w = rwl.area.width(area)\n        local h = rwl.area.height(area)\n        local x = rwl.area.centerX(area)\n        local y = rwl.area.centerY(area)\n        \n        // if the width or height or x or y has changed, update\n        if w != self._lastW or h != self._lastH or x != self._lastX or y != self._lastY (\n          self.needsUpdate = true\n          \n          self._lastW = w\n          self._lastH = h\n          self._lastX = x\n          self._lastY = y\n        )\n        \n        if self.needsUpdate (\n          void self.update(area)\n          self.needsUpdate = false\n        )\n      )\n      \n      def interactUpdate(object context) (\n        if self.errored (\n          return\n        )\n      \n        context.top = null\n        context.topI = 0\n        for i self.elements.len (\n          void self.elements[i].interactUpdate(context)\n        )\n        \n        //log context.top\n        \n        if context.top != null (\n          void context.top.topUpdate(context)\n        )\n      )\n      \n      def checkElemUpdate() (\n        if self.errored (\n          return\n        )\n      \n        for i self.elements.len (\n          void self.elements[i].checkUpdate()\n        )\n      )\n      \n      def render(array area) (\n        void self.checkUpdate(area)\n      \n        self.worker.area @= area\n        if self.errored (\n          goto rwl.area.centerX(area) rwl.area.centerY(area)\n          centext \"rwl errored :(\" 12 : c#shared.theme.seco\n          if self.errormsg != null (\n            centext self.errormsg 8 : c#shared.theme.prim chy#-20\n          )\n          return\n        )\n        \n        void rwl.main.RenderElements(self.elements)\n      )\n      \n      def getElement(string id) (\n        local queue @= [...self.elements]\n        while queue.len > 0 (\n          local elem @= queue.shift()\n          \n          if elem.id == id (\n            return elem\n          )\n          \n          if elem.children != null (\n            for i elem.children.len (\n              void queue.append(elem.children[i])\n            )\n          )\n        )\n      )\n    )\n  )\n  return __imports__b471b13f60903428337025313115b852\ncase \"./sidebartest.rwl\"\n  return \"  root {\\n    frame [Horizontal, id=\\\"bleh\\\"] {\\n      section [\\n        id=\\\"sidebar\\\",\\n        size=150, color=theme:prim,\\n        rounding_tr=17.5, rounding_br=17.5,\\n        padding=10\\n      ] {},\\n      section {\\n      }\\n    },\\n    \\n    script {\\n      event(onload) {\\n        i := 0;\\n        createSidebarButton := (name) ~ {\\n          i = i + 1;\\n          elem := document.createContainer(\\\"button\\\");\\n          elem.height = 35;\\n          elem.padding = 10;\\n          elem.color = theme.seco;\\n          elem.hover_color = theme.tert;\\n          elem.rounding = 10;\\n          elem.id = \\\"btn\\\" + i;\\n          if (i == 1)\\n            elem.anchor = \\\"t\\\";\\n          elem.margin_b = 10;\\n          document.getElement(\\\"sidebar\\\").addChild(elem);\\n          \\n          script := document.createScript(\\\"event(#\\\" + elem.id + \\\":click) {\\\\n  log(\\\\\\\"\\\" + name + \\\" clicked!\\\\\\\");\\\\n}\\\\n\\\");\\n          document.root.addChild(script);\\n          \\n          text := document.createTextElement(name);\\n          text.color = theme.text;\\n          elem.addChild(text);\\n        };\\n        \\n        btns := [\\n          \\\"hi\\\",\\n          \\\"wow\\\",\\n          \\\"blehh\\\",\\n          \\\"fr\\\"\\n        ];\\n        \\n        for (btn, btns) {\\n          log(btn);\\n          createSidebarButton(btn);\\n        }\\n      }\\n    }\\n  }\"\n\ncase \"./test.rwl\"\n  return \"  root [color=theme:prim] {\\n    frame [Horizontal] {\\n      section [size=100, rounding_tr=20, rounding_br=20] {\\n        \\\"fr\\\" [color=theme:seco]\\n      },\\n      section {\\n        frame [Vertical] {\\n          section [size=50] {\\n            \\\"maybe?\\\" [color=theme:text, anchor=\\\"l\\\", margin=10, size=15]\\n          },\\n          section [color=theme:back, rounding=20, margin_r=10, margin_b=10, padding=20] {\\n            \\\"blehhh\\\" [color=theme:text],\\n            \\\"fr\\\",\\n            button [color=theme:prim,padding=5,rounding=5] {\\n              \\\"hi\\\"\\n            },\\n            \\\":P\\\" [anchor=\\\"bl\\\",size=5]\\n          }\\n        }\\n      }\\n    },\\n    script {\\n      event(onload) {\\n        log(\\\"blehh\\\");\\n        \\n        document.title = \\\"gay\\\";\\n        document.icon = \\\"flag-progress\\\";\\n      }\\n    }\\n  }\"\n\ncase \"./main.rwl\"\n  return \"  root {\\n    script {\\n      event (onload) {\\n        log(\\\"hi\\\");\\n      }\\n    }\\n  }\"\n)\n)\nimport as \"glass\" from \"packages\"\n\n// fpp boilerplate\n\n\n\nobject rwl @= {\n  main: import(\"./src/rwl/main.osl\"),\n  config: import(\"./src/rwl/config.osl\"),\n  area: import(\"./src/rwl/area.osl\"),\n  error: import(\"./src/rwl/error.osl\"),\n  value: import(\"./src/rwl/value.osl\"),\n  debug: import(\"./src/rwl/debug.osl\"),\n  ast: import(\"./src/rwl/ast.osl\")\n}\n\nobject rtr @= {\n  main: import(\"./src/rtr/main.osl\"),\n  ast: import(\"./src/rtr/ast.osl\"),\n  error: import(\"./src/rtr/error.osl\"),\n  value: import(\"./src/rtr/value.osl\"),\n  compiler: import(\"./src/rtr/compiler.osl\"),\n  instruction: import(\"./src/rtr/instruction.osl\"),\n  apis: {}\n}\n\n// make them load after\nrtr.apis @= {\n  main: import(\"./src/rtr/apis/main.osl\"),\n  rwl: import(\"./src/rtr/apis/rwl.osl\"),\n  browser: import(\"./src/rtr/apis/browser.osl\")\n}\n\nobject shared @= {\n  graphics: import(\"./src/shared/graphics.osl\"),\n  utils: import(\"./src/shared/utils.osl\"),\n  document: import(\"./src/shared/document.osl\"),\n  tab: import(\"./src/shared/tab.osl\"),\n  url: import(\"./src/shared/url.osl\"),\n  theme: import(\"./src/shared/theme.osl\"),\n  config: import(\"./src/shared/config.osl\"),\n  tab_worker: import(\"./src/shared/tab_worker.osl\"),\n  input: import(\"./src/shared/input.osl\"),\n  settings: import(\"./src/shared/settings.osl\"),\n  save: import(\"./src/shared/save.osl\")\n}\n\nobject layouts @= {\n  shared: {\n    state: import(\"./src/layouts/shared/state.osl\"),\n    utils: import(\"./src/layouts/shared/utils.osl\"),\n    topbar: import(\"./src/layouts/shared/topbar.osl\"),\n    urlbar: import(\"./src/layouts/shared/urlbar.osl\"),\n    view: import(\"./src/layouts/shared/view.osl\")\n  },\n  chromeLike: {\n    main: import(\"./src/layouts/chromeLike/main.osl\"),\n    topbar: import(\"./src/layouts/chromeLike/topbar.osl\")\n  },\n  summit: {\n    main: import(\"./src/layouts/summit/main.osl\"),\n    sidebar: import(\"./src/layouts/summit/sidebar.osl\"),\n    topbar: import(\"./src/layouts/summit/topbar.osl\")\n  }\n}\n\nobject net @= {\n  fetch: import(\"./src/net/fetch.osl\"),\n  response: import(\"./src/net/response.osl\")\n}\n\nif build.package.phosphorus.hasDevtools ?? true (\n  object devtools @= {\n    main: import(\"./src/devtools/main.osl\"),\n    topbar: import(\"./src/devtools/topbar.osl\"),\n    rightclick: import(\"./src/devtools/rightclick.osl\"),\n    \n    menus: {\n      elements: import(\"./src/devtools/menus/elements.osl\"),\n      console: import(\"./src/devtools/menus/console.osl\"),\n      network: import(\"./src/devtools/menus/network.osl\"),\n      storage: import(\"./src/devtools/menus/storage.osl\"),\n      compiled: import(\"./src/devtools/menus/compiled.osl\")\n    }\n  }\n)\n\nobject browserPages @= {\n  empty: import(\"./src/assets/empty.rwl\"),\n  home: import(\"./src/assets/home.rwl\"),\n  settings: () -> import(\"./src/assets/settings.rwl\")\n}\n\nvoid shared.settings.load()\nvoid shared.config.net.refresh()\n\nvoid layouts.chromeLike.main.init()\n\nif !build.built (\n  // debug tabs\n  local document @= shared.document.Document()\n  void document.loadUrl(shared.url.Url(\"phos://settings\"))\n  //void document.loadUrl(shared.url.Url(\"local://./main.rwl\"))\n  void layouts.shared.state.openTabDocument(document)\n  \n  local document2 @= shared.document.Document()\n  void document2.loadUrl(shared.url.Url(\"local://./test.rwl\"))\n  void layouts.shared.state.openTabDocument(document2)\n  \n  local document3 @= shared.document.Document()\n  void document3.loadUrl(shared.url.Url(\"local://./sidebartest.rwl\"))\n  void layouts.shared.state.openTabDocument(document3)\n) else (\n  local document3 @= shared.document.Document()\n  void document3.loadUrl(shared.url.Url(shared.config.url.browser_scheme ++ \"://home\"))\n  void layouts.shared.state.openTabDocument(document3)\n)\n\nvoid layouts.shared.state.selectTab(1)\n\nvoid window.resize(900,500)\n\ncurrentLayout = build.package.phosphorus.layout ?? \"chromeLike\"\n\nif !build.built (\n  currentLayout = \"summit\"\n)\n\nmainloop:\n  void layouts[currentLayout].main.update()\n  //void layouts.chromeLike.main.update()\n  //void layouts.summit.main.update()\n  \n  // file dropping\n  if file_dropped != 0 (\n    local data @= open(file_dropped,[3,2,1])\n    local path = data[1] ++ \"/\" ++ data[2] ++ data[3]\n    local document @= shared.document.Document()\n    void document.loadUrl(shared.url.Url(\"local://\" ++ path))\n    void layouts.shared.state.openTabDocument(document)\n    file_dropped = 0\n  )",""]],"c #703d00 square 0 2 10 4 c #FF9800 square -8 6 2 2 line -5 7 3 0 square 0 -1 10 5 w 8 square 0 -0.5 5 0"],[".folder","src",[[".folder","rwl",[[".osl","config","\ngoob = \"hi\"\n",""],[".osl","area","\ndef copy(area) (\n  return [area[1], area[2], area[3], area[4]]\n)\n\ndef centerX(area) (\n  return area[1] + area[3] / 2\n)\n\ndef centerY(area) (\n  return area[2] + area[4] / 2\n)\n\ndef width(area) (\n  return area[3] - area[1]\n)\n\ndef height(area) (\n  return area[4] - area[2]\n)\n\ndef pad(area, pad) (\n  return [\n    area[1] + pad[1],\n    area[2] + pad[2],\n    area[3] - pad[3],\n    area[4] - pad[4]\n  ]\n)\n\ndef margin(area, mar) (\n  return [\n    area[1] - mar[1],\n    area[2] - mar[2],\n    area[3] + mar[3],\n    area[4] + mar[4]\n  ]\n)\n",""],[".osl","error","\nobject Errors = {\n  UnknownElementKind: def(data) -> (\n    return \"unknown element kind:\" + data.elementKind\n  ),\n  UnknownAttributeKind: def(data) -> (\n    return \"unknown attribute kind:\" + data.attributeKind\n  ),\n  \n  UnknownValueType: def(data) -> (\n    return \"unknown value type:\" + data.valueType\n  ),\n  UnknownBlockType: def(data) -> (\n    return \"unknown block type:\" + data.blockType\n  ),\n  \n  InvalidAnchorName: def(data) -> (\n    return \"unknown anchor name\" + data.name\n  ),\n  InvalidAlignmentName: def(data) -> (\n    return \"unknown anchor name\" + data.name\n  ),\n  \n  InvalidElemType: def(data) -> (\n    return \"cannot have\" + data.valueType + \"as element\"\n  ),\n  \n  ValueTypeMismatch: def(data) -> (\n    if typeof(data.wanted) == \"string\" (\n      data.wanted @= [data.wanted]\n    )\n    local forCtx = \"\"\n    if data.attr != null (\n      forCtx += \"for\" + data.attr\n    )\n    return \"wanted\" + data.wanted.join(\" or \") + \"got\" + data.got ++ forCtx\n  ),\n  \n  UnknownProperty: def(data) -> (\n    return \"unknown property\" + data.property + \"on\" + data.source\n  ),\n  UnknownPropertySource: def(data) -> (\n    return \"unknown source\" + data.source\n  ),\n  \n  ElemInFrame: def(data) -> (\n    return \"element in a frame, only sections are allowed directly in frames\"\n  ),\n  \n  NoScriptType: def(data) -> (\n    return \"no script type attribute\"\n  ),\n  InvalidScriptType: def(data) -> (\n    return \"unknown script type\" + data.type\n  ),\n  InvalidScriptAttrType: def(data) -> (\n    return \"unknown script type attribute type\" + data.type\n  ),\n  \n  NoIconSrc: def(data) -> (\n    return \"icon has no src\"\n  )\n}\n\nclass Error (\n  boolean isError = true\n  \n  def init(string type, object data) (\n    self.type = type\n    self.data @= data\n    \n    local err @= rwl.error.Errors[type]\n    if err == null (\n      self.type = \"UnknownErrorType\"\n      self.txt = \"unknown error type\" + type\n      return\n    )\n    self.txt = err(data)\n  )\n  \n  def stringify() (\n    return \"Error<\" ++ self.type ++ \">:\\n\" ++ self.txt.split(\"\\n\").map(l -> \"    \" ++ l).join(\"\\n\")\n  )\n)\n",""],[".osl","value","\nclass RWLValue (\n  \n)\n\nclass RWLStrValue extends RWLValue (\n  type = \"str\"\n  def init(string value) (\n    self.value @= value\n  )\n)\n\nclass RWLNumValue extends RWLValue (\n  type = \"num\"\n  def init(number value) (\n    self.value @= value\n  )\n)\n\nclass RWLPercentageValue extends RWLValue (\n  type = \"percentage\"\n  def init(number value) (\n    self.value @= value\n  )\n)\n\nclass RWLColorValue extends RWLValue (\n  type = \"color\"\n  def init(string value) (\n    self.value @= value\n  )\n)\n\ndef AstToValue(ast) (\n  switch ast.type (\n    case \"str\"\n      return rwl.value.RWLStrValue(ast.value)\n    case \"num\"\n      return rwl.value.RWLNumValue(ast.value)\n    case \"percentage\"\n      return rwl.value.RWLPercentageValue(ast.value)\n    case \"color\"\n      return rwl.value.RWLColorValue(ast.value)\n    case \"property\"\n      switch ast.source (\n        case \"theme\"\n          local col = shared.theme[ast.name]\n          if typeof(col) == \"string\" (\n            return rwl.value.RWLColorValue(col)\n          )\n          break\n        default\n          return rwl.error.Error(\"UnknownPropertySource\", {\n            source: ast.source\n          })\n      )\n      return rwl.error.Error(\"UnknownProperty\", {\n        property: ast.name,\n        source: ast.source\n      })\n    default\n      return rwl.error.Error(\"UnknownValueType\", {\n        valueType: ast.type\n      })\n  )\n)\n",""],[".osl","main","\ndebug = false\n\nclass RWLNode (\n  // global attributes\n  def initGlobal() (\n    self.elemI = rwl.main.elemI\n    rwl.main.elemI ++\n    self.updateGlobal()\n  )\n  def updateGlobal(area, context) (\n    self.id = null\n    \n    local id @= self.expectOnHeader(\"id\", \"str\")\n    if id.isError (\n      return id\n    )\n    if id != null (\n      self.id = id.value\n    )\n    \n    self.cu_area @= area\n    self.cu_context @= context\n    void self.checkUpdate()\n  )\n  \n  def updateFromCache() (\n    if self.cu_area != null (\n      void self.update(self.cu_area, self.cu_context)\n    )\n  )\n  \n  def updateParentFromCache() (\n    if self.parent != null and self.parent.name != null (\n      void self.parent.updateFromCache()\n    ) else (\n      void self.updateFromCache()\n    )\n  )\n  \n  def checkUpdate() (\n    if self.needsUpdate (\n      self.needsUpdate = false\n      void self.updateFromCache()\n    )\n    \n    // used when this was a branch like system\n    //if self.children != null (\n    //  for i self.children.len (\n    //    void self.children[i].checkUpdate()\n    //  )\n    //)\n  )\n  \n  def update() (\n    \n  )\n  \n  def topUpdate() (\n    \n  )\n  \n  def interactUpdate() (\n    \n  )\n  \n  def render() (\n    \n  )\n  \n  def renderDevtools() (\n    \n  )\n  \n  def expectOnHeader(string key, string type) (\n    for attrI self.header.pairs.len (\n      local attr @= self.header.pairs[attrI]\n      if attr[2].isError (\n        return attr[2]\n      )\n      if attr[1] == key (\n        if attr[2].type != type (\n          return rwl.error.Error(\"ValueTypeMismatch\", {\n            wanted: type,\n            got: attr[2].type\n          })\n        ) else (\n          return attr[2]\n        )\n      )\n    )\n    return null\n  )\n  \n  def getAreaKeys(string name, pairs) (\n    local l = 0\n    local r = 0\n    local b = 0\n    local t = 0\n    \n    pairs ??= self.header.pairs\n    for pairI pairs.len (\n      local pair @= pairs[pairI]\n      local n = pair[1]\n      local value @= pair[2]\n      \n      if n == name (\n        l = value.value\n        r = value.value\n        b = value.value\n        t = value.value\n      ) else if n == name ++ \"_x\" (\n        l = value.value\n        r = value.value\n      ) else if n == name ++ \"_y\" (\n        b = value.value\n        t = value.value\n      ) else if n == name ++ \"_l\" or n == name ++ \"_left\" (\n        l = value.value\n      ) else if n == name ++ \"_r\" or n == name ++ \"_right\" (\n        r = value.value\n      ) else if n == name ++ \"_b\" or n == name ++ \"_bottom\" (\n        b = value.value\n      ) else if n == name ++ \"_t\" or n == name ++ \"_top\" (\n        t = value.value\n      )\n    )\n    \n    return [l, b, r, t]\n  )\n  \n  def getPadding(pairs) (\n    return self.getAreaKeys(\"padding\", pairs)\n  )\n  def getMargin(pairs) (\n    return self.getAreaKeys(\"margin\", pairs)\n  )\n)\n\nclass RWLContainer extends RWLNode (\n  kind = \"block\"\n  def init(array children, object header) (\n    self.children @= children\n    self.header @= header\n    void self.initGlobal()\n  )\n  \n  def update(array area, object context) (\n    void self.updateBackgroundColor()\n    void self.updateBackground(area)\n    void self.updateGlobal(area, context)\n    \n    local childArea @= rwl.area.pad(area, self.getPadding())\n    \n    self.area @= area\n    self.childArea @= childArea\n    \n    return rwl.main.UpdateElements(self.children, childArea, {\n      anchorX: \"c\",\n      anchorY: \"c\",\n      color: \"#fff\",\n      inst: context.inst\n    }, self)\n  )\n  \n  def interactUpdate(object context) (\n    for i self.children.len (\n      void self.children[i].interactUpdate(context)\n    )\n  )\n  \n  def updateBackgroundColor() (\n    local color @= self.expectOnHeader(\"color\", \"color\")\n    \n    if color != null (\n      self.color @= color.value\n    )\n  )\n  \n  def updateBackground(array area) (\n    self.area @= area\n    \n    local allRounding @= self.expectOnHeader(\"rounding\", \"num\")\n    \n    local rounding @= allRounding.value ?? 0\n    \n    local corners @= [\"bl\",\"br\",\"tl\",\"tr\"]\n    for i corners.len (\n      local corner @= self.expectOnHeader(\"rounding_\" ++ corners[i], \"num\")\n      if corner != null (\n        if typeof(rounding) != \"array\" (\n          rounding @= []\n          loop i - 1 (\n            void rounding.append(allRounding.value ?? 0)\n          )\n        )\n        void rounding.append(corner.value ?? 0)\n      ) else (\n        void rounding.append(allRounding.value ?? 0)\n      )\n    )\n    self.rounding @= rounding\n    \n    void self.updateBackgroundColor()\n  )\n  \n  def render() (\n    if self.header.flags.contains(\"Hidden\") (\n      void self.renderDevtools()\n      return\n    )\n    \n    void self.renderBackground()\n    if rwl.main.debug (\n      void rwl.debug.box(self.area, #f00)\n      void rwl.debug.box(self.childArea, #0f0)\n    )\n    void rwl.main.RenderElements(self.children)\n    void self.renderDevtools()\n  )\n  \n  def renderDevtools() (\n    if self.elemI == devtools.main.hoveredElement (\n      self.childArea ??= self.area\n      \n      // left\n      void shared.graphics.filledTransparentArea([\n        self.area[1],\n        self.area[2],\n        self.childArea[1],\n        self.area[4]\n      ], #f0f, 20)\n      // right\n      void shared.graphics.filledTransparentArea([\n        self.childArea[3],\n        self.area[2],\n        self.area[3],\n        self.area[4]\n      ], #f0f, 20)\n      // top\n      void shared.graphics.filledTransparentArea([\n        self.childArea[1],\n        self.childArea[4],\n        self.childArea[3],\n        self.area[4]\n      ], #f0f, 20)\n      // bottom\n      void shared.graphics.filledTransparentArea([\n        self.childArea[1],\n        self.area[2],\n        self.childArea[3],\n        self.childArea[2]\n      ], #f0f, 20)\n      \n      if self.fullArea != null (\n        // left\n        void shared.graphics.filledTransparentArea([\n          self.fullArea[1],\n          self.fullArea[2],\n          self.area[1],\n          self.fullArea[4]\n        ], #0f0, 20)\n        // right\n        void shared.graphics.filledTransparentArea([\n          self.area[3],\n          self.fullArea[2],\n          self.fullArea[3],\n          self.fullArea[4]\n        ], #0f0, 20)\n        // top\n        void shared.graphics.filledTransparentArea([\n          self.area[1],\n          self.area[4],\n          self.area[3],\n          self.fullArea[4]\n        ], #0f0, 20)\n        // bottom\n        void shared.graphics.filledTransparentArea([\n          self.area[1],\n          self.fullArea[2],\n          self.area[3],\n          self.area[2]\n        ], #0f0, 20)\n      )\n      \n      if self.name != \"RWLFrame\" (\n        void shared.graphics.filledTransparentArea(self.childArea, #0ff, 20)\n      )\n    )\n  )\n  \n  def renderBackground() (\n    if self.color != null (\n      void shared.graphics.filledBox(self.area, self.rounding, self.color)\n    )\n  )\n)\n\nclass RWLRoot extends RWLContainer (\n  blockName = \"root\"\n  \n  def init(array children, object header) (\n    self.children @= children\n    self.header @= header\n    void self.initGlobal()\n  )\n)\n\nclass RWLFrame extends RWLContainer (\n  blockName = \"frame\"\n  \n  def init(array children, object header) (\n    self.children @= children\n    self.header @= header\n    void self.initGlobal()\n  )\n  \n  def update(array area, object context) (\n    void self.updateBackgroundColor()\n    void self.updateBackground(area)\n    void self.updateGlobal(area, context)\n    \n    local dir = \"x\"\n    local flipped = false\n    for flagI self.header.flags.len (\n      switch self.header.flags[flagI] (\n        case \"Horizontal\"\n          dir = \"x\"\n          break\n        case \"Vertical\"\n          dir = \"y\"\n          break\n        case \"Flipped\"\n          flipped = !flipped\n          break\n      )\n    )\n    \n    local amount = 0\n    if dir == \"x\" (\n      local total = rwl.area.width(area)\n    ) else if dir == \"y\" (\n      local total = rwl.area.height(area)\n    )\n    \n    local frameContext @= {\n      inst: context.inst\n    }\n    \n    for i self.children.len (\n      local child @= self.children[i]\n      \n      // defaults to remaining\n      local size = total - amount\n      local pairs @= child.header.pairs\n      for pairI pairs.len (\n        local pair @= pairs[pairI]\n        local value @= pair[2]\n        if pair[1] == \"size\" or (pair[1] == \"width\" and dir == \"x\") or (pair[1] == \"height\" and dir == \"y\") (\n          switch value.type (\n            case \"num\"\n              size = value.value\n              break\n            case \"percentage\"\n              size = value.value / 100 * (total - amount)\n              break\n            default\n              return rwl.error.Error(\"ValueTypeMismatch\", {\n                wanted: [\"num\", \"percentage\"],\n                got: value.type\n              })\n          )\n          break\n        )\n      )\n      \n      if dir == \"x\" (\n        local childArea @= [\n          flipped ? (area[3] - amount - size) (area[1] + amount),\n          area[2],\n          flipped ? (area[3] - amount) (area[1] + amount + size),\n          area[4]\n        ]\n      ) else if dir == \"y\" (\n        local childArea @= [\n          area[1],\n          flipped ? (area[2] + amount) (area[4] - amount - size),\n          area[3],\n          flipped ? (area[2] + amount + size) (area[4] - amount)\n        ]\n      )\n      \n      child.fullArea @= childArea\n      \n      childArea @= rwl.area.pad(childArea, self.getMargin(pairs))\n      \n      if child.kind == \"block\" (\n        local out @= child.update(childArea, frameContext)\n        if out.isError (\n          return out\n        )\n      ) else if [\"icon\"].contains(child.kind) (\n        void child.update(childArea, frameContext)\n      ) else (\n        return rwl.error.Error(\"ElemInFrame\", {})\n      )\n      amount += size\n    )\n    if dir == \"x\" (\n      self.usedArea @= [\n        flipped ? (area[3] - amount) (area[1]),\n        area[2],\n        flipped ? (area[3]) (area[1] + amount),\n        area[4]\n      ]\n      self.unusedArea @= [\n        flipped ? (area[1]) (area[1] + amount),\n        area[2],\n        flipped ? (area[3] - amount) (area[3]),\n        area[4]\n      ]\n    ) else if dir == \"y\" (\n      self.usedArea @= [\n        area[1],\n        flipped ? (area[2]) (area[4] - amount),\n        area[3],\n        flipped ? (area[2] + amount) (area[4])\n      ]\n      self.unusedArea @= [\n        area[1],\n        flipped ? (area[2] + amount) (area[2]),\n        area[3],\n        flipped ? (area[4]) (area[4] - amount)\n      ]\n    )\n  )\n  \n  def render() (\n    if self.header.flags.contains(\"Hidden\") (\n      void self.renderFrameDevtools()\n      return\n    )\n    \n    void self.renderBackground()\n    void rwl.main.RenderElements(self.children)\n    void self.renderFrameDevtools()\n  )\n  \n  def renderFrameDevtools() (\n    if self.elemI == devtools.main.hoveredElement (\n      void shared.graphics.filledTransparentArea(self.usedArea, #0ff, 20)\n      void shared.graphics.filledTransparentArea(self.unusedArea, #00f, 20)\n    )\n  )\n)\n\nclass RWLSection extends RWLContainer (\n  blockName = \"section\"\n  \n  def init(array children, object header) (\n    self.children @= children\n    self.header @= header\n    void self.initGlobal()\n  )\n)\n\nclass RWLPositionedContainer extends RWLContainer (\n  def update(array containerArea, object context) (\n    void self.updateGlobal(containerArea, context)\n    \n    local height = self.expectOnHeader(\"height\", \"num\").value ?? 20\n    \n    local margin @= self.getMargin()\n    local padding @= self.getPadding()\n    \n    local anchor @= self.expectOnHeader(\"anchor\", \"str\")\n    if anchor.isError (\n      return anchor\n    )\n    anchor = anchor[\"value\"]\n    \n    if context.x == null or context.y == null (\n      anchor ??= \"c\"\n    )\n    \n    if anchor != null (\n      if [\"tl\",\"t\",\"tr\",\n          \"l\",\"c\",\"r\",\n          \"bl\",\"b\",\"br\",\n          \"top left\", \"top\", \"top right\",\n          \"left\", \"center\", \"right\",\n          \"bottom left\", \"bottom\", \"bottom right\"].contains(anchor).not() (\n        return rwl.error.Error(\"InvalidAnchorName\", {\n          name: anchor\n        })\n      )\n      \n      local anchorX = rwl.area.centerX(containerArea)\n      local anchorY = rwl.area.centerY(containerArea) + (height / 2)\n      local anchorXType = \"c\"\n      local anchorYType = \"c\"\n      \n      if anchor.endsWith(\"l\") or anchor.endsWith(\"left\") (\n        anchorXType = \"l\"\n      )\n      if anchor.endsWith(\"r\") or anchor.endsWith(\"right\") (\n        anchorXType = \"r\"\n      )\n      \n      if anchor.startsWith(\"t\") or anchor.endsWith(\"top\") (\n        anchorY = containerArea[4]\n        anchorYType = \"t\"\n      )\n      if anchor.startsWith(\"b\") or anchor.endsWith(\"bottom\") (\n        anchorY = containerArea[2] + height + margin[2] + margin[4]\n        anchorYType = \"b\"\n      )\n      \n      context.x = anchorX\n      context.y = anchorY\n      context.anchorX = anchorXType\n      context.anchorY = anchorYType\n    )\n    context.y -= height / (context.anchorY == \"b\" ? -2 2) + (context.anchorY == \"b\" ? -margin[2] margin[4])\n    \n    local area @= [\n      containerArea[1] + margin[1],\n      context.y - (height / 2),\n      containerArea[3] - margin[3],\n      context.y + (height / 2)\n    ]\n    self.fullArea @= [\n      containerArea[1],\n      context.y - (height / 2) - margin[2],\n      containerArea[3],\n      context.y + (height / 2) + margin[4]\n    ]\n    \n    context.y -= height / (context.anchorY == \"b\" ? -2 2) + (context.anchorY == \"c\" ? 0 context.anchorY == \"b\" ? -margin[4] margin[2])\n    \n    void self.updateBackground(area)\n    \n    local childArea @= rwl.area.pad(area, padding)\n    \n    self.childArea @= childArea\n    \n    return rwl.main.UpdateElements(self.children, childArea, {\n      anchorX: \"c\",\n      anchorY: \"c\",\n      color: \"#fff\",\n      inst: context.inst\n    }, self)\n  )\n  \n  def render() (\n    if self.header.flags.contains(\"Hidden\") (\n      void self.renderDevtools()\n      return\n    )\n    \n    void self.renderBackground()\n    if rwl.main.debug (\n      void rwl.debug.box(self.area, #f00)\n      void rwl.debug.box(self.childArea, #0f0)\n      void rwl.debug.box(self.outArea, #00f)\n    )\n    void rwl.main.RenderElements(self.children)\n    void self.renderDevtools()\n  )\n)\n\nclass RWLButton extends RWLPositionedContainer (\n  blockName = \"button\"\n  \n  def init(array children, object header) (\n    self.children @= children\n    self.header @= header\n    void self.initGlobal()\n  )\n  \n  def isHovered() (\n    return mouse_x > self.area[1] and mouse_y > self.area[2] and mouse_x < self.area[3] and mouse_y < self.area[4]\n  )\n  \n  def updateBackgroundColor() (\n    local color @= self.expectOnHeader(\"color\", \"color\")\n    if color.isError (\n      return color\n    )\n    if color != null (\n      self.color @= color.value\n    )\n    \n    local hover_color @= self.expectOnHeader(\"hover_color\", \"color\")\n    if hover_color.isError (\n      return hover_color\n    )\n    if hover_color != null (\n      self.hover_color @= hover_color.value\n    )\n  )\n  \n  def renderBackground() (\n    local hov = self.isHovered()\n    \n    local col = self.color\n    if self.hover_color != null and hov (\n      col = self.hover_color\n    )\n    if col != null (\n      void shared.graphics.filledBox(self.area, self.rounding, col)\n    )\n    \n    //void shared.graphics.box(self.area, #fff)\n  )\n  \n  def interactUpdate(object context) (\n    if self.isHovered() (\n      // rework to use actual ordering system / order elemI on elem creation\n      //log context.topI self.elemI\n      if context.topI < self.elemI (\n        context.top @= self\n        context.topI = self.elemI\n      )\n    )\n  )\n  \n  def topUpdate(object context) (\n    //log \"hi\" context shared.input.rwlLeftClick\n    if shared.input.rwlLeftClick (\n      void context.rtr.runEvents({\n        name: \"click\",\n        element: self\n      }, {})\n    )\n  )\n)\n\nclass RWLScript extends RWLNode (\n  blockName = \"script\"\n  kind = \"script\"\n  \n  def init(body, object header, object inst) (\n    self.body @= body\n    self.header @= header\n    \n    void self.parse()\n    void self.makeModule(inst)\n  )\n  \n  def parse() (\n    self.ast @= null\n    // TODO: try\n    local parser @= rtr.ast.Parser(body)\n    self.ast @= parser.parse()\n  )\n  \n  def makeModule(object inst) (\n    if self.ast != null (\n      self.mod @= rtr.main.Module(self.ast)\n      void inst.rtrInst.addModule(self.mod)\n    )\n  )\n  \n  def update(array area, object context) (\n    if self.mod != null (\n      void self.mod.runEvent({\n        name: \"onupdate\"\n      }, {})\n    )\n  )\n  \n  def start() (\n    void self.mod.runEvent({\n      name: \"onload\",\n    }, {})\n  )\n)\n\nclass RWLElement extends RWLNode (\n  kind = \"element\"\n  def init(object value, object header) (\n    self.value @= value\n    self.header @= header\n    void self.initGlobal()\n  )\n  \n  def update(array area, object context) (\n    void self.updateGlobal(area, context)\n    local text = null\n    \n    switch self.value.type (\n      case \"str\"; case \"num\"\n        text = self.value.value.toStr()\n        break\n    )\n    \n    if text == null (\n      return rwl.error.Error(\"InvalidElemType\", {\n        valueType: self.value.type\n      })\n    )\n    \n    // font\n    //<font>\n    local size @= self.expectOnHeader(\"size\", \"num\")\n    if size.isError (\n      return size\n    )\n    size = size[\"value\"] ?? 10\n    \n    local spacing @= self.expectOnHeader(\"spacing\", \"num\")\n    if spacing.isError (\n      return spacing\n    )\n    spacing = spacing[\"value\"] ?? 1\n    \n    local line_height @= self.expectOnHeader(\"line_height\", \"num\")\n    if line_height.isError (\n      return line_height\n    )\n    line_height = spacing[\"line_height\"] ?? 1\n    \n    // positioning\n    local margin @= self.getMargin()\n    \n    local anchor @= self.expectOnHeader(\"anchor\", \"str\")\n    if anchor.isError (\n      return anchor\n    )\n    anchor = anchor[\"value\"]\n    \n    if context.x == null or context.y == null (\n      anchor ??= \"c\"\n    )\n    \n    if anchor != null (\n      if [\"tl\",\"t\",\"tr\",\n          \"l\",\"c\",\"r\",\n          \"bl\",\"b\",\"br\",\n          \"top left\", \"top\", \"top right\",\n          \"left\", \"center\", \"right\",\n          \"bottom left\", \"bottom\", \"bottom right\"].contains(anchor).not() (\n        return rwl.error.Error(\"InvalidAnchorName\", {\n          name: anchor\n        })\n      )\n      \n      local anchorX = rwl.area.centerX(area)\n      local anchorY = rwl.area.centerY(area) + (line_height * 1 * size)\n      local anchorXType = \"c\"\n      local anchorYType = \"c\"\n      \n      if anchor.endsWith(\"l\") or anchor.endsWith(\"left\") (\n        anchorX = area[1] + margin[1]\n        anchorXType = \"l\"\n      )\n      if anchor.endsWith(\"r\") or anchor.endsWith(\"right\") (\n        anchorX = area[3] - margin[3]\n        anchorXType = \"r\"\n      )\n      \n      if anchor.startsWith(\"t\") or anchor.endsWith(\"top\") (\n        anchorY = area[4]\n        anchorYType = \"t\"\n      )\n      if anchor.startsWith(\"b\") or anchor.endsWith(\"bottom\") (\n        anchorY = area[2]\n        anchorYType = \"b\"\n      )\n      \n      context.x = anchorX\n      context.y = anchorY\n      context.anchorX = anchorXType\n      context.anchorY = anchorYType\n    )\n    \n    local boxAlignment = context.anchorX\n    \n    local alignment @= self.expectOnHeader(\"alignment\", \"str\")\n    if alignment.isError (\n      return alignment\n    )\n    alignment = alignment[\"value\"]\n    if alignment != null (\n      if [\"l\",\"c\",\"r\",\n          \"left\", \"center\", \"right\"].contains(alignment).not() (\n        return rwl.error.Error(\"InvalidAlignmentName\", {\n          name: anchor\n        })\n      )\n      \n      if alignment.endsWith(\"l\") or alignment.endsWith(\"left\") (\n        alignment = \"l\"\n      )\n      if alignment.endsWith(\"r\") or alignment.endsWith(\"right\") (\n        alignment = \"r\"\n      )\n    )\n    alignment ??= boxAlignment\n    \n    // appearance\n    //<link>\n    //<decoration>\n    local color @= self.expectOnHeader(\"color\", \"color\")\n    if color.isError (\n      return color\n    )\n    color = color.value\n    if color != null (\n      context.color = color\n    )\n    color ??= context.color\n    \n    local linesr @= text.split(\"\\n\")\n    local width = 0\n    for lineI linesr.len (\n      width = max(width, linesr[lineI].len * size * spacing)\n    )\n    local height = lines.len * line_height * 2 * size\n    \n    local x = context.x\n    if boxAlignment == \"l\" (\n      x += width / 2\n    )\n    if boxAlignment == \"r\" (\n      x += width / -2\n    )\n    \n    context.y -= height / (context.anchorY == \"b\" ? -2 2) + (context.anchorY == \"b\" ? -margin[2] margin[4])\n    \n    self.lines @= []\n    //log self.lines\n    local y = context.y + (height / 2)\n    for lineI linesr.len (\n      y -= size * line_height\n      local lineW = shared.graphics.getTextWidth(linesr[lineI]) * size\n      local lx = x\n      if alignment == \"l\" (\n        lx += width / -2\n      )\n      if alignment == \"r\" (\n        lx += width / 2 - lineW\n      )\n      if alignment == \"c\" (\n        // account for char spacing\n        lx += lineW * -.5\n      )\n      //log self\n      self.lines ??= []\n      void self.lines.append([linesr[lineI], lx, y, size, color])\n      y -= size * line_height\n    )\n    \n    self.debugArea @= [\n      x - (width / 2),\n      context.y - (height / 2),\n      x + (width / 2),\n      context.y + (height / 2)\n    ]\n    self.margin @= margin\n    \n    context.y -= height / (context.anchorY == \"b\" ? -2 2) + (context.anchorY == \"b\" ? -margin[4] margin[2])\n  )\n  \n  def render() (\n    if self.header.flags.contains(\"Hidden\") (\n      void self.renderDevtools()\n      return\n    )\n    \n    for lineI self.lines.len (\n      local line @= self.lines[lineI]\n      void shared.graphics.ptext(line[1], line[2], line[3], line[4], line[5])\n    )\n    \n    void rwl.debug.box(self.debugArea ?? [])\n    void self.renderDevtools()\n  )\n  \n  def renderDevtools() (\n    if self.elemI == devtools.main.hoveredElement (\n      void shared.graphics.filledTransparentArea(self.debugArea, #0ff, 20)\n      \n      local fullArea = rwl.area.margin(self.debugArea, self.margin)\n     \n      if fullArea != null (\n        // left\n        void shared.graphics.filledTransparentArea([\n          fullArea[1],\n          fullArea[2],\n          self.debugArea[1],\n          fullArea[4]\n        ], #f0f, 20)\n        // right\n        void shared.graphics.filledTransparentArea([\n          self.debugArea[3],\n          fullArea[2],\n          fullArea[3],\n          fullArea[4]\n        ], #f0f, 20)\n        // top\n        void shared.graphics.filledTransparentArea([\n          self.debugArea[1],\n          self.debugArea[4],\n          self.debugArea[3],\n          fullArea[4]\n        ], #f0f, 20)\n        // bottom\n        void shared.graphics.filledTransparentArea([\n          self.debugArea[1],\n          fullArea[2],\n          self.debugArea[3],\n          self.debugArea[2]\n        ], #f0f, 20)\n      )\n    )\n  )\n)\n\nclass RWLIcon extends RWLNode (\n  kind = \"icon\"\n  \n  def update(array area, object context) (\n    local scale @= self.expectOnHeader(\"scale\", \"num\")\n    if scale.isError (\n      return scale\n    )\n    self.scale = size.value ?? 1\n    \n    local src @= self.expectOnHeader(\"src\", \"str\")\n    if src.isError (\n      return src\n    )\n    if src == null (\n      return rwl.error.Error(\"NoIconSrc\", {})\n    )\n    self.src = src.value\n    \n    local color @= self.expectOnHeader(\"color\", \"color\")\n    if color.isError (\n      return color\n    )\n    self.color = color.value\n    \n    // TODO: anchors?\n    self.x = rwl.area.centerX(area)\n    self.y = rwl.area.centerY(area)\n  )\n  \n  def render() (\n    if self.header.flags.contains(\"Hidden\") (\n      void self.renderDevtools()\n      return\n    )\n    \n    void shared.graphics.picon(self.src, self.x, self.y, self.scale, self.color ?? \"#fff\")\n    void self.renderDevtools()\n  )\n  \n  def init(object header) (\n    self.header @= header\n  )\n)\n\ndef UpdateElements(array elements, array area, object context, object parentElem) (\n  for i elements.len (\n    elements[i].parent @= parentElem\n    local out @= elements[i].update(area, context)\n    if out.isError (\n      return out\n    )\n  )\n)\n\ndef RenderElements(array elements) (\n  for i elements.len (\n    //void\n    void elements[i].render()\n    void\n  )\n)\n\nelemI = 0\ndef AstToElement(ast, object inst) (\n  def AstToHeader(header) (\n    local flags @= []\n    local pairs @= []\n    for attrI header.attributes.len (\n      local attr @= header.attributes[attrI]\n      switch attr.kind (\n        case \"flag\"\n          flags.append(attr.data)\n          break\n        case \"key\"\n          void pairs.append([attr.key, rwl.value.AstToValue(attr.value)])\n          break\n      )\n    )\n    return { flags, pairs }\n  )\n  //log \"a\" ast\n  local header @= AstToHeader(ast.data.header)\n  \n  switch ast.kind (\n    case \"block\"\n      if ast.data.header.key != \"script\" (\n        local children @= AstsToElements(ast.data.content.elements, inst)\n      )\n      if typeof(children) != \"array\" and children[\"isError\"] (\n        return children\n      )\n      switch ast.data.header.key (\n        // top level\n        case \"root\"\n          return rwl.main.RWLRoot(children, header)\n        \n        // normal\n        case \"frame\"\n          return rwl.main.RWLFrame(children, header)\n        case \"section\"\n          return rwl.main.RWLSection(children, header)\n        \n        case \"script\"\n          return rwl.main.RWLScript(shared.utils.removeIndents(ast.data.content), header, inst)\n        \n        case \"button\"\n          return rwl.main.RWLButton(children, header)\n        \n        default\n          return rwl.error.Error(\"UnknownBlockType\", {\n            blockType: ast.data.header.key\n          })\n          break\n      )\n      break\n    \n    case \"element\"\n      return rwl.main.RWLElement(rwl.value.AstToValue(ast.data.value), header)\n    \n    case \"icon\"\n      return rwl.main.RWLIcon(header)\n    \n    default\n      return rwl.error.Error(\"UnknownElementKind\", {\n        elementKind: ast.kind\n      })\n      break\n  )\n)\n\ndef AstsToElements(elements, object inst) (\n  local elems @= []\n  for i elements.len (\n    local out @= AstToElement(elements[i], inst)\n    if out.isError (\n      return out\n    )\n    void elems.append(out)\n  )\n  return elems\n)\n\nclass RWL (\n  def init(object ast, object rtrInst) (\n    self.rtrInst @= rtrInst\n    self.errored = false\n    self.needsUpdate = true\n    self.hasUpdated = false\n    \n    self._lastW = 0\n    self._lastH = 0\n    self._lastX = 0\n    self._lastY = 0\n    \n    void self.loadFromAst(ast)\n  )\n  \n  def loadFromAst(object ast) (\n    self.ast @= ast\n    self.elements @= rwl.main.AstsToElements(ast.elements, self)\n    \n    if typeof(self.elements) != \"array\" and self.elements.isError (\n      error self.elements.stringify()\n      self.errored = true\n      return\n    )\n  )\n  \n  def update(array area) (\n    self.hasUpdated = true\n    if self.errored (\n      return\n    )\n    \n    local out @= rwl.main.UpdateElements(self.elements, area, {\n      inst: self,\n      root: true\n    }, {})\n    if out.isError (\n      error out.stringify()\n      self.errored = true\n      self.errormsg = out.stringify()\n    )\n  )\n  \n  def checkUpdate(array area) (\n    local w = rwl.area.width(area)\n    local h = rwl.area.height(area)\n    local x = rwl.area.centerX(area)\n    local y = rwl.area.centerY(area)\n    \n    // if the width or height or x or y has changed, update\n    if w != self._lastW or h != self._lastH or x != self._lastX or y != self._lastY (\n      self.needsUpdate = true\n      \n      self._lastW = w\n      self._lastH = h\n      self._lastX = x\n      self._lastY = y\n    )\n    \n    if self.needsUpdate (\n      void self.update(area)\n      self.needsUpdate = false\n    )\n  )\n  \n  def interactUpdate(object context) (\n    if self.errored (\n      return\n    )\n  \n    context.top = null\n    context.topI = 0\n    for i self.elements.len (\n      void self.elements[i].interactUpdate(context)\n    )\n    \n    //log context.top\n    \n    if context.top != null (\n      void context.top.topUpdate(context)\n    )\n  )\n  \n  def checkElemUpdate() (\n    if self.errored (\n      return\n    )\n  \n    for i self.elements.len (\n      void self.elements[i].checkUpdate()\n    )\n  )\n  \n  def render(array area) (\n    void self.checkUpdate(area)\n  \n    self.worker.area @= area\n    if self.errored (\n      goto rwl.area.centerX(area) rwl.area.centerY(area)\n      centext \"rwl errored :(\" 12 : c#shared.theme.seco\n      if self.errormsg != null (\n        centext self.errormsg 8 : c#shared.theme.prim chy#-20\n      )\n      return\n    )\n    \n    void rwl.main.RenderElements(self.elements)\n  )\n  \n  def getElement(string id) (\n    local queue @= [...self.elements]\n    while queue.len > 0 (\n      local elem @= queue.shift()\n      \n      if elem.id == id (\n        return elem\n      )\n      \n      if elem.children != null (\n        for i elem.children.len (\n          void queue.append(elem.children[i])\n        )\n      )\n    )\n  )\n)\n",""],[".osl","debug","def box(array area, color) (\n  if !rwl.main.debug (\n    return\n  )\n  void shared.graphics.box(area, color ?? #f00)\n)",""],[".osl","ast","\nclass Parser (\n  def init(string text) (\n    void self.tokenise(text)\n  )\n  \n  def parse() (\n    self.pointer = 1\n    \n    local out @= {\n      elements: self.blockContent()\n    }\n    \n    if !self.atEnd() (\n      throw \"unexpected token '\" ++ self.peek() ++ \"'\"\n    )\n    \n    return out\n  )\n  \n  def peek() (\n    return self.tokens[self.pointer]\n  )\n  def consume() (\n    local tkn = self.peek()\n    self.pointer ++\n    return tkn\n  )\n  def consumeWhitespace() (\n    while self.peek().match(\"/^\\\\s$/\") != null (\n      void self.consume()\n    )\n  )\n  def consumeSpaces() (\n    local txt = \"\"\n    while self.peek() == \" \" (\n      txt ++= self.consume()\n    )\n    return txt\n  )\n  def atEnd() (\n    return self.pointer >= self.tokens.len\n  )\n  def expect(string token) (\n    local tkn @= self.consume()\n    if tkn != token (\n      throw \"expected '\" ++ token ++ \"' got '\" ++ tkn ++ \"'\"\n    )\n    return tkn\n  )\n  def expects(array tokens) (\n    local tkn @= self.consume()\n    if !tokens.contains(tkn) (\n      throw \"expected '\" ++ tokens.join(\" or \") ++ \"' got '\" ++ tkn ++ \"'\"\n    )\n    return tkn\n  )\n  def expectText() (\n    local tkn @= self.consume()\n    if !tkn.match(\"/^[a-zA-Z_0-9]+$/\") (\n      throw \"identifier must consist of letters or _\"\n    )\n    return tkn\n  )\n  def getPos() (\n    local ln = 1\n    local col = 0\n    local i = self.pointer\n    for t self.pointer (\n      col ++\n      if self.tokens[t] == \"\\n\" (\n        ln ++\n        col = 0\n      )\n    )\n    return { ln, col, i }\n  )\n  \n  def tokenise(string text) (\n    self.tokens @= []\n    local splitChars @= [\n      // rwl\n      \"{\",\"}\",\n      \"[\",\"]\",\n      \",\",\n      \" \",\n      \"\\n\",\n      \"/\",\"\\\\\",\"*\",\n      \"'\",\"\\\"\",\"`\",\n      \":\",\"#\",\"%\",\"=\",\n      // rtr\n      \"(\",\")\",\n      \"[\",\"]\",\n      \"{\",\"}\",\n      \",\",\";\",\":\",\"=\",\".\",\n      \"+\",\"-\",\"*\",\"/\",\"%\",\"^\",\n      \"\\\\\",\n      \"'\",\"\\\"\",\"`\",\n      \" \",\"\\n\",\n      \"!\",\"?\"\n    ]\n    local buf = \"\"\n    for i text.len (\n      if splitChars.contains(text[i]) (\n        if buf.len > 0 (\n          void self.tokens.append(buf)\n        )\n        void self.tokens.append(text[i])\n        buf = \"\"\n      ) else (\n        buf ++= text[i]\n      )\n    )\n    if buf.len > 0 (\n      self.tokens.append(buf)\n    )\n  )\n  \n  // statements\n  def blockContent() (\n    local statements @= []\n    local end = false\n    while !end (\n      local out @= self.statement()\n      if out != null (\n        void statements.append(out)\n      )\n      void self.consumeWhitespace()\n      if self.peek() == \"}\" or self.atEnd() (\n        end = true\n      ) else (\n        void self.expect(\",\")\n      )\n    )\n    return statements\n  )\n  \n  def statement() (\n    void self.consumeWhitespace()\n    \n    local start @= self.getPos()\n    local tkn @= self.peek()\n    \n    // void elements\n    if [\"icon\",\"image\"].contains(tkn) (\n      void self.consume()\n      void self.consumeWhitespace()\n      local header @= self.header()\n      \n      return {\n        data: {\n          header\n        },\n        kind: tkn,\n        start, end: self.getPos()\n      }\n    )\n    \n    // block\n    if tkn.match(\"/^[a-zA-Z]+$/\") != null (\n      return self.blockStatement()\n    )\n    \n    // element\n    local value @= self.value()\n    if value != null (\n      void self.consumeWhitespace()\n      local header @= self.header()\n      \n      return {\n        data: {\n          value,\n          header\n        },\n        kind: \"element\",\n        start, end: self.getPos()\n      }\n    )\n  )\n  \n  def blockStatement() (\n    local start @= self.getPos()\n    local key @= self.consume()\n    \n    void self.consumeWhitespace()\n    \n    local header @= self.header()\n    header.key = key\n    \n    void self.consumeWhitespace()\n    \n    if key == \"script\" (\n      local content = \"\"\n      local spaceContent = \"\"\n      void self.expect(\"{\")\n      local end = false\n      local depth = 1\n      local stringType = null\n      while !end (\n        local tkn @= self.peek()\n        \n        if tkn == \"'\" (\n          if stringType == \"'\" (\n            stringType = null\n          ) else if stringType == null (\n            stringType = \"'\"\n          )\n        )\n        \n        if tkn == \"\\\"\" (\n          if stringType == \"\\\"\" (\n            stringType = null\n          ) else if stringType == null (\n            stringType = \"\\\"\"\n          )\n        )\n        \n        if tkn == \"`\" (\n          if stringType == \"`\" (\n            stringType = null\n          ) else if stringType == null (\n            stringType = \"`\"\n          )\n        )\n        \n        if stringType == null (\n          if tkn == \"{\" (\n            depth ++\n          )\n          if tkn == \"}\" (\n            depth --\n          )\n        )\n        \n        if self.atEnd() or (tkn == \"}\" and depth == 0 and stringType == null) (\n          end = true\n        ) else (\n          if tkn == \"\\n\" (\n            spaceContent = \"\"\n            void self.consume()\n            if content != \"\" (\n              content ++= \"\\n\"\n            )\n          ) else if tkn == \" \" (\n            spaceContent ++= self.consume()\n          ) else (\n            content ++= spaceContent\n            content ++= self.consume()\n            spaceContent = \"\"\n          )\n        )\n      )\n      void self.expect(\"}\")\n    ) else (\n      local content @= self.block()\n    )\n    \n    return {\n      kind: \"block\",\n      data: {\n        header,\n        content\n      },\n      start, end: self.getPos()\n    }\n  )\n  \n  def block() (\n    local start @= self.getPos()\n    void self.expect(\"{\")\n    void self.consumeWhitespace()\n    local elements @= self.blockContent()\n    void self.consumeWhitespace()\n    void self.expect(\"}\")\n    return { elements, start, end: self.getPos() }\n  )\n  \n  // header stuff\n  def header() (\n    local start @= self.getPos()\n    local attributes @= []\n    if self.peek() == \"[\" (\n      void self.expect(\"[\")\n      local end = self.peek() == \"]\"\n      while !end (\n        local out @= self.headerItem()\n        if out != null (\n          void attributes.append(out)\n        )\n        void self.consumeWhitespace()\n        if self.peek() == \",\" (\n          void self.consume()\n        )\n        if self.peek() == \"]\" or self.atEnd() (\n          end = true\n        )\n      )\n      void self.expect(\"]\")\n    )\n    \n    return { attributes, start, end: self.getPos() }\n  )\n  def headerItem() (\n    void self.consumeWhitespace()\n    local start @= self.getPos()\n    local tkn @= self.consume()\n    void self.consumeWhitespace()\n    if self.peek() == \"=\" (\n      if tkn.match(\"/^[a-zA-Z_]+$/\") == null (\n        throw \"attribute key must consist of letters or _\"\n      )\n      void self.consume()\n      local value @= self.value()\n      return {\n        kind: \"key\",\n        key: tkn,\n        value,\n        start, end: self.getPos()\n      }\n    )\n    if tkn.match(\"/^[a-zA-Z_]+$/\") != null (\n      return {\n        kind: \"flag\",\n        data: tkn,\n        start, end: self.getPos()\n      }\n    )\n  )\n  \n  // values\n  def value() (\n    if [\"'\",\"\\\"\",\"`\"].contains(self.peek()) (\n      return self.str()\n    )\n    \n    if self.peek().match(\"/^[0-9]+$/\") != null (\n      return self.num()\n    )\n    \n    if self.peek() == \"#\" (\n      return self.color()\n    )\n    \n    if self.peek().match(\"/^\\\\w+$/\") != null (\n      return self.property()\n    )\n  )\n  \n  def str() (\n    local start @= self.getPos()\n    local q @= self.expects([\"'\",\"\\\"\",\"`\"])\n    local content = \"\"\n    local end = false\n    while !end (\n      local tkn @= self.peek()\n      if tkn == \"\\\\\" (\n        void self.consume()\n        local tkn = self.consume()\n        local char = tkn[1]\n        switch char (\n          case \"n\"\n            char = \"\\n\"\n            break\n        )\n        content ++= char ++ tkn.trim(2,-1)\n        continue\n      )\n      \n      if q == tkn (\n        end = true\n      ) else (\n        content ++= self.consume()\n      )\n      if self.atEnd() (\n        end = true\n      )\n    )\n    void self.expect(q)\n    return {\n      type: \"str\",\n      value: content,\n      start, end: self.getPos()\n    }\n  )\n  \n  // and percentage\n  def num() (\n    if self.peek().match(\"/^[0-9]+$/\") == null (\n      throw \"unexpected token '\" ++ self.peek() ++ \"'\"\n    )\n    \n    local start @= self.getPos()\n    \n    local value @= self.consume().toNum()\n    \n    local type = \"num\"\n    \n    if self.peek() == \"%\" (\n      void self.consume()\n      type = \"percentage\"\n    )\n    \n    return {\n      type,\n      value,\n      start, end: self.getPos()\n    }\n  )\n  \n  def color() (\n    local start @= self.getPos()\n    void self.expect(\"#\")\n    local value = self.consume()\n    if ![3,6].contains(value.len) (\n      throw \"hex values can only be 3 or 6 characters long\"\n    )\n    return {\n      type: \"color\",\n      value: \"#\" ++ value,\n      start, end: self.getPos()\n    }\n  )\n  \n  def property() (\n    local start @= self.getPos()\n    local source = self.consume()\n    if source.match(\"/^[a-zA-Z_]+$/\") == null (\n      throw \"source must consist of letters or _\"\n    )\n    \n    void self.consumeWhitespace()\n    void self.expect(\":\")\n    void self.consumeWhitespace()\n    \n    local name = self.consume()\n    if name.match(\"/^[a-zA-Z_]+$/\") == null (\n      throw \"name must consist of letters or _\"\n    )\n    \n    return {\n      type: \"property\",\n      source,\n      name,\n      start, end: self.getPos()\n    }\n  )\n)\n",""]],"c #571028 square 0 2 10 4 c #E91E63 square -8 6 2 2 line -5 7 3 0 square 0 -1 10 5 w 8 square 0 -0.5 5 0"],[".folder","rtr",[[".osl","main","\nclass Module (\n  def init(object ast) (\n    void self.loadFromAst(ast)\n    void self.initScope()\n    void self.defScope()\n    \n    self.eventQueue @= []\n    self.initTopDone = false\n    \n    // only used in bytecode\n    self.returnVal = null\n  )\n  def loadFromAst(object ast) (\n    self.ast @= ast\n    \n    self.events @= []\n    self.eventList @= []\n    for i self.ast.elements.len (\n      local topLevel @= self.ast.elements[i]\n      if topLevel.kind == \"event\" (\n        if topLevel.target.kind == \"global\" (\n          if self.eventList.contains(topLevel.target.target) (\n            throw topLevel.target.target + \"event already exists on module\"\n          )\n          void self.eventList.append(topLevel.target.target)\n        )\n        void self.events.append([\n          topLevel.target,\n          topLevel\n        ])\n      )\n    )\n  )\n  def initTop() (\n    if self.initTopDone (\n      return\n    )\n    self.initTopDone = true\n    \n    self.ast @= ast\n    \n    void self.newScope({})\n    for i self.ast.elements.len (\n      local topLevel @= self.ast.elements[i]\n      if topLevel.kind == \"global\" (\n        local val @= self.runExpression(topLevel.val)\n        local meta = null\n        if topLevel.auto (\n          meta @= {\n            type: val.getRtrType()\n          }\n        )\n        void self.declScopeVar(topLevel.name, val, meta)\n      )\n    )\n  )\n  \n  def initScope() (\n    self.scope @= []\n  )\n  def newScope(object vars) (\n    void self.scope.append(vars)\n  )\n  def popScope() (\n    return self.scope.pop()\n  )\n  def defScope() (\n    // helper funcs\n    local cFunc @= def(name, content) -> (\n      void self.setScopeVar(name, rtr.value.RTROslFuncValue(content))\n    )\n    \n    void self.newScope({})\n    \n    void self.setScopeVar(\"true\", rtr.value.RTRBoolValue(true))\n    void self.setScopeVar(\"false\", rtr.value.RTRBoolValue(false))\n    \n    cFunc(\"log\", def(args, inst) -> (\n      local txt = args.map(a -> a.stringify()).join(\" \")\n      log txt\n      void inst.inst.console.append([\"log\", txt])\n    ))\n    cFunc(\"error\", def(args, inst) -> (\n      local txt = args.map(a -> a.stringify()).join(\" \")\n      void inst.inst.console.append([\"err\", txt])\n      throw txt\n    ))\n    cFunc(\"return\", def(args, inst) -> (\n      local val @= args[1]\n      val ??= rtr.value.RTRNullValue()\n      void inst.setScopeVar(\"@return\", val)\n      inst.returnVal @= val\n    ))\n    cFunc(\"typeof\", def(args) -> (\n      local val @= args[1] ?? rtr.value.RTRNullValue()\n      return val.getRtrType()\n    ))\n    cFunc(\"length\", def(args) -> (\n      return rtr.value.RTRNumValue(args[1].length())\n    ))\n    \n    // mathematical\n    cFunc(\"min\", def(args) -> (\n      local v = args[1].numbify()\n      for i args.len - 1 (\n        local a @= args[i + 1].numbify()\n        v = min(v, a)\n      )\n      return rtr.value.RTRNumValue(v)\n    ))\n    cFunc(\"max\", def(args) -> (\n      local v = args[1].numbify()\n      for i args.len - 1 (\n        local a @= args[i + 1].numbify()\n        v = max(v, a)\n      )\n      return rtr.value.RTRNumValue(v)\n    ))\n    \n    cFunc(\"abs\", def(args) -> (\n      return rtr.value.RTRNumValue(args[1].numbify().abs())\n    ))\n    cFunc(\"sqrt\", def(args) -> (\n      return rtr.value.RTRNumValue(args[1].numbify().sqrt())\n    ))\n    \n    cFunc(\"round\", def(args) -> (\n      return rtr.value.RTRNumValue(args[1].numbify().round())\n    ))\n    cFunc(\"floor\", def(args) -> (\n      return rtr.value.RTRNumValue(args[1].numbify().floor())\n    ))\n    cFunc(\"ceil\", def(args) -> (\n      return rtr.value.RTRNumValue(args[1].numbify().ceiling())\n    ))\n    \n    // string\n    cFunc(\"join\", def(args) -> (\n      local txt = \"\"\n      for i args.len (\n        txt ++= args[i].stringify()\n      )\n      return rtr.value.RTRStrValue(txt)\n    ))\n    cFunc(\"split\", def(args) -> (\n      return rtr.value.RTRArrValue(args[1]\n        .stringify()\n        .split(args[2].stringify())\n        .map(e -> rtr.value.RTRStrValue(e)))\n    ))\n    \n    cFunc(\"chr\", def(args) -> (\n      return rtr.value.RTRStrValue(args[1].numbify().chr())\n    ))\n    cFunc(\"ord\", def(args) -> (\n      return rtr.value.RTRNumValue(args[1].stringify().ord())\n    ))\n    \n    cFunc(\"toUpper\", def(args) -> (\n      return rtr.value.RTRStrValue(args[1].stringify().toUpper())\n    ))\n    cFunc(\"toLower\", def(args) -> (\n      return rtr.value.RTRStrValue(args[1].stringify().toLower())\n    ))\n    cFunc(\"toTitle\", def(args) -> (\n      return rtr.value.RTRStrValue(args[1].stringify().toTitle())\n    ))\n    \n    // array\n    cFunc(\"item\", def(args) -> (\n      return args[1].getItem(args[2])\n    ))\n    cFunc(\"range\", def(args) -> (\n      return rtr.value.RTRArrValue((args[1].numbify() to args[2].numbify()).map(e -> rtr.value.RTRNumValue(e)))\n    ))\n    \n    // object\n    cFunc(\"keys\", def(args) -> (\n      return rtr.value.RTRArrValue(args[1].keys().map(e -> rtr.value.RTRStrValue(e)))\n    ))\n    cFunc(\"values\", def(args) -> (\n      return rtr.value.RTRArrValue(args[1].values())\n    ))\n    cFunc(\"has\", def(args) -> (\n      return rtr.value.RTRBoolValue(args[1].has(args[2].stringify()))\n    ))\n    cFunc(\"obj\", def() -> (\n      return rtr.value.RTRObjValue({})\n    ))\n    \n    // logical\n    cFunc(\"all\", def(args) -> (\n      return rtr.value.RTRBoolValue(args.every(a -> a.boolify()))\n    ))\n    cFunc(\"any\", def(args) -> (\n      return rtr.value.RTRBoolValue(args.some(a -> a.boolify()))\n    ))\n    cFunc(\"not\", def(args) -> (\n      return rtr.value.RTRBoolValue(!args[1].boolify())\n    ))\n  )\n  def getScopeVarRaw(string key) (\n    for rawI self.scope.len (\n      local layer @= self.scope[self.scope.len - rawI + 1]\n      if layer[key] != null (\n        return layer[key]\n      )\n    )\n    return null\n  )\n  def getScopeVar(string key) (\n    return self.getScopeVarRaw(key)[1]\n  )\n  def getScopeVarMeta(string key) (\n    return self.getScopeVarRaw(key)[2]\n  )\n  def setScopeVar(string key, val, meta) (\n    meta ??= {}\n    for rawI self.scope.len (\n      local layer @= self.scope[self.scope.len - rawI + 1]\n      if layer[key] != null (\n        layer[key] @= [val, layer[key][2] ++ meta]\n        return\n      )\n    )\n    void self.declScopeVar(key, val, meta)\n  )\n  def declScopeVar(string key, val, meta) (\n    self.scope[self.scope.len][key] @= [val, meta]\n  )\n  \n  def findEligible(object target) (\n    local evs @= []\n    \n    for i self.events.len (\n      local ev @= self.events[i][2]\n      \n      if target.element != null (\n        if ev.target.kind == \"property\" and ev.target.eventName == target.name (\n          if ev.target.target.kind == \"id\" (\n            if ev.target.target.name == target.element.id (\n              void evs.append(ev)\n            )\n          )\n        )\n      ) else if typeof(ev.target.target) == \"string\" (\n        if ev.target.target == target.name (\n          void evs.append(ev)\n        )\n      )\n    )\n    \n    return evs\n  )\n  \n  def runEvents(object target, object data) (\n    void self.eventQueue.append([\n      \"events\",\n      target,\n      data\n    ])\n  )\n  def runEvent(object target, object data) (\n    void self.eventQueue.append([\n      \"event\",\n      target,\n      data\n    ])\n  )\n  \n  def runEventQueue() (\n    for i self.eventQueue.len (\n      local ev @= self.eventQueue.shift()\n      \n      if ev[1] == \"events\" (\n        void self.runEventsRaw(ev[2], ev[3])\n      )\n      if ev[1] == \"event\" (\n        void self.runEventRaw(ev[2], ev[3])\n      )\n    )\n  )\n  \n  def runEventsRaw(object target, object data) (\n    local evs @= self.findEligible(target)\n    \n    void self.initTop()\n    local p @= performance\n    for i evs.len (\n      void self.runBlock(evs[i].body)\n    )\n    log \"exec time\" performance - p\n  )\n  def runEventRaw(object target, object data) (\n    local ev @= self.findEligible(target)[1]\n    \n    if ev == null (\n      return rtr.value.RTRNullValue()\n    )\n    \n    void self.initTop()\n    local p @= performance\n    local out @= self.runBlock(ev.body)\n    log \"exec time\" performance - p\n    return out\n  )\n  def runBlock(object block) (\n    if shared.config.browser.phosphorus.useCompiler and block.compile == null (\n      local start = performance\n      local compileOut @= rtr.compiler.compileBlock(block)\n      if typeof(compileOut) != \"array\" and compileOut.isError (\n        block.compile = false\n      ) else (\n        block.compile @= compileOut\n      )\n      self.inst.compiled ??= []\n      void self.inst.compiled.append({\n        body: compileOut,\n        start: block.start,\n        end: block.end,\n        ast: block,\n        time: performance - start\n      })\n    )\n    if block.compile != null (\n      return self.runInstructions(block.compile)\n    )\n    \n    local elements @= block.elements\n    local outVal @= rtr.value.RTRNullValue()\n    void self.newScope({})\n    for i elements.len (\n      local out @= self.runStatement(elements[i])\n      if self.getScopeVar(\"@return\") ?? 0 != 0 (\n        outVal @= self.getScopeVar(\"@return\")\n        break\n      )\n    )\n    void self.popScope()\n    return outVal\n  )\n  def runStatement(object statement) (\n    switch statement.kind (\n      case \"expression\"\n        return self.runExpression(statement.expr)\n      case \"block\"\n        return self.runBlock(statement.body)\n      \n      case \"branch\"\n        if self.runExpression(statement.cond).boolify() (\n          return self.runStatement(statement.body)\n        )\n        for i statement.elifs.len (\n          local elif @= statement.elifs[i]\n          if self.runExpression(elif.cond).boolify() (\n            return self.runStatement(elif.body)\n          )\n        )\n        if statement.elseBody != null (\n          return self.runStatement(statement.elseBody)\n        )\n        return rtr.value.RTRNullValue()\n      \n      case \"while\"\n        local iters = 0\n        while self.runExpression(statement.cond).boolify() and self.getScopeVar(\"@return\") ?? 0 == 0 and iters < 999999 (\n          void self.runStatement(statement.body)\n          iters ++\n        )\n        return rtr.value.RTRNullValue()\n      case \"until\"\n        local iters = 0\n        while !self.runExpression(statement.cond).boolify() and self.getScopeVar(\"@return\") ?? 0 == 0 and iters < 999999 (\n          void self.runStatement(statement.body)\n          iters ++\n        )\n        return rtr.value.RTRNullValue()\n      case \"repeat\"\n        loop self.runExpression(statement.amount).numbify() (\n          void self.runStatement(statement.body)\n        )\n        return rtr.value.RTRNullValue()\n      case \"for\"\n        local arr @= self.runExpression(statement.arr).arrify()\n        for i arr.len (\n          void self.newScope({})\n          void self.declScopeVar(statement.var, arr[i])\n          void self.runStatement(statement.body)\n          void self.popScope()\n        )\n        return rtr.value.RTRNullValue()\n      \n      default\n        throw \"unknown statement type\" + statement.kind\n    )\n  )\n  def runExpression(object expression) (\n    switch expression.kind (\n      case \"call\"\n        local func @= self.runExpression(expression.func)\n        local args @= []\n        for i expression.args.len (\n          void args.append(self.runExpression(expression.args[i]))\n        )\n        return func.callFunc(self, args) ?? rtr.value.RTRNullValue()\n      case \"decl\"\n        local val @= self.runExpression(expression.val)\n        \n        void self.declScopeVar(expression.tar, val, {\n          type: val.getRtrType()\n        })\n        \n        return val\n      case \"asi\"\n        local val @= self.runExpression(expression.val)\n        \n        local existingMeta = null\n        local existing = null\n        switch expression.tar.kind (\n          case \"var\"\n            existingMeta @= self.getScopeVarMeta(expression.tar.name)\n            existing @= self.getScopeVar(expression.tar.name)\n            break\n          case \"prop\"\n            existing @= self.runExpression(expression.tar)\n            break\n        )\n        \n        if expression.op != null (\n          val @= self.runBinary(existing, expression.op, val)\n        )\n        \n        switch expression.tar.kind (\n          case \"var\"\n            if existingMeta != null (\n              local curType @= val.getRtrType()\n              if existingMeta.type != null (\n                if !existingMeta.type.isEqual(curType) (\n                  throw \"cannot assign\" + curType.stringify() + \"to\" + existingMeta.type.stringify() + \"variable\" \n                )\n              )\n            )\n            void self.setScopeVar(expression.tar.name, val)\n            break\n          case \"prop\"\n            local obj @= self.runExpression(expression.tar.obj)\n            local key @= expression.tar.key\n            if typeof(key) == \"string\" (\n              key @= rtr.value.RTRStrValue(key)\n            ) else (\n              key @= self.runExpression(key)\n            )\n            void obj.setItem(key, val)\n            break\n          default\n            throw \"cannot assign to\" + expression.tar.kind\n        )\n        \n        return val\n      case \"unary\"\n        local val @= self.runExpression(expression.expr)\n        return self.runUnary(expression.type, val)\n      case \"binary\"\n        local left @= self.runExpression(expression.left)\n        local right @= self.runExpression(expression.right)\n        return self.runBinary(left, expression.op, right)\n      \n      case \"var\"\n        local val @= self.getScopeVar(expression.name)\n        return val ?? rtr.value.RTRNullValue()\n      case \"prop\"\n        local obj @= self.runExpression(expression.obj)\n        local key @= expression.key\n        if typeof(key) == \"string\" (\n          key @= rtr.value.RTRStrValue(key)\n        ) else (\n          key @= self.runExpression(key)\n        )\n        return obj.getItem(key) ?? rtr.value.RTRNullValue()\n      \n      case \"str\"\n        return rtr.value.RTRStrValue(expression.val)\n      case \"num\"\n        return rtr.value.RTRNumValue(expression.val)\n      case \"func\"\n        return rtr.value.RTRAstFuncValue(expression.args, expression.body)\n      case \"arr\"\n        return rtr.value.RTRArrValue(expression.elems.map(e -> self.runExpression(e)))\n      case \"obj\"\n        local val @= {}\n        for i expression.pairs.len (\n          local pair @= expression.pairs[i]\n          val[pair.name] @= self.runExpression(pair.value)\n        )\n        return rtr.value.RTRObjValue(val)\n      case \"color\"\n        return rtr.value.RTRColorValue(expression.val)\n      \n      default\n        throw \"unknown expression type\" + expression.kind\n    )\n  )\n  def runUnary(string op, object val) (\n    switch op (\n      case \"-\"\n        return rtr.value.RTRNumValue(-val.numbify())\n      case \"+\"\n        return rtr.value.RTRNumValue(val.numbify())\n      case \"!\"\n        return rtr.value.RTRBoolValue(!val.boolify())\n      case \"?\"\n        return rtr.value.RTRBoolValue(val.boolify())\n    )\n    return rtr.value.RTRNullValue()\n  )\n  def runBinary(object left, string op, object right) (\n    local numT @= rtr.value.RTRNumValue.getRtrType()\n    switch op (\n      case \"+\"\n        if left.getRtrType().isEqual(numT) and right.getRtrType().isEqual(numT) (\n          return rtr.value.RTRNumValue(left.numbify() + right.numbify())\n        )\n        return rtr.value.RTRStrValue(left.stringify() ++ right.stringify())\n      case \"-\"\n        if left.getRtrType().isEqual(numT) and right.getRtrType().isEqual(numT) (\n          return rtr.value.RTRNumValue(left.numbify() - right.numbify())\n        )\n        return rtr.value.RTRNumValue(NaN)\n      case \"*\"\n        if left.getRtrType().isEqual(numT) and right.getRtrType().isEqual(numT) (\n          return rtr.value.RTRNumValue(left.numbify() * right.numbify())\n        )\n        return rtr.value.RTRNumValue(NaN)\n      case \"/\"\n        if left.getRtrType().isEqual(numT) and right.getRtrType().isEqual(numT) (\n          return rtr.value.RTRNumValue(left.numbify() / right.numbify())\n        )\n        return rtr.value.RTRNumValue(NaN)\n      case \"%\"\n        if left.getRtrType().isEqual(numT) and right.getRtrType().isEqual(numT) (\n          return rtr.value.RTRNumValue(left.numbify() % right.numbify())\n        )\n        return rtr.value.RTRNumValue(NaN)\n      case \"^\"\n        if left.getRtrType().isEqual(numT) and right.getRtrType().isEqual(numT) (\n          return rtr.value.RTRNumValue(left.numbify() ^ right.numbify())\n        )\n        return rtr.value.RTRNumValue(NaN)\n      \n      case \"==\"\n        return rtr.value.RTRBoolValue(left.isEqual(right))\n      case \"!=\"\n        return rtr.value.RTRBoolValue(left.isEqual(right))\n      \n      case \">\"\n        return rtr.value.RTRBoolValue(left.numbify() > right.numbify())\n      case \"<\"\n        return rtr.value.RTRBoolValue(left.numbify() < right.numbify())\n      case \">=\"\n        return rtr.value.RTRBoolValue(left.numbify() >= right.numbify())\n      case \"<=\"\n        return rtr.value.RTRBoolValue(left.numbify() <= right.numbify())\n    \n      case \"??\"\n        return left.getRtrType().data.name == \"null\" ? right left\n    )\n    \n    return rtr.value.RTRNullValue()\n  )\n  \n  def runInstructions(array instructions) (\n    self.stack ??= []\n    \n    local labels @= {}\n    \n    for i instructions.len (\n      local instruction @= instructions[i]\n      if instruction.kind == \"label\" (\n        labels[instruction.name] = i\n      )\n    )\n    \n    local i = 0\n    local iters = 0\n    while i < instructions.len and iters < 1000 (\n      i ++\n      iters ++\n      local instruction @= instructions[i]\n      //log i iters instruction self.stack.map(s -> s.stringify())\n      switch instruction.kind (\n        case \"label\"; break\n        case \"jump\"\n          i = labels[instruction.label] ?? i\n          break\n        case \"jumpIf\"\n          local val @= self.stack.pop() ?? rtr.value.RTRNullValue()\n          if val.boolify() (\n            i = labels[instruction.label] ?? i\n          )\n          break\n        case \"jumpNotIf\"\n          local val @= self.stack.pop() ?? rtr.value.RTRNullValue()\n          if !val.boolify() (\n            i = labels[instruction.label] ?? i\n          )\n          break\n        \n        case \"call\"\n          local args @= []\n          loop instruction.args (\n            void args.prepend(self.stack.pop() ?? rtr.value.RTRNullValue())\n          )\n          local func @= self.stack.pop() ?? rtr.value.RTRNullValue()\n          local out @= func.callFunc(self, args) ?? rtr.value.RTRNullValue()\n          if self.returnVal != null (\n            local out @= self.returnVal\n            self.returnVal = null\n            return out\n          )\n          void self.stack.append(out)\n          break\n        case \"unary\"\n          local val @= self.stack.pop() ?? rtr.value.RTRNullValue()\n          void self.stack.append(self.runUnary(instruction.op, val))\n          break\n        case \"binary\"\n          local right @= self.stack.pop() ?? rtr.value.RTRNullValue()\n          local left @= self.stack.pop() ?? rtr.value.RTRNullValue()\n          void self.stack.append(self.runBinary(left, instruction.op, right))\n          break\n        case \"prop\"\n          local key @= self.stack.pop() ?? rtr.value.RTRNullValue()\n          local obj @= self.stack.pop() ?? rtr.value.RTRNullValue()\n          void self.stack.append(obj.getItem(key))\n          break\n        case \"len\"\n          local obj @= self.stack.pop() ?? rtr.value.RTRNullValue()\n          void self.stack.append(rtr.value.RTRNumValue(obj.length()))\n          break\n          \n        case \"null\"\n          void self.stack.append(rtr.value.RTRNullValue())\n          break\n        case \"str\"\n          void self.stack.append(rtr.value.RTRStrValue(instruction.data))\n          break\n        case \"bool\"\n          void self.stack.append(rtr.value.RTRBoolValue(instruction.data))\n          break\n        case \"num\"\n          void self.stack.append(rtr.value.RTRNumValue(instruction.data))\n          break\n        case \"func\"\n          void self.stack.append(rtr.value.RTRBytecodeFuncValue(instruction.args, instruction.body))\n          break\n        case \"arr\"\n          local elems @= []\n          loop instruction.elems (\n            void elems.prepend(self.stack.pop() ?? rtr.value.RTRNullValue())\n          )\n          void self.stack.append(rtr.value.RTRArrValue(elems))\n          break\n        case \"obj\"\n          local values @= []\n          loop instruction.keys.len (\n            void values.prepend(self.stack.pop() ?? rtr.value.RTRNullValue())\n          )\n          \n          local obj @= {}\n          for obji values.len (\n            obj[instruction.keys[obji]] @= values[obji]\n          )\n          void self.stack.append(rtr.value.RTRObjValue(obj))\n          break\n        case \"color\"\n          void self.stack.append(rtr.value.RTRColorValue(instruction.data))\n          break\n        \n        case \"get\"\n          local val @= self.getScopeVar(instruction.name) ?? rtr.value.RTRNullValue()\n          void self.stack.append(val)\n          break\n        case \"decl\"\n          local val @= self.stack[-1] ?? rtr.value.RTRNullValue()\n          void self.declScopeVar(instruction.name, val, {\n            type: val.getRtrType()\n          })\n          break\n        case \"newScope\"\n          void self.newScope({})\n          break\n        case \"popScope\"\n          void self.popScope()\n          break\n        \n        case \"asivar\"\n          local val @= self.stack[-1] ?? rtr.value.RTRNullValue()\n          \n          local existingMeta @= self.getScopeVarMeta(instruction.name)\n          local existing @= self.getScopeVar(instruction.name)\n          \n          if instruction.op != null (\n            val @= self.runBinary(existing, instruction.op, val)\n          )\n          \n          local curType @= val.getRtrType()\n          if existingMeta.type != null (\n            if !existingMeta.type.isEqual(curType) (\n              // replace with return err\n              throw \"cannot assign\" + curType.stringify() + \"to\" + existingMeta.type.stringify() + \"variable\" \n            )\n          )\n          \n          void self.setScopeVar(instruction.name, val)\n          break\n        case \"asiprop\"\n          local key @= self.stack.pop() ?? rtr.value.RTRNullValue()\n          local obj @= self.stack.pop() ?? rtr.value.RTRNullValue()\n          \n          local val @= self.stack[-1] ?? rtr.value.RTRNullValue()\n          if instruction.op != null (\n            val @= self.runBinary(obj.getItem(key), instruction.op, val)\n          )\n          \n          void obj.setItem(key, val)\n          break\n        \n        case \"pop\"\n          void self.stack.pop()\n          break\n        case \"dupe\"\n          void self.stack.append(self.stack[instruction.i])\n          break\n        \n        default\n          return rtr.error.Error(\"UnknownInstructionKind\", { kind: instruction.kind })\n      )\n      \n    )\n    \n    return rtr.value.RTRNullValue()\n  )\n)\n\nclass RTR (\n  def init() (\n    self.modules @= {}\n    self.console @= []\n    self.ouid = OuidNew()\n    \n    self.started = false\n  )\n\n  def addModule(object mod) (\n    local key @= OuidNew()\n    mod.inst @= self\n    self.modules[key] @= mod\n    return key\n  )\n  \n  def startModules() (\n    if !self.started (\n      self.started = true\n      void self.runEvent({\n       name: \"onload\"\n      }, {})\n    )\n  )\n  \n  def runEvent(object target, object data) (\n    local mods @= self.modules.getValues()\n    for i mods.len (\n      void mods[i].runEvent(target, data)\n    )\n  )\n  def runEvents(object target, object data) (\n    local mods @= self.modules.getValues()\n    for i mods.len (\n      void mods[i].runEvents(target, data)\n    )\n  )\n)\n",""],[".osl","ast","\nclass Parser (\n  def init(string text, scriptLocation) (\n    self.scriptLocation @= scriptLocation\n    void self.tokenise(text)\n  )\n  \n  def parse() (\n    self.pointer = 1\n    local out @= self.blockContent(true)\n    \n    if !self.atEnd() (\n      throw \"unexpected token\" + self.peek()\n    )\n    \n    return { elements: out }\n  )\n  \n  def peek(amount) (\n    amount ??= 1\n    return self.tokens[self.pointer + amount - 1]\n  )\n  def consume() (\n    local tkn = self.peek()\n    self.pointer ++\n    return tkn\n  )\n  def consumeWhitespace() (\n    while self.peek().match(\"/^\\\\s$/\") != null (\n      void self.consume()\n    )\n  )\n  def atEnd() (\n    return self.pointer >= self.tokens.len\n  )\n  def expect(string token) (\n    local tkn @= self.consume()\n    if tkn != token (\n      throw \"expected '\" ++ token ++ \"' got '\" ++ tkn ++ \"'\"\n    )\n    return tkn\n  )\n  def expects(array tokens) (\n    local tkn @= self.consume()\n    if !tokens.contains(tkn) (\n      throw \"expected '\" ++ tokens.join(\" or \") ++ \"' got '\" ++ tkn ++ \"'\"\n    )\n    return tkn\n  )\n  def expectText() (\n    local tkn @= self.consume()\n    if !tkn.match(\"/^[a-zA-Z_0-9]+$/\") (\n      throw \"identifier must consist of letters or _\"\n    )\n    return tkn\n  )\n  def getPos() (\n    local ln = 1\n    local col = 0\n    local char = 0\n    local i = self.pointer\n    for t self.pointer (\n      col ++\n      char += self.tokens[t].len\n      if self.tokens[t] == \"\\n\" (\n        ln ++\n        col = 0\n        char = 0\n      )\n    )\n    return { ln, col, char, i, loc: self.scriptLocation }\n  )\n  \n  def tokenise(string text) (\n    self.tokens @= []\n    local splitChars @= [\n      \"(\",\")\",\n      \"[\",\"]\",\n      \"{\",\"}\",\n      \",\",\";\",\":\",\"=\",\".\",\"#\",\n      \"+\",\"-\",\"*\",\"/\",\"%\",\"^\",\n      \"\\\\\",\n      \"'\",\"\\\"\",\"`\",\n      \" \",\"\\n\",\n      \"!\",\"?\"\n    ]\n    local buf = \"\"\n    for i text.len (\n      if splitChars.contains(text[i]) (\n        if buf.len > 0 (\n          void self.tokens.append(buf)\n        )\n        void self.tokens.append(text[i])\n        buf = \"\"\n      ) else (\n        buf ++= text[i]\n      )\n    )\n    if buf.len > 0 (\n      self.tokens.append(buf)\n    )\n  )\n  \n  // statements\n  def blockContent(top) (\n    local statements @= []\n    local end = self.peek() == \"}\" or self.atEnd()\n    while !end (\n      if top (\n        local out @= self.topLevelStatement()\n      ) else (\n        local out @= self.statement()\n      )\n      if out != null (\n        void statements.append(out)\n      )\n      void self.consumeWhitespace()\n      if self.peek() == \";\" (\n        void self.consume()\n      )\n      if self.peek() == \"}\" or self.atEnd() (\n        end = true\n      )\n    )\n    return statements\n  )\n  \n  def topLevelStatement() (\n    void self.consumeWhitespace()\n    \n    if self.peek() == \"event\" (\n      return self.event()\n    )\n    \n    void self.consumeWhitespace()\n    \n    // global parsing\n    local ptr = self.pointer\n    \n    local start @= self.getPos()\n    local name = self.consume()\n    if name.match(\"/^[a-zA-Z_0-9]+$/\") != null (\n      void self.consumeWhitespace()\n      if self.peek() == \":\" (\n        void self.consume()\n        void self.expect(\"=\")\n        void self.consumeWhitespace()\n        local expr @= self.expression()\n        void self.expect(\";\")\n        return {\n          kind: \"global\",\n          name,\n          val: expr,\n          auto: true,\n          start, end: self.getPos()\n        }\n      )\n      if self.peek() == \"=\" (\n        void self.consume()\n        local expr @= self.expression()\n        void self.expect(\";\")\n        return {\n          kind: \"global\",\n          name,\n          val: expr,\n          start, end: self.getPos()\n        }\n      )\n    )\n    \n    self.pointer = ptr\n    \n    void self.consumeWhitespace()\n    \n    throw \"unexpected token '\" ++ self.peek() ++ \"'\"\n  )\n  \n  def event() (\n    local start @= self.getPos()\n    void self.expect(\"event\")\n    void self.consumeWhitespace()\n    void self.expect(\"(\")\n    void self.consumeWhitespace()\n    local target @= self.eventTarget()\n    void self.consumeWhitespace()\n    void self.expect(\")\")\n    void self.consumeWhitespace()\n    local body @= self.block()\n    \n    return {\n      kind: \"event\",\n      target,\n      body,\n      start, end: self.getPos()\n    }\n  )\n  \n  def statement(noSemicolon) (\n    void self.consumeWhitespace()\n    \n    // statements\n    if self.peek() == \"{\" (\n      local start @= self.getPos()\n      local body @= self.block()\n      return {\n        kind: \"block\",\n        body,\n        start, end: self.getPos()\n      }\n    )\n    \n    if self.peek() == \"if\" (\n      local start @= self.getPos()\n      void self.consume()\n      void self.consumeWhitespace()\n      void self.expect(\"(\")\n      local ifCond @= self.expression()\n      void self.expect(\")\")\n      void self.consumeWhitespace()\n      local ifBody @= self.statement()\n      \n      local elifs @= []\n      \n      void self.consumeWhitespace()\n      while self.peek() == \"elif\" (\n        void self.consume()\n        void self.consumeWhitespace()\n        void self.expect(\"(\")\n        local elifCond @= self.expression()\n        void self.expect(\")\")\n        void self.consumeWhitespace()\n        local elifBody @= self.statement()\n        \n        void elifs.append({\n          cond: elifCond,\n          body: elifBody\n        })\n        void self.consumeWhitespace()\n      )\n      \n      local elseBody = null\n      void self.consumeWhitespace()\n      if self.peek() == \"else\" (\n        void self.consume()\n        void self.consumeWhitespace()\n        local elseBody @= self.statement()\n      )\n      \n      return {\n        kind: \"branch\",\n        cond: ifCond,\n        body: ifBody,\n        elifs,\n        elseBody,\n        start, end: self.getPos()\n      }\n    )\n    \n    if [\"while\",\"until\"].contains(self.peek()) (\n      local start @= self.getPos()\n      local kind @= self.consume()\n      void self.consumeWhitespace()\n      void self.expect(\"(\")\n      local cond @= self.expression()\n      void self.expect(\")\")\n      void self.consumeWhitespace()\n      local body @= self.statement()\n      \n      return {\n        kind,\n        cond,\n        body,\n        start, end: self.getPos()\n      }\n    )\n    \n    if self.peek() == \"repeat\" (\n      local start @= self.getPos()\n      void self.consume()\n      void self.consumeWhitespace()\n      void self.expect(\"(\")\n      local amount @= self.expression()\n      void self.expect(\")\")\n      void self.consumeWhitespace()\n      local body @= self.statement()\n      \n      return {\n        kind: \"repeat\",\n        amount,\n        body,\n        start, end: self.getPos()\n      }\n    )\n    \n    if self.peek() == \"for\" (\n      local start @= self.getPos()\n      void self.consume()\n      void self.consumeWhitespace()\n      void self.expect(\"(\")\n      local var @= self.expectText()\n      void self.consumeWhitespace()\n      void self.expect(\",\")\n      void self.consumeWhitespace()\n      local arr @= self.expression()\n      void self.expect(\")\")\n      void self.consumeWhitespace()\n      local body @= self.statement()\n      return {\n        kind: \"for\",\n        var,\n        arr,\n        body,\n        start, end: self.getPos()\n      }\n    )\n    \n    local expr @= self.expression()\n    if expr != null (\n      void self.consumeWhitespace()\n      if !noSemicolon (\n        void self.expect(\";\")\n      )\n      \n      return {\n        kind: \"expression\",\n        expr\n      }\n    ) else (\n      throw \"unexpected token '\" ++ self.peek() ++ \"'\"\n    )\n  )\n  \n  def block() (\n    local start @= self.getPos()\n    void self.expect(\"{\")\n    void self.consumeWhitespace()\n    local elements @= self.blockContent()\n    void self.consumeWhitespace()\n    void self.expect(\"}\")\n    return { elements, start, end: self.getPos() }\n  )\n  \n  // event targets\n  def eventTarget() (\n    local start @= self.getPos()\n    \n    local target @= self.target()\n    \n    void self.consumeWhitespace()\n    \n    if self.peek() == \":\" (\n      void self.consume()\n      local eventName = self.expectText()\n      return {\n        kind: \"property\",\n        target,\n        eventName,\n        start, end: self.getPos()\n      }\n    )\n    \n    self.pointer = start.i\n    \n    return {\n      kind: \"global\",\n      target: self.expectText(),\n      start, end: self.getPos()\n    }\n  )\n  \n  // targets\n  def target() (\n    local start @= self.getPos()\n    \n    if self.peek() == \"*\" (\n      void self.consume()\n      return {\n        kind: \"any\"\n      }\n    )\n    \n    local kind = \"element\"\n    \n    if self.peek() == \"#\" (\n      void self.consume()\n      void self.consumeWhitespace()\n      kind = \"id\"\n    )\n    \n    local name = self.expectText()\n    \n    return {\n      kind,\n      name\n    }\n  )\n  \n  // expressions\n  def expression() (\n    return self.declare()\n  )\n  \n  def declare() (\n    if self.peek().match(\"/^[a-zA-Z_]\\\\w*$/\") != null (\n      local start @= self.getPos()\n      local ptr = self.pointer\n      local tar = self.consume()\n      void self.consumeWhitespace()\n      if self.peek() == \":\" and self.peek(2) == \"=\" (\n        void self.consume()\n        void self.consume()\n        void self.consumeWhitespace()\n        \n        local val @= self.expression()\n        \n        return {\n          kind: \"decl\",\n          tar,\n          val,\n          start, end: self.getPos()\n        }\n      )\n      self.pointer = ptr\n    )\n    \n    return self.assignment()\n  )\n  \n  def assignment() (\n    local start @= self.getPos()\n    local expr @= self.equality()\n    void self.consumeWhitespace()\n    \n    local op = null\n    \n    if self.peek() ++ self.peek(2) == \"??\" and self.peek(3) == \"=\" (\n      op = self.peek() ++ self.peek(2)\n    )\n    \n    if self.peek(2) == \"=\" and [\"+\",\"-\",\"*\",\"/\",\"%\",\"^\"].contains(self.peek()) (\n      op = self.peek()\n    )\n    \n    if op != null or self.peek() == \"=\" (\n      if op != null (\n        loop op.len (\n          void self.consume()\n        )\n      )\n      void self.consume()\n      void self.consumeWhitespace()\n      \n      local val @= self.expression()\n      \n      return {\n        kind: \"asi\",\n        op,\n        tar: expr,\n        val,\n        start, end: self.getPos()\n      }\n    )\n    \n    return expr\n  )\n  \n  def equality() (\n    local expr @= self.comparison()\n    void self.consumeWhitespace()\n    \n    while [\"==\",\"!=\"].contains(self.peek() ++ self.peek(2)) (\n      local op @= self.consume() ++ self.consume()\n      local right @= self.comparison()\n      expr @= {\n        kind: \"binary\",\n        op,\n        left: expr,\n        right\n      }\n    )\n    \n    return expr\n  )\n  \n  def comparison() (\n    local expr @= self.term()\n    \n    local end = false\n    while !end (\n      void self.consumeWhitespace()\n      if [\">\",\"<\"].contains(self.peek()) (\n        local op @= self.consume()\n        local isEql = self.peek() == \"=\"\n        if isEql (\n          op ++= self.consume()\n        )\n        \n        local right @= self.factor()\n        \n        expr @= {\n          kind: \"binary\",\n          op,\n          left: expr,\n          right\n        }\n      ) else (\n        end = true\n      )\n    )\n    \n    return expr\n  )\n  \n  def term() (\n    local expr @= self.factor()\n    void self.consumeWhitespace()\n    \n    while [\"+\",\"-\"].contains(self.peek()) and self.peek(2) != \"=\" (\n      local op @= self.consume()\n      local right @= self.factor()\n      expr @= {\n        kind: \"binary\",\n        op,\n        left: expr,\n        right\n      }\n      void self.consumeWhitespace()\n    )\n    \n    return expr\n  )\n  \n  def factor() (\n    local expr @= self.otherBinary()\n    void self.consumeWhitespace()\n    \n    while [\"*\",\"/\"].contains(self.peek()) and self.peek(2) != \"=\" (\n      local op @= self.consume()\n      local right @= self.otherBinary()\n      expr @= {\n        kind: \"binary\",\n        op,\n        left: expr,\n        right\n      }\n      void self.consumeWhitespace()\n    )\n    \n    return expr\n  )\n  \n  def otherBinary() (\n    local expr @= self.coalescence()\n    void self.consumeWhitespace()\n    \n    while [\"%\",\"^\"].contains(self.peek()) and self.peek(2) != \"=\" (\n      local op @= self.consume()\n      local right @= self.coalescence()\n      expr @= {\n        kind: \"binary\",\n        op,\n        left: expr,\n        right\n      }\n      void self.consumeWhitespace()\n    )\n    \n    return expr\n  )\n  \n  def coalescence() (\n    local expr @= self.unary()\n    void self.consumeWhitespace()\n    \n    while self.peek() ++ self.peek(2) == \"??\" and self.peek(3) != \"=\" (\n      local op @= self.consume() ++ self.consume()\n      local right @= self.unary()\n      expr @= {\n        kind: \"binary\",\n        op,\n        left: expr,\n        right\n      }\n      void self.consumeWhitespace()\n    )\n    \n    return expr\n  )\n  \n  def unary() (\n    if self.peek(2) != \"=\" (\n      switch self.peek() (\n        case \"-\"; case \"+\"; case \"!\"; case \"?\"\n          return {\n            kind: \"unary\",\n            type: self.consume(),\n            expr: self.callExpr()\n          }\n      )\n    )\n    \n    return self.callExpr()\n  )\n  \n  def callExpr() (\n    local start @= self.getPos()\n    local expr @= self.func()\n    \n    if self.peek() == \"(\" (\n      void self.consume()\n      \n      local args @= []\n      local end = self.peek() == \")\"\n      while !end (\n        local out @= self.expression()\n        if out != null (\n          void args.append(out)\n        )\n        void self.consumeWhitespace()\n        if self.peek() == \",\" (\n          void self.consume()\n        )\n        void self.consumeWhitespace()\n        if self.peek() == \")\" or self.atEnd() (\n          end = true\n        )\n      )\n      void self.expect(\")\")\n      \n      return {\n        kind: \"call\",\n        args,\n        func: expr,\n        start, end: self.getPos()\n      }\n    )\n    \n    return expr\n  )\n  \n  def func() (\n    local start @= self.getPos()\n    \n    local is = false\n    if self.peek() == \"(\" (\n      local end = false\n      local depth = 0\n      while !end (\n        local tkn @= self.consume()\n        if tkn == \"(\" (\n          depth ++\n        )\n        if tkn == \")\" (\n          depth --\n        )\n        \n        if tkn == \")\" and depth == 0 (\n          end = true\n          is = true\n        )\n        if self.atEnd() (\n          end = true\n        )\n      )\n    )\n    void self.consumeWhitespace()\n    if is and self.peek() == \"~\" (\n      self.pointer = start.i\n      \n      local args @= []\n      void self.consume()\n      void self.consumeWhitespace()\n      local end = self.peek() == \")\"\n      if self.peek() == \")\" (\n        void self.consume()\n      )\n      while !end (\n        local tkn @= self.expectText()\n        void args.append({\n          name: tkn\n        })\n        \n        void self.consumeWhitespace()\n        local ntkn = self.expects([\",\",\")\"])\n        void self.consumeWhitespace()\n        if ntkn == \")\" or self.atEnd() (\n          end = true\n        )\n      )\n      void self.consumeWhitespace()\n      void self.expect(\"~\")\n      void self.consumeWhitespace()\n      local body @= self.statement(true)\n      return {\n        kind: \"func\",\n        args,\n        body,\n        start, end: self.getPos()\n      }\n    )\n    self.pointer = start.i\n    \n    return self.objProperty()\n  )\n  \n  def objProperty() (\n    local expr @= self.primary()\n    void self.consumeWhitespace()\n    \n    while (self.peek() == \"[\" or self.peek() == \".\") and !self.atEnd() (\n      if self.peek() == \"[\" (\n        void self.consume()\n        local key @= self.expression()\n        void self.expect(\"]\")\n      ) else if self.peek() == \".\" (\n        void self.consume()\n        local key @= self.expectText()\n      ) else (\n        throw \"unexpected token '\" ++ self.peek() ++ \"'\"\n      )\n      expr @= {\n        kind: \"prop\",\n        obj: expr,\n        key\n      }\n      if self.peek() == \"(\" (\n        void self.consume()\n        \n        local args @= []\n        local end = self.peek() == \")\"\n        while !end (\n          local out @= self.expression()\n          if out != null (\n            void args.append(out)\n          )\n          void self.consumeWhitespace()\n          if self.peek() == \",\" (\n            void self.consume()\n          )\n          void self.consumeWhitespace()\n          if self.peek() == \")\" or self.atEnd() (\n            end = true\n          )\n        )\n        void self.expect(\")\")\n        \n        expr @= {\n          kind: \"call\",\n          args,\n          func: expr\n        }\n      )\n      void self.consumeWhitespace()\n    )\n    \n    return expr\n  )\n  \n  def primary() (\n    void self.consumeWhitespace()\n    \n    if self.peek() == \"(\" (\n      void self.consume()\n      local expr @= self.expression()\n      void self.expect(\")\")\n      return expr\n    )\n    \n    if self.peek() == \"[\" (\n      return self.arr()\n    )\n    \n    if self.peek() == \"{\" (\n      return self.obj()\n    )\n    \n    if self.peek() == \"#\" (\n      return self.color()\n    )\n    \n    if [\"'\",\"\\\"\",\"`\"].contains(self.peek()) (\n      return self.str()\n    )\n    \n    if self.peek().match(\"/^[0-9]+$/\") != null (\n      return self.num()\n    )\n    \n    if self.peek().match(\"/^[a-zA-Z_\\\\$][\\\\w\\\\s\\\\$]*$/\") != null (\n      local start @= self.getPos()\n      return {\n        kind: \"var\",\n        name: self.consume(),\n        start, end: self.getPos()\n      }\n    )\n    \n    throw \"unexpected token '\" ++ self.peek() ++ \"'\"\n  )\n  \n  def arr() (\n    void self.expect(\"[\")\n    void self.consumeWhitespace()\n    \n    local elems @= []\n    \n    local end = self.peek() == \"]\"\n    while !end (\n      local expr @= self.expression()\n      void elems.append(expr)\n      \n      void self.consumeWhitespace()\n      if self.peek() == \"]\" or self.atEnd() (\n        end = true\n      ) else (\n        void self.expect(\",\")\n      )\n      void self.consumeWhitespace()\n    )\n    \n    void self.expect(\"]\")\n    \n    return {\n      kind: \"arr\",\n      elems\n    }\n  )\n  \n  def obj() (\n    void self.expect(\"{\")\n    void self.consumeWhitespace()\n    \n    local pairs @= []\n    \n    local end = self.peek() == \"}\"\n    while !end (\n      void self.consumeWhitespace()\n      local name @= self.expectText()\n      void self.consumeWhitespace()\n      void self.expect(\":\")\n      void self.consumeWhitespace()\n      local value @= self.expression()\n      \n      void pairs.append({ name, value })\n      \n      void self.consumeWhitespace()\n      if self.peek() == \"}\" (\n        end = true\n      ) else (\n        void self.expect(\",\")\n      )\n    )\n    void self.expect(\"}\")\n    \n    return {\n      kind: \"obj\",\n      pairs\n    }\n  )\n  \n  def color() (\n    local start @= self.getPos()\n    void self.expect(\"#\")\n    local value = self.consume()\n    if ![3,6].contains(value.len) (\n      throw \"hex values can only be 3 or 6 characters long\"\n    )\n    return {\n      kind: \"color\",\n      val: \"#\" ++ value,\n      start, end: self.getPos()\n    }\n  )\n  \n  def str() (\n    local start @= self.getPos()\n    local q @= self.expects([\"'\",\"\\\"\",\"`\"])\n    local content = \"\"\n    local end = false\n    while (!end) (\n      local tkn @= self.peek()\n      if tkn == \"\\\\\" (\n        void self.consume()\n        local tkn = self.consume()\n        local char = tkn[1]\n        switch char (\n          case \"n\"\n            char = \"\\n\"\n            break\n        )\n        content ++= char ++ tkn.trim(2,-1)\n        continue\n      )\n      \n      if q == tkn (\n        end = true\n      ) else (\n        content ++= self.consume()\n      )\n      if self.atEnd() (\n        end = true\n      )\n    )\n    void self.expect(q)\n    return {\n      kind: \"str\",\n      val: content,\n      start, end: self.getPos()\n    }\n  )\n  \n  def num() (\n    if self.peek().match(\"/^[0-9]+$/\") == null (\n      throw \"unexpected token '\" ++ self.peek() ++ \"'\"\n    )\n    \n    local start @= self.getPos()\n    local val @= self.consume()\n    \n    if self.peek() == \".\" (\n      val ++= self.consume()\n      if self.peek().match(\"/^[0-9]+$/\") == null (\n        throw \"unexpected token '\" ++ self.peek() ++ \"'\"\n      )\n      val ++= self.consume()\n    )\n    \n    val @= val.toNum()\n    \n    return {\n      kind: \"num\",\n      val,\n      start, end: self.getPos()\n    }\n  )\n)\n",""],[".osl","error","\nobject Errors = {\n  CannotAssign: def(data) -> (\n    return \"cannot assign to\" + data.kind\n  ),\n\n  // instructions\n  UnknownInstructionKind: def(data) -> (\n    return \"unknown instruction kind:\" + data.kind\n  ),\n  \n  // compiler\n  UnknownStatementKind: def(data) -> (\n    return \"unknown statement kind:\" + data.kind\n  ),\n  UnknownExpressionKind: def(data) -> (\n    return \"unknown expression kind:\" + data.kind\n  )\n}\n\nclass Error (\n  boolean isError = true\n  \n  def init(string type, object data) (\n    self.type = type\n    self.data @= data\n    \n    local err @= rtr.error.Errors[type]\n    if err == null (\n      self.type = \"UnknownErrorType\"\n      self.txt = \"unknown error type\" + type\n      return\n    )\n    self.txt = err(data)\n  )\n  \n  def stringify() (\n    return \"Error<\" ++ self.type ++ \">:\\n\" ++ self.txt.split(\"\\n\").map(l -> \"    \" ++ l).join(\"\\n\")\n  )\n)\n",""],[".osl","value","\nclass RTRValue (\n  def callFunc() (\n    throw \"cannot call\" + self.stringify(true) + \"as function\"\n  )\n\n  def getRtrType() (\n    throw self.name + \"has not implemented getRtrType()\"\n    return rtr.value.RTRTypeValue({\n      name: \"?\"\n    })\n  )\n\n  def stringify() (\n    return \"<\" ++ self.getRtrType().getName() ++ \">\"\n  )\n  def numbify() (\n    return NaN\n  )\n  def boolify() (\n    return true\n  )\n  def arrify() (\n    return []\n  )\n  def length() (\n    return 0\n  )\n  def getItem(key) (\n    return null\n  )\n  def setItem(key, value) (\n    throw \"cannot set items on\" + self.stringify(true)\n  )\n  def keys() (\n    return []\n  )\n  def values() (\n    return []\n  )\n  def has(key) (\n    return false\n  )\n  def isEqual(other) (\n    return self.getRtrType().isEqual(other.getRtrType())\n  )\n)\n\nclass RTRTypeValue (\n  def init(object data) (\n    self.data @= data\n  )\n  \n  def stringify() (\n    return self.getName()\n  )\n  def getName() (\n    if self.data.name != null (\n      return self.data.name\n    )\n    return \"?\"\n  )\n  def isEqual(object other) (\n    return self.data.name == other.data.name\n  )\n)\n\nclass RTRLiteralValue extends RTRValue (\n  boolean isLiteral = true\n)\n\nclass RTRStrValue extends RTRLiteralValue (\n  def init(string value) (\n    self.value @= value\n  )\n  \n  def getRtrType() (\n    return rtr.value.RTRTypeValue({\n      name: \"str\"\n    })\n  )\n  \n  def stringify(format) (\n    return format ? self.value.JsonStringify() self.value\n  )\n  def numbify() (\n    return self.value.toNum()\n  )\n  def boolify() (\n    return self.value.len > 0\n  )\n  def arrify() (\n    return self.value.split(\"\").map(e -> rtr.value.RTRStrValue(e))\n  )\n  def length() (\n    return self.value.len\n  )\n  def getItem(index) (\n    return rtr.value.RTRStrValue(self.value[index.numbify() + 1])\n  )\n  def isEqual(other) (\n    return self.getRtrType().isEqual(other.getRtrType()) and self.value === other.value\n  )\n)\n\nclass RTRNumValue extends RTRLiteralValue (\n  def init(number value) (\n    self.value @= value\n  )\n  \n  def getRtrType() (\n    return rtr.value.RTRTypeValue({\n      name: \"num\"\n    })\n  )\n  \n  def stringify() (\n    return self.value.toStr()\n  )\n  def numbify() (\n    return self.value\n  )\n  def boolify() (\n    return self.value > 0\n  )\n  def arrify() (\n    return self.value.toStr().split(\"\").map(e -> rtr.value.RTRStrValue(e))\n  )\n  def length() (\n    return self.value.toStr().length\n  )\n  def getItem(index) (\n    return self.value.toStr()[index.numbify() + 1]\n  )\n  def isEqual(other) (\n    return self.getRtrType().isEqual(other.getRtrType()) and self.value === other.value\n  )\n)\n\nclass RTRBoolValue extends RTRLiteralValue (\n  def init(boolean value) (\n    self.value @= value\n  )\n  \n  def getRtrType() (\n    return rtr.value.RTRTypeValue({\n      name: \"bool\"\n    })\n  )\n  \n  def stringify() (\n    return self.value.toStr()\n  )\n  def numbify() (\n    return self.value.toNum()\n  )\n  def boolify() (\n    return self.value\n  )\n  def isEqual(other) (\n    return self.getRtrType().isEqual(other.getRtrType()) and self.value === other.value\n  )\n)\n\nclass RTRColorValue extends RTRLiteralValue (\n  def init(string value) (\n    self.value @= value\n  )\n  \n  def getRtrType() (\n    return rtr.value.RTRTypeValue({\n      name: \"color\"\n    })\n  )\n  \n  def stringify() (\n    return self.value.toStr()\n  )\n  def boolify() (\n    return !!self.value\n  )\n  def isEqual(other) (\n    return self.getRtrType().isEqual(other.getRtrType()) and self.value === other.value\n  )\n)\n\nclass RTRFuncValue extends RTRValue (\n  def getRtrType() (\n    return rtr.value.RTRTypeValue({\n      name: \"func\"\n    })\n  )\n)\n\nclass RTROslFuncValue extends RTRFuncValue (\n  def init(func, extra) (\n    self.func @= func\n    self.extra @= extra\n  )\n  \n  def callFunc(object inst, array args) (\n    return self.func(args, inst, extra) ?? rtr.value.RTRNullValue()\n  )\n)\nclass RTRAstFuncValue extends RTRFuncValue (\n  def init(array args, object body) (\n    self.args @= args\n    self.body @= body\n  )\n  \n  def callFunc(object inst, array args) (\n    local s @= {}\n    for i self.args.len (\n      local a @= self.args[i]\n      local v @= args[i] ?? rtr.value.RTRNullValue()\n      s[a.name] @= [v, {}]\n    )\n    \n    void inst.newScope(s)\n    void inst.declScopeVar(\"@return\", 0)\n    \n    local exprOut @= inst.runStatement(self.body)\n    \n    local ret @= inst.getScopeVar(\"@return\") ?? 0\n    if ret == 0 (\n      ret @= exprOut\n    )\n    \n    void inst.popScope()\n    \n    return ret\n  )\n)\nclass RTRBytecodeFuncValue extends RTRFuncValue (\n  def init(array args, array body) (\n    self.args @= args\n    self.body @= body\n  )\n  \n  def callFunc(object inst, array args) (\n    local s @= {}\n    for i self.args.len (\n      local a @= self.args[i]\n      local v @= args[i] ?? rtr.value.RTRNullValue()\n      s[a.name] @= [v, {}]\n    )\n    \n    void inst.newScope(s)\n    \n    local exprOut @= inst.runInstructions(self.body)\n    \n    void inst.popScope()\n    \n    return exprOut\n  )\n)\n\nclass RTRNullValue extends RTRValue (\n  def getRtrType() (\n    return rtr.value.RTRTypeValue({\n      name: \"null\"\n    })\n  )\n  \n  def boolify() (\n    return false\n  )\n  def isEqual(other) (\n    return self.getRtrType().isEqual(other.getRtrType()) and self.value === other.value\n  )\n)\n\nclass RTRArrValue extends RTRValue (\n  def init(array elements) (\n    self.elements @= elements\n  )\n  \n  def getRtrType() (\n    return rtr.value.RTRTypeValue({\n      name: \"arr\"\n    })\n  )\n  \n  def stringify() (\n    local el @= self.elements.map(e -> e.stringify(true))\n    return \"[\" ++ el.join(\", \") ++ \"]\"\n  )\n  def boolify() (\n    return self.elements.len > 0\n  )\n  def arrify() (\n    return self.elements\n  )\n  def length() (\n    return self.elements.len\n  )\n  def keys() (\n    local arr2 @= []\n    for i self.elements.len (\n      void arr2.append(i - 1)\n    )\n    return arr2\n  )\n  def values() (\n    return self.elements\n  )\n  def getItem(index) (\n    return self.elements[index.numbify() + 1]\n  )\n  // setItem\n)\n\nclass RTRObjValue extends RTRValue (\n  def init(object value) (\n    self.value @= value\n  )\n  \n  def getRtrType() (\n    return rtr.value.RTRTypeValue({\n      name: \"obj\"\n    })\n  )\n  \n  def stringify() (\n    local el @= self.value.getEntries().map(e -> e[1] ++ \":\" + e[2].stringify(true))\n    return \"{\" ++ el.join(\", \") ++ \"}\"\n  )\n  def boolify() (\n    return self.value.getKeys().len > 0\n  )\n  def arrify() (\n    return self.value.getKeys().map(e -> rtr.value.RTRStrValue(e))\n  )\n  def length() (\n    return self.value.getKeys().len\n  )\n  def keys() (\n    return self.value.getKeys()\n  )\n  def values() (\n    return self.value.getValues()\n  )\n  def has(key) (\n    return self.value.getKeys().contains(key)\n  )\n  def getItem(key) (\n    return self.value[key.stringify()]\n  )\n  def setItem(key, value) (\n    self.value[key.stringify()] @= value\n  )\n)\n",""],[".osl","compiler","\nlbli = 0\n\ndef getLabelName() (\n  self.lbli ++\n  return self.lbli.toStr()\n)\n\ndef compileBlock(object block) (\n  local instructions @= []\n  //log \"blk\" block\n  for i block.elements.len (\n    local out @= compileStatement(block.elements[i])\n    if typeof(out) != \"array\" and out.isError (\n      return out\n    )\n    \n    instructions ++= out\n  )\n  return instructions\n)\n\ndef compileStatement(object statement) (\n  //log \"stat\" statement\n  switch statement.kind (\n    case \"expression\"\n      local out @= compileExpression(statement.expr)\n      if typeof(out) != \"array\" and out.isError (\n        return out\n      )\n      \n      out += rtr.instruction.pop()\n      return out\n    case \"block\"\n      local body @= compileBlock(statement.body)\n      if typeof(body) != \"array\" and body.isError (\n        return body\n      )\n      \n      local out @= []\n      \n      out += rtr.instruction.newScope()\n      out ++= body\n      out += rtr.instruction.popScope()\n      \n      return out\n    \n    case \"branch\"\n      local out @= []\n      local hasElse = statement.elifs.len > 0 or statement.elseBody != null\n      \n      local endLbl = getLabelName()\n      local elseLbl = hasElse ? getLabelName() endLbl\n      \n      local cond @= compileExpression(statement.cond)\n      if typeof(cond) != \"array\" and cond.isError (\n        return cond\n      )\n      out ++= cond\n      out += rtr.instruction.jumpNotIf(elseLbl)\n      local body @= compileStatement(statement.body)\n      if typeof(body) != \"array\" and body.isError (\n        return body\n      )\n      out ++= body\n      if hasElse (\n        out += rtr.instruction.jump(endLbl)\n      )\n      \n      for i statement.elifs.len (\n        local elif @= statement.elifs[i]\n        local isLast = i == statement.elifs.len and statement.elseBody == null\n        out += rtr.instruction.label(elseLbl)\n        elseLbl = isLast ? endLbl getLabelName()\n        \n        local cond @= compileExpression(elif.cond)\n        if typeof(cond) != \"array\" and cond.isError (\n          return cond\n        )\n        out ++= cond\n        out += rtr.instruction.jumpNotIf(elseLbl)\n        local body @= compileStatement(elif.body)\n        if typeof(body) != \"array\" and body.isError (\n          return body\n        )\n        out ++= body\n        if !(i == statement.elifs.len and statement.elseBody == null) (\n          out += rtr.instruction.jump(endLbl)\n        )\n      )\n      \n      if statement.elseBody != null (\n        out += rtr.instruction.label(elseLbl)\n        local body @= compileStatement(statement.elseBody)\n        if typeof(body) != \"array\" and body.isError (\n          return body\n        )\n        out ++= body\n      )\n      out += rtr.instruction.label(endLbl)\n      return out\n    \n    case \"while\"\n      local out @= []\n      \n      local startLbl @= getLabelName()\n      local endLbl @= getLabelName()\n      \n      out += rtr.instruction.label(startLbl)\n      local cond @= compileExpression(statement.cond)\n      if typeof(cond) != \"array\" and cond.isError (\n        return cond\n      )\n      out ++= cond\n      out += rtr.instruction.jumpNotIf(endLbl)\n      \n      local body @= compileStatement(statement.body)\n      if typeof(body) != \"array\" and body.isError (\n        return body\n      )\n      out ++= body\n      \n      out += rtr.instruction.jump(startLbl)\n      out += rtr.instruction.label(endLbl)\n      return out\n    case \"until\"\n      local out @= []\n      \n      local startLbl @= getLabelName()\n      local endLbl @= getLabelName()\n      \n      out += rtr.instruction.label(startLbl)\n      local cond @= compileExpression(statement.cond)\n      if typeof(cond) != \"array\" and cond.isError (\n        return cond\n      )\n      out ++= cond\n      out += rtr.instruction.jumpIf(endLbl)\n      \n      local body @= compileStatement(statement.body)\n      if typeof(body) != \"array\" and body.isError (\n        return body\n      )\n      out ++= body\n      \n      out += rtr.instruction.jump(startLbl)\n      out += rtr.instruction.label(endLbl)\n      return out\n    case \"repeat\"\n      local out @= []\n      \n      local startLbl @= getLabelName()\n      local endLbl @= getLabelName()\n      \n      out += rtr.instruction.num(1)\n      out += rtr.instruction.label(startLbl)\n      out += rtr.instruction.dupe(-1)\n      local amt @= compileExpression(statement.amount)\n      if typeof(amt) != \"array\" and amt.isError (\n        return amt\n      )\n      out ++= amt\n      out += rtr.instruction.binary(\">\")\n      out += rtr.instruction.jumpIf(endLbl)\n      \n      out ++= compileStatement(statement.body)\n      \n      out += rtr.instruction.num(1)\n      out += rtr.instruction.binary(\"+\")\n      out += rtr.instruction.jump(startLbl)\n      out += rtr.instruction.label(endLbl)\n      out += rtr.instruction.pop()\n      return out\n    case \"for\"\n      local out @= []\n      \n      local startLbl @= getLabelName()\n      local endLbl @= getLabelName()\n      local arr @= compileExpression(statement.arr)\n      if typeof(arr) != \"array\" and arr.isError (\n        return arr\n      )\n      out ++= arr\n      out += rtr.instruction.num(0)\n      out += rtr.instruction.label(startLbl)\n      out += rtr.instruction.dupe(-2)\n      out += rtr.instruction.len()\n      out += rtr.instruction.dupe(-2)\n      out += rtr.instruction.binary(\"<=\")\n      out += rtr.instruction.jumpIf(endLbl)\n      out += rtr.instruction.dupe(-2)\n      out += rtr.instruction.dupe(-2)\n      out += rtr.instruction.prop()\n      out += rtr.instruction.newScope()\n      out += rtr.instruction.decl(statement.var)\n      out += rtr.instruction.pop()\n      \n      out ++= compileStatement(statement.body)\n      \n      out += rtr.instruction.popScope()\n      out += rtr.instruction.num(1)\n      out += rtr.instruction.binary(\"+\")\n      out += rtr.instruction.jump(startLbl)\n      out += rtr.instruction.label(endLbl)\n      out += rtr.instruction.pop()\n      out += rtr.instruction.pop()\n      return out\n    \n    default\n      return rtr.error.Error(\"UnknownStatementKind\", { kind: statement.kind })\n  )\n  \n  return []\n)\n\ndef compileExpression(object expression) (\n  //log \"expr\" expression\n  switch expression.kind (\n    case \"call\"\n      local func @= compileExpression(expression.func)\n      if typeof(func) != \"array\" and func.isError (\n        return func\n      )\n      \n      local args @= []\n      for i expression.args.len (\n        local out @= compileExpression(expression.args[i])\n        if typeof(out) != \"array\" and out.isError (\n          return out\n        )\n        \n        args ++= out\n      )\n      local out @= []\n      out ++= func\n      out ++= args\n      out += rtr.instruction.callOp(expression.args.len)\n      return out\n    case \"decl\"\n      local val @= compileExpression(expression.val)\n      if typeof(val) != \"array\" and val.isError (\n        return val\n      )\n      \n      local out @= val\n      out += rtr.instruction.decl(expression.tar)\n      return out\n    case \"asi\"\n      local val @= compileExpression(expression.val)\n      if typeof(val) != \"array\" and val.isError (\n        return val\n      )\n      local out @= val\n      switch expression.tar.kind (\n        case \"var\"\n          void out.append(rtr.instruction.asivar(expression.tar.name, expression.op))\n          return out\n        case \"prop\"\n          out ++= compileExpression(expression.tar.obj)\n          if typeof(expression.tar.key) == \"string\" (\n            out += rtr.instruction.str(expression.tar.key)\n          ) else (\n            out ++= compileExpression(expression.tar.key)\n          )\n          void out.append(rtr.instruction.asiprop(expression.op))\n          return out\n      )\n      \n      return [rtr.instruction.null()]\n    case \"unary\"\n      local val @= compileExpression(expression.expr)\n      \n      local out @= []\n      out ++= val\n      out += rtr.instruction.unary(expression.type)\n      \n      return out\n    case \"binary\"\n      local left @= compileExpression(expression.left)\n      if typeof(left) != \"array\" and left.isError (\n        return left\n      )\n      local right @= compileExpression(expression.right)\n      if typeof(right) != \"array\" and right.isError (\n        return right\n      )\n      \n      local out @= []\n      out ++= left\n      out ++= right\n      out += rtr.instruction.binary(expression.op)\n      \n      return out\n    case \"var\"\n      if [\"true\",\"false\"].contains(expression.name) (\n        return [rtr.instruction.bool(expression.name == \"true\")]\n      )\n      return [rtr.instruction.get(expression.name)]\n    case \"prop\"\n      local out @= []\n      out ++= compileExpression(expression.obj)\n      if typeof(expression.key) == \"string\" (\n        out += rtr.instruction.str(expression.key)\n      ) else (\n        out ++= compileExpression(expression.key)\n      )\n      out += rtr.instruction.prop()\n      return out\n    \n    case \"str\"\n      return [rtr.instruction.str(expression.val)]\n    case \"num\"\n      return [rtr.instruction.num(expression.val)]\n    case \"func\"\n      return [rtr.instruction.func(compileStatement(expression.body), expression.args)]\n    case \"arr\"\n      local out @= []\n      for i expression.elems.len (\n        out ++= compileExpression(expression.elems[i])\n      )\n      out += rtr.instruction.arr(expression.elems.len)\n      return out\n    case \"obj\"\n      local out @= []\n      local keys @= []\n      for i expression.pairs.len (\n        out ++= compileExpression(expression.pairs[i].value)\n        void keys.append(expression.pairs[i].name)\n      )\n      out += rtr.instruction.obj(keys)\n      return out\n    case \"color\"\n      return [rtr.instruction.color(expression.val)]\n    \n    default\n      log expression\n      return rtr.error.Error(\"UnknownExpressionKind\", { kind: expression.kind })\n  )\n  \n  return [rtr.instruction.null()]\n)\n",""],[".osl","instruction","\n// program flow\ndef label(string name) (\n  return { kind: \"label\", name }\n)\ndef jump(string label) (\n  return { kind: \"jump\", label }\n)\ndef jumpIf(string label) (\n  return { kind: \"jumpIf\", label }\n)\ndef jumpNotIf(string label) (\n  return { kind: \"jumpNotIf\", label }\n)\n\n// operations\ndef callOp(number amount) (\n  return { kind: \"call\", args: amount }\n)\ndef unary(string op) (\n  return { kind: \"unary\", op }\n)\ndef binary(string op) (\n  return { kind: \"binary\", op }\n)\ndef prop() (\n  return { kind: \"prop\" }\n)\ndef len() (\n  return { kind: \"len\" }\n)\n\n// values\ndef null() (\n  return { kind: \"null\" }\n)\ndef str(string data) (\n  return { kind: \"str\", data }\n)\ndef num(number data) (\n  return { kind: \"num\", data }\n)\ndef bool(boolean data) (\n  return { kind: \"bool\", data }\n)\ndef func(array body, array args) (\n  return { kind: \"func\", body, args }\n)\ndef arr(number elems) (\n  return { kind: \"arr\", elems }\n)\ndef obj(array keys) (\n  return { kind: \"obj\", keys }\n)\ndef color(string data) (\n  return { kind: \"color\", data }\n)\n\n// scope\ndef get(string name) (\n  return { kind: \"get\", name }\n)\ndef decl(string name) (\n  return { kind: \"decl\", name }\n)\ndef newScope() (\n  return { kind: \"newScope\" }\n)\ndef popScope() (\n  return { kind: \"popScope\" }\n)\n\n// assignments\ndef asivar(string name, op) (\n  return { kind: \"asivar\", name, op }\n)\ndef asiprop(op) (\n  return { kind: \"asiprop\", op }\n)\n\n// stack\ndef pop() (\n  return { kind: \"pop\" }\n)\ndef dupe(number i) (\n  return { kind: \"dupe\", i }\n)\n",""],[".folder","apis",[[".osl","rwl","\nclass RTRDocument extends rtr.value.RTRValue (\n  def init(object doc) (\n    self.doc @= doc\n  )\n\n  def getRtrType() (\n    return rtr.value.RTRTypeValue({\n      name: \"document\"\n    })\n  )\n  \n  def getItem(key) (\n    switch key.stringify() (\n      // values\n      case \"title\"\n        return rtr.value.RTRStrValue(self.doc.title)\n      case \"icon\"\n        if self.doc.icon == null (\n          return rtr.value.RTRNullValue()\n        )\n        return rtr.value.RTRStrValue(self.doc.icon)\n      case \"root\"\n        local elems @= self.doc.rwlInst.elements\n        for i elems.len (\n          local elem @= elems[i]\n          if elem.name == \"RWLRoot\" (\n            return rtr.apis.rwl.RTRElement(elem)\n          )\n        )\n        return rtr.value.RTRNullValue()\n      \n      // methods\n      case \"redirect\"\n        return rtr.value.RTROslFuncValue(def(args, _inst, doc) -> (\n          void doc.doc.loadUrl(shared.url.Url(args[1].stringify()))\n          void layouts.shared.state.updateTab()\n        ), self)\n      case \"getElement\"\n        return rtr.value.RTROslFuncValue(def(args, _inst, doc) -> (\n          local elem @= doc.doc.rwlInst.getElement(args[1].stringify())\n          if elem == null (\n            return rtr.value.RTRNullValue()\n          )\n          return rtr.apis.rwl.RTRElement(elem)\n        ), self)\n      case \"createTextElement\"\n        return rtr.value.RTROslFuncValue(def(args, _inst) -> (\n          return rtr.apis.rwl.RTRElement(rwl.main.RWLElement(rtr.apis.rwl.rtrValueToRwlValue(args[1]), { flags: [], pairs: [] }))\n        ))\n      case \"createScript\"\n        return rtr.value.RTROslFuncValue(def(args, _inst, doc) -> (\n          local elem @= rwl.main.RWLScript(args[1].stringify(), { flags: [], pairs: [] }, doc.doc.rwlInst)\n          void rtr.apis.main.addToMod(doc.doc, elem.mod)\n          void elem.start()\n          return rtr.apis.rwl.RTRElement(elem)\n        ), self)\n      case \"createContainer\"\n        return rtr.value.RTROslFuncValue(def(args, _inst) -> (\n          local kind = args[1].stringify()\n          switch kind (\n            case \"frame\"\n              return rtr.apis.rwl.RTRElement(rwl.main.RWLFrame([], { flags: [], pairs: [] }))\n            case \"section\"\n              return rtr.apis.rwl.RTRElement(rwl.main.RWLSection([], { flags: [], pairs: [] }))\n            case \"button\"\n              return rtr.apis.rwl.RTRElement(rwl.main.RWLButton([], { flags: [], pairs: [] }))\n            \n            default\n              throw \"unknown container type\" + kind\n          )\n          return rtr.apis.rwl.RTRElement(rwl.main.RWLElement(rtr.apis.rwl.rtrValueToRwlValue(args[1]), { flags: [], pairs: [] }))\n        ))\n      \n      default\n        throw \"unknown property\" + key.stringify() + \"on document\"\n    )\n  )\n  \n  def setItem(key, value) (\n    switch key.stringify() (\n      case \"title\"\n        self.doc.title = value.stringify()\n        break\n      case \"icon\"\n        self.doc.icon = value.stringify()\n        break\n      default\n        throw \"cannot set property\" + key.stringify() + \"on document\"\n    )\n  )\n)\n\nclass RTRElement extends rtr.value.RTRValue (\n  isRwlElem = true\n  \n  def init(object elem) (\n    self.elem @= elem\n  )\n\n  def getRtrType() (\n    return rtr.value.RTRTypeValue({\n      name: \"element\"\n    })\n  )\n  \n  def stringify() (\n    local txt = (self.elem.blockName ?? self.elem.kind).toStr()\n    if self.elem.id != null (\n      txt ++= \":\" ++ self.elem.id\n    )\n    return \"<\" ++ txt ++ \">\"\n  )\n  \n  def getItem(key) (\n    local k = key.stringify()\n    \n    switch k (\n      case \"toggleFlag\"\n        return rtr.value.RTROslFuncValue(def(args, _inst, elem) -> (\n          local flags @= elem.elem.header.flags\n          local name = args[1].stringify()\n          \n          if flags.contains(name) (\n            void flags.delete(flags.index(name))\n          ) else (\n            void flags.append(name)\n          )\n          \n          elem.elem.needsUpdate = true\n          void elem.elem.checkUpdate()\n        ), self)\n      case \"addFlag\"\n        return rtr.value.RTROslFuncValue(def(args, _inst, elem) -> (\n          local flags @= elem.elem.header.flags\n          local name = args[1].stringify()\n          \n          if !flags.contains(name) (\n            void flags.append(name)\n          )\n          \n          elem.elem.needsUpdate = true\n          void elem.elem.checkUpdate()\n        ), self)\n      case \"removeFlag\"\n        return rtr.value.RTROslFuncValue(def(args, _inst, elem) -> (\n          local flags @= elem.elem.header.flags\n          local name = args[1].stringify()\n          \n          if flags.contains(name) (\n            void flags.delete(flags.index(name))\n          )\n          \n          elem.elem.needsUpdate = true\n          void elem.elem.checkUpdate()\n        ), self)\n      case \"hasFlag\"\n        return rtr.value.RTROslFuncValue(def(args, _inst, elem) -> (\n          local flags @= elem.elem.header.flags\n          local name = args[1].stringify()\n          \n          return rtr.value.RTRBoolValue(flags.contains(name))\n        ), self)\n      \n      case \"addChild\"\n        return rtr.value.RTROslFuncValue(def(args, _inst, elem) -> (\n          if elem.elem.children == null (\n            throw elem.kind + \"cannot contain children\"\n          )\n          if !args[1].isRwlElem (\n            throw \"argument is not rwl element\"\n          )\n          void elem.elem.children.append(args[1].elem)\n          \n          void elem.elem.updateParentFromCache()\n        ), self)\n      case \"popChild\"\n        return rtr.value.RTROslFuncValue(def(args, _inst, elem) -> (\n          if elem.elem.children == null (\n            throw elem.kind + \"doesnt contain children\"\n          )\n          local idx = args.len > 0 ? args[1].numbify() 1\n          local out @= elem.elem.children[idx]\n          if out != null (\n            out @= rtr.apis.rwl.RTRElement(out)\n          ) else (\n            out @= rtr.value.RTRNullValue()\n          )\n          void elem.elem.children.delete(idx)\n          \n          void elem.elem.updateParentFromCache()\n          return out\n        ), self)\n    )\n    \n    for i self.elem.header.pairs.len (\n      local pair @= self.elem.header.pairs[i]\n      if pair[1] == k (\n        return rtr.apis.rwl.rwlValueToRtrValue(pair[2])\n      )\n    )\n    return rtr.value.RTRNullValue()\n  )\n  \n  def setItem(key, value) (\n    local k = key.stringify()\n    local v @= rtr.apis.rwl.rtrValueToRwlValue(value)\n    \n    if k == \"text\" and self.elem.name == \"RWLElement\" (\n      self.elem.value @= v\n      void self.elem.updateFromCache()\n      return\n    )\n    \n    for i self.elem.header.pairs.len (\n      local pair @= self.elem.header.pairs[i]\n      if pair[1] == k (\n        pair[2] @= v\n        void self.elem.updateParentFromCache()\n        return\n      )\n    )\n    \n    void self.elem.header.pairs.append([\n      k, v\n    ])\n    \n    void self.elem.updateParentFromCache()\n  )\n)\n\ndef rwlValueToRtrValue(object val) (\n  switch val.type (\n    case \"str\"\n      return rtr.value.RTRStrValue(val.value)\n    case \"num\"\n      return rtr.value.RTRNumValue(val.value)\n    // percentage\n    // color\n  )\n  \n  return rtr.value.RTRNullValue()\n)\n\ndef rtrValueToRwlValue(object val) (\n  local type @= val.getRtrType()\n  \n  switch type.data.name (\n    case \"str\"\n      return rwl.value.RWLStrValue(val.value)\n    case \"num\"\n      return rwl.value.RWLNumValue(val.value)\n    case \"color\"\n      return rwl.value.RWLColorValue(val.value)\n  )\n  \n  throw \"cannot set\" + type.stringify() + \"as rwl property\"\n)\n\n// applies rwl related apis to rtr\ndef addToMod(object doc, object mod) (\n  void mod.declScopeVar(\"document\", RTRDocument(doc))\n  void mod.declScopeVar(\"theme\", rtr.value.RTRObjValue({\n    back: rtr.value.RTRColorValue(shared.theme.back),\n    prim: rtr.value.RTRColorValue(shared.theme.prim),\n    seco: rtr.value.RTRColorValue(shared.theme.seco),\n    tert: rtr.value.RTRColorValue(shared.theme.tert),\n    text: rtr.value.RTRColorValue(shared.theme.text),\n    accent: rtr.value.RTRColorValue(shared.theme.accent),\n  }))\n)\n",""],[".osl","main","\n// applies apis to rtr\ndef addToInst(object doc, object rtrInst) (\n  local mods @= rtrInst.modules.getValues()\n  for i mods.len (\n    addToMod(doc, mods[i])\n  )\n)\n\ndef addToMod(object doc, object mod) (\n  void rtr.apis.rwl.addToMod(doc, mod)\n  void rtr.apis.browser.addToMod(doc, mod)\n)\n",""],[".osl","browser","\ndef addToMod(object doc, object mod) (\n  void mod.declScopeVar(\"$$brwsr\", rtr.value.RTRObjValue({\n    settings: rtr.value.RTRObjValue({\n      getCategories: rtr.value.RTROslFuncValue(def() -> (\n        return rtr.value.RTRArrValue(shared.settings.entries.getKeys().map(c -> rtr.value.RTRStrValue(c)))\n      )),\n      getCategory: rtr.value.RTROslFuncValue(def() -> (\n      \n      ))\n    })\n  }))\n)",""]],"c #6e6410 square 0 2 10 4 c #dbc714 square -8 6 2 2 line -5 7 3 0 square 0 -1 10 5 w 8 square 0 -0.5 5 0"]],"c #334859 square 0 2 10 4 c #42A5F5 square -8 6 2 2 line -5 7 3 0 square 0 -1 10 5 w 8 square 0 -0.5 5 0"],[".folder","shared",[[".osl","graphics","\n_canvasID = null\n_canvas = null\n\ndef init() (\n  if shared.config.browser.phosphorus.useCanvas (\n    self._canvasID = OuidNew()\n    self._canvas @= shared.canvas.createCanvas(self._canvasID, window.width, window.height)\n    log self\n  )\n)\n\n// cursor\ncursor_x = 0\ncursor_y = 0\ndef goto(number x, number y) (\n  self.cursor_x = x\n  self.cursor_y = y\n)\n\ndef change_x(number x) (\n  self.cursor_x += x\n)\ndef change_y(number y) (\n  self.cursor_y += y\n)\ndef change(number x, number y) (\n  self.cursor_x += x\n  self.cursor_y += y\n)\n\n// utils\ndef getTextWidth(string text) (\n  return text.len\n)\n\n// rendering\ndef box(array area, string color) (\n  c color\n  pen \"size\" 1\n  goto area[1] area[2]\n  pen \"down\"\n  goto area[3] area[2]\n  goto area[3] area[4]\n  goto area[1] area[4]\n  goto area[1] area[2]\n  pen \"up\"\n)\n\ndef filledBox(array area, rounding, string color) (\n  local x = rwl.area.centerX(area)\n  local y = rwl.area.centerY(area)\n  local w = rwl.area.width(area)\n  local h = rwl.area.height(area)\n  \n  if typeof(rounding) == \"number\" (\n    rounding @= [rounding,rounding,rounding,rounding]\n  )\n  \n  c color\n  \n  if typeof(rounding) == \"number\" (\n    goto x y\n    frame area[1] area[4] area[3] area[2] (\n      local r = max(rounding * 2 - 10, 0)\n      square w - r h - r r\n    )\n  ) else if typeof(rounding) == \"array\" (\n    // could rework this to have it be corner - rounding for pos\n    // so it would have higher parity with canvas?\n    x = round(x)\n    y = round(y)\n    local hw = w / 2\n    local hh = h / 2\n    goto x y\n    //local r = min(rounding[1] * 2, min(w, h) / 2)\n    frame area[1] y x area[2] (\n      local r = max(rounding[1] * 2, 0)\n      goto frame.left + hw frame.bottom + hh\n      square frame.width * 2 - r frame.height * 2 - r r\n    )\n    frame x y area[3] area[2] (\n      local r = max(rounding[2] * 2, 0)\n      goto frame.right - hw frame.bottom + hh\n      square frame.width * 2 - r frame.height * 2 - r r\n    )\n    frame area[1] area[4] x y (\n      local r = max(rounding[3] * 2, 0)\n      goto frame.left + hw frame.top - hh\n      square frame.width * 2 - r frame.height * 2 - r r\n    )\n    frame x area[4] area[3] y (\n      local r = max(rounding[4] * 2, 0)\n      goto frame.right - hw frame.top - hh\n      square frame.width * 2 - r frame.height * 2 - r r\n    )\n  )\n)\n\ndef filledTransparentArea(array area, string color, number opacity) (\n  frame area[1] area[4] area[3] area[2] (\n    c color\n    pen \"opacity\" opacity\n    pen \"size\" 9999\n    goto 0 0\n    pen \"down\"\n    pen \"up\"\n  )\n)\n\ndef ctext(string text, number size, string color) (\n  void ptext(text, self.cursor_x, self.cursor_y, size, color)\n)\ndef ptext(string text, number x, number y, number size, string color) (\n  goto x y\n  text text size : c#color\n)\n\ndef cicon(string src, number size, string color) (\n  void picon(text, self.cursor_x, self.cursor_y, size, color)\n)\ndef picon(string src, number x, number y, number size, string color) (\n  goto x y\n  icon src size : c#color\n)\n",""],[".osl","utils","\ndef removeIndents(str) (\n  local lines @= str.split(\"\\n\")\n  local indent = null\n  for i lines.len (\n    local l2 = lines[i].match(\"/^( *)(.+)$/\")\n    if l2[2].len > 0 (\n      indent = min(indent ?? 9999, l2[2].len)\n    )\n  )\n  for i lines.len (\n    lines[i] = lines[i].trim(indent + 1, -1)\n  )\n  return lines.join(\"\\n\")\n)\n\ndef jsFunc(string js) (\n  local f @= js.eval()\n  local f2 @= () -> ()\n  f2.code @= f\n  return f2\n)\n",""],[".osl","document","\nclass Document (\n  def init() (\n    void self.createInsts()\n    \n    self.started = false\n    self.shouldBeAlive = false\n    self.focused = false\n  )\n  \n  def close() (\n    void self.killWorker()\n  )\n  \n  def createWorker() (\n    //log \"create worker\"\n    void self.killWorker()\n    self.worker @= worker(shared.tab_worker)\n    self.worker.document @= self\n    self.shouldBeAlive = true\n  )\n  \n  def killWorker() (\n    if self.worker != null (\n      //log \"kill worker\"\n      if self.worker.kill == null (\n        return\n      )\n      void self.worker.kill()\n      self.worker = null\n      self.shouldBeAlive = false\n    )\n  )\n  \n  def createInsts() (\n    self.title = \"New Tab\"\n    if self.url != null (\n      self.title = self.url.getTitle()\n    )\n    self.icon = null\n    \n    self.rtrInst @= rtr.main.RTR()\n    self.rwlInst @= rwl.main.RWL(shared.document.empty, self.rtrInst)\n  )\n  \n  def updateInsts() (\n    // inject apis\n    void rtr.apis.main.addToInst(self, self.rtrInst)\n  )\n  \n  def update(array area) (\n    void self.rwlInst.update(area)\n  )\n  \n  def rtrUpdate() (\n    if !self.started and self.rwlInst.hasUpdated (\n      void self.rtrInst.startModules()\n      self.started = true\n    )\n  )\n  \n  def render(array area) (\n    if self.worker != null (\n      self.worker.area @= area\n      if !self.worker.alive and self.shouldBeAlive (\n        //void self.createWorker()\n        //self.rwlInst.errored = true\n        //self.rwlInst.errormsg = \"tab worker died, check js console\"\n      )\n    )\n    \n    goto rwl.area.centerX(area) rwl.area.centerY(area)\n    square rwl.area.width(area) - 10 rwl.area.height(area) - 10 10 : c#shared.theme.back\n    \n    if self.loading (\n      goto rwl.area.centerX(area) rwl.area.centerY(area)\n      direction timer * 720\n      icon \"sync\" .75 : c#shared.theme.text\n      direction 90\n      return\n    )\n    \n    //log self.rwlInst\n    void self.rwlInst.render(area)\n  )\n  \n  def checkResp() (\n    if self.resp == null (\n      self.loading = false\n      return\n    )\n    \n    if self.resp.isFinished (\n      if self.resp.isValid (\n        self.loading = false\n        \n        void self.createInsts()\n        void self.loadText(self.resp.content)\n        \n        self.resp = null\n      )\n    ) else (\n      self.loading = true\n      void self.resp.update()\n    )\n  )\n  \n  def loadAst(object ast) (\n    void self.createInsts()\n    void self.rwlInst.loadFromAst(ast)\n    void self.updateInsts()\n    self.started = false\n  )\n  \n  def loadText(string text) (\n    void self.createWorker()\n    self.worker.parseText = text\n  )\n  \n  def loadUrl(object url) (\n    self.url @= url\n    void self.createInsts()\n    self.resp @= net.fetch.url(url)\n  )\n  \n  def getIcon() (\n    return self.icon\n  )\n  def getTitle() (\n    return self.title\n  )\n)\n\ndef init() (\n  local parser @= rwl.ast.Parser(import(\"./src/assets/empty.rwl\"))\n  self.empty @= parser.parse()\n)\n",""],[".osl","tab","\nclass Tab (\n  def init(object document) (\n    self.document @= document\n  )\n  \n  def redirect(object url) (\n    void self.document.loadUrl(url)\n    void layouts.shared.state.updateTab()\n  )\n)\n",""],[".osl","url","\nclass Url (\n  def init(string text) (\n    void self.parse(text)\n  )\n  \n  def parse(string text) (\n    self.text = text\n    local s @= text.match(\"/^((\\\\w+):\\\\/\\\\/)/\")\n    local match @= text.match(\"/^((\\\\w+):\\\\/\\\\/)?(((\\\\w+)\\\\.)?(\\\\w+)(\\\\.(\\\\w+))?\\\\/?(([\\\\/w]+)?(\\\\/(\\\\w+\\\\.\\\\w+))?))\\\\/?/\")\n    \n    self.scheme = match[3] ?? s[3] ?? shared.config.url.defaults.scheme\n    \n    if self.scheme == \"local\" (\n      self.domain_name = text.trim(\"local://\".len + 1, -1)\n      local usrPath = \"origin/(c) users/\" ++ username\n      if self.domain_name.toLower().startsWith(usrPath.toLower()) (\n        self.domain_name = \"~\" ++ self.domain_name.trim(usrPath.len + 1, -1)\n      )\n      self.domain_top = null\n      self.domain_sub = null\n      self.path = null\n      self.params @= {}\n      self.resource = null\n      self.text = \"local://\" ++ self.domain_name\n      return\n    )\n    \n    if match[9] != null (\n      local domain_name = match[7]\n      local domain_top = match[9]\n      local domain_sub = match[6]\n    ) else (\n      if match[6] != null (\n        local domain_name = match[6]\n        local domain_top = match[7]\n        local domain_sub = null\n      ) else (\n        local domain_name = match[7]\n        local domain_top = null\n        local domain_sub = null\n      )\n    )\n    \n    self.domain_name = domain_name ?? shared.config.url.defaults.name\n    self.domain_top = domain_top ?? shared.config.url.defaults.top\n    self.domain_sub = domain_sub\n    self.path = match[13]\n    self.params @= {}\n    self.resource = match[10] ?? \"index.rwl\"\n    \n    if self.scheme == shared.config.url.browser_scheme (\n      self.domain_top = null\n    )\n  )\n  \n  def format() (\n    if self.scheme == \"local\" (\n      return self.text\n    )\n    local sub = self.domain_sub != null ? self.domain_sub ++ \".\" \"\"\n    local top = self.domain_top != null ? \".\" ++ self.domain_top \"\"\n    local txt = self.scheme ++ \"://\" ++ sub ++ domain_name ++ top\n    if self.path != null (\n      txt ++= \"/\" ++ self.path\n    )\n    if self.resource != \"index.rwl\" (\n      txt ++= \"/\" ++ self.resource\n    )\n    return txt\n  )\n  \n  def getTitle() (\n    if self.scheme == \"local\" (\n      return self.domain_name.split(\"/\")[-1].split(\".\")[1]\n    )\n    return self.domain_name\n  )\n)\n",""],[".osl","theme","\ndef load() (\n  self.back = user.theme.background\n  self.prim = user.theme.primary\n  self.seco = user.theme.secondary\n  self.tert = user.theme.tertiary\n  self.text = user.theme.text\n  self.accent = global_accent\n)\n\nload()\n",""],[".osl","config","\nclass net (\n  servers = {\n    rtr: {\n      url: \"https://web.rotur.dev/\",\n      \n      // <server>/<command>\n      commands: {\n        tlds: \"tlds\"\n      }\n    }\n  }\n  \n  def refresh() (\n    if shared.settings.get(\"net\", \"offline\") (\n      self.servers @= []\n    )\n    \n    for i self.servers.len (\n      local s @= self.servers.getValues()[i]\n      s.tlds @= (s.url ++ s.commands.tlds).httpGet()\n    )\n  )\n)\n\nclass url (\n  string browser_scheme = build.package.phosphorus.browser_scheme ?? \"phos\"\n  \n  class defaults (\n    string scheme = \"rtr\"\n    string name = \"unknown\"\n    string top = \"web\"\n  )\n)\n\nclass browser (\n  string name = build.package.name ?? \"phosphorus\"\n  array developers = build.package.developers ?? [\"flufi\"]\n  string version = build.package.version ?? \"1.0.0a\"\n  \n  // browserName@developer\n  string save_developer = build.package.save_developer ?? \"rotur\"\n  \n  class phosphorus (\n    string version = \"1.0.0a\"\n    \n    boolean useCanvas = false\n    boolean useCompiler = true\n  )\n)\n",""],[".osl","tab_worker","\ndef oncreate() (\n  self.ouid = OuidNew()\n)\n\ndef onframe() (\n  if self.parseText != null (\n    local parser @= rwl.ast.Parser(self.parseText)\n    if self != null (\n      //log self\n      void self.document.loadAst(parser.parse())\n      self.parseText = null\n    )\n  )\n  if self.document != null and self.document.focused (\n    void self.document.rwlInst.interactUpdate({\n      rtr: self.document.rtrInst\n    })\n    void self.document.rtrUpdate()\n    //void self.document.rwlInst.checkElemUpdate()\n    local mods @= self.document.rtrInst.modules.getValues()\n    for i mods.len (\n      void mods[i].runEventQueue()\n    )\n    void shared.input.reset()\n  )\n)\n",""],[".osl","input","\nboolean rwlLeftClick = false\n\ndef reset() (\n  self.rwlLeftClick = false\n)\n\ndef update() (\n  self.leftClick = mouse_left and !self.leftDown\n  self.leftDown = mouse_left\n  if self.leftClick (\n    self.rwlLeftClick = true\n  )\n  \n  // TODO: make a keybind system?\n  if \"`\".onKeyDown() (\n    void shared.settings.set(\"devtools\", \"open\", !shared.settings.get(\"devtools\", \"open\"))\n    //devtools.main.open = !devtools.main.open\n  )\n)\n",""],[".osl","settings","\nobject entries = {\n  devtools: {\n    dockside: {\n      type: \"string\",\n      desc: \"what side devtools is anchored to\",\n      default: \"r\",\n      applySetting: def(string value) -> (\n        devtools.main.anchor = value\n      )\n    },\n    open: {\n      type: \"boolean\",\n      desc: \"if devtools is open or not\",\n      default: false,\n      applySetting: def(boolean value) -> (\n        devtools.main.open = value\n      )\n    },\n    menu: {\n      type: \"string\",\n      desc: \"current open devtools menu\",\n      default: \"console\",\n      applySetting: def(string value) -> (\n        devtools.main.menu = value\n      )\n    }\n  },\n  net: {\n    offline: {\n      type: \"boolean\",\n      desc: \"disables networking\",\n      default: false\n    }\n  }\n}\n\nobject _data = {}\n\ndef load() (\n  local br @= shared.config.browser\n  void shared.save.setName(br.name ++ \"@\" ++ br.save_developer)\n  if !shared.save.exists(\"settings.json\") (\n    void self.write()\n  )\n  self._data @= self.deserialize(shared.save.get(\"settings.json\"))\n  void self.applySettings()\n  void self.write()\n)\n\ndef write() (\n  void shared.save.set(\"settings.json\", self.serialize())\n)\n\ndef get(string category, string entry) (\n  return self._data[category][entry]\n)\ndef set(string category, string entry, value) (\n  local entryData @= self.entries[category][entry]\n  if entryData == null (\n    throw \"setting\" + category ++ \"/\" ++ entry + \"doesnt exist\"\n  )\n  \n  if entryData.type != typeof(value) (\n    throw \"expected\" + entry.type + \"for\" + category ++ \"/\" ++ entry + \"but got\" + typeof(value)\n  )\n  self._data[category][entry] @= value\n  void self.write()\n  void self.applySettings()\n)\n\ndef applySettings() (\n  local categoryData @= self.entries.getEntries()\n  for categoryI categoryData.len (\n    local category @= categoryData[categoryI]\n    local entryData @= category[2].getEntries()\n    for entryI entryData.len (\n      local entry @= entryData[entryI]\n      local value = self._data[category[1]][entry[1]] ?? entry[2].default\n      if entry[2].applySetting != null (\n        void entry[2].applySetting(value)\n      )\n    )\n  )\n)\n\ndef serialize() (\n  local out @= {}\n  local categoryData @= self.entries.getEntries()\n  for categoryI categoryData.len (\n    local category @= categoryData[categoryI]\n    out[category[1]] @= {}\n    local entryData @= category[2].getEntries()\n    for entryI entryData.len (\n      local entry @= entryData[entryI]\n      local value = self._data[category[1]][entry[1]] ?? entry[2].default\n      out[category[1]][entry[1]] @= value\n    )\n  )\n  return out.JsonStringify()\n)\ndef deserialize(string data) (\n  local raw @= data.JsonParse()\n  \n  local out @= {}\n  local categoryData @= self.entries.getEntries()\n  for categoryI categoryData.len (\n    local category @= categoryData[categoryI]\n    out[category[1]] @= {}\n    local entryData @= category[2].getEntries()\n    for entryI entryData.len (\n      local entry @= entryData[entryI]\n      local value = raw[category[1]][entry[1]] ?? entry[2].default\n      out[category[1]][entry[1]] @= value\n    )\n  )\n  return out\n)\n",""],[".osl","save","\ndef setName(string name) (\n  save name \"set_directory\"\n)\n\ndef exists(string fileName) (\n  return fileName.saveExists()\n)\n\ndef get(string fileName) (\n  if !self.exists(fileName) (\n    throw fileName ++ \"does not exist\"\n  )\n\n  return fileName.saveGet().toStr()\n)\n\ndef set(string fileName, string data) (\n  save fileName \"set\" data\n)\n",""]],"c #295c2c square 0 2 10 4 c #4CAF50 square -8 6 2 2 line -5 7 3 0 square 0 -1 10 5 w 8 square 0 -0.5 5 0"],[".folder","layouts",[[".folder","shared",[[".osl","utils","\ndef getContentArea() (\n  return [\n    window.left,\n    window.bottom,\n    window.right,\n    window.top - 50\n  ]\n)\n",""],[".osl","topbar","\narray defaultButtons = [\n  {\n    icon: \"close\",\n    click: window.close\n  },\n  {\n    icon: \"down\",\n    click: window.minimise\n  },\n  {\n    icon: \"maximise\",\n    click: window.fullscreen\n  }\n]\n\ndef winButtons(array buttons, boolean background) (\n  if background (\n    local w = buttons.len * 25\n    \n    loc -2 2 w / -2 - 7.5 -20\n    square w - 5 18 10 : c#shared.theme.prim\n  )\n  \n  loc -2 2 -20 -20\n  change_x 25\n  for i buttons.len (\n    local button @= buttons[i]\n    \n    c shared.theme.text\n    icon button.icon 0.6 * (button.icon_size ?? 1) : hover_size#1.1 chx#-25\n    if mouse_touching (\n      cursor \"pointer\"\n      if onclick (\n        void button.click()\n      )\n    )\n  )\n)\n",""],[".osl","state","\ndebug = false\n\ndef init() (\n  void self.updateTab()\n  void self.selectTab(1)\n  \n  self.tabs @= []\n)\n\ndef resetDragbox() (\n  self.dragbox @= [[2,2,0,0],[-2,2,-90,-40]]\n)\n\ndef applyDragbox() (\n  window.setDragbox(self.dragbox[1], self.dragbox[2])\n  \n  if self.debug (\n    c #fff\n    loc self.dragbox[1][1] self.dragbox[1][2] self.dragbox[1][3] self.dragbox[1][4]\n    pen \"down\"\n    loc self.dragbox[2][1] self.dragbox[2][2] self.dragbox[2][3] self.dragbox[2][4]\n    pen \"up\"\n  )\n)\n\ndef openTabDocument(object document) (\n  local tab @= shared.tab.Tab(document)\n  void self.tabs.append(tab)\n  void self.selectTab(self.tabs.len)\n)\n\ndef openEmptyTab() (\n  void self.openTabDocument(shared.document.Document())\n)\n\ndef closeTab(number index) (\n  void self.tabs[index].document.close()\n  void self.tabs.delete(index)\n  \n  if index < self.currentTab (\n    self.currentTab --\n  )\n  \n  void self.selectTab(self.currentTab)\n)\n\ndef selectTab(number index) (\n  self.currentTab @= index\n  void self.updateTab()\n)\n\ndef updateTab() (\n  if self.currentDocument != null (\n    self.currentDocument.focused = false\n  )\n  self.currentDocument @= self.tabs[self.currentTab].document\n  if self.currentDocument.url != null (\n    inputs[layouts.shared.urlbar.inputId] = self.currentDocument.url.format()\n  ) else (\n    inputs[layouts.shared.urlbar.inputId] = \"\"\n  )\n  if inputs.selected.id == layouts.shared.urlbar.inputId (\n   input \"unfocus\"\n  )\n  \n  if self.currentDocument != null (\n    self.currentDocument.focused = true\n    \n    // fix for while workers be goofy\n    void self.currentDocument.createWorker()\n  )\n  //self.currentDocument ??= shared.document.Document()\n)\n",""],[".osl","urlbar","\ninputId = \"browser_url\"\n\ndef update(array area) (\n  local defaultText = \"blehh\"\n  \n  goto rwl.area.centerX(area) rwl.area.centerY(area) + 2.5\n  \n  local w = rwl.area.width(area) - 15\n  local h = rwl.area.height(area) - 0\n  \n  square w - 5 h - 18 15 : c#shared.theme.prim\n  input w h - 5 self.inputId defaultText 0 shared.theme.text\n  \n  if inputs.selected.id == self.inputId (\n    if \"enter\".onKeyDown() (\n      void self.goto()\n    )\n  )\n  \n  //void shared.graphics.box(area, #f00)\n)\n\ndef goto() (\n  local url = inputs[self.inputId]\n  \n  url @= shared.url.Url(url)\n  \n  if layouts.shared.state.tabs.len == 0 (\n    void layouts.shared.state.openEmptyTab()\n  )\n  \n  local tab @= layouts.shared.state.tabs[layouts.shared.state.currentTab]\n  void tab.redirect(url)\n)\n",""],[".osl","view","\ndef render(array area) (\n  local contentArea @= rwl.area.copy(area)\n  \n  if devtools.main.open (\n    local devtoolsData @= devtools.main ?? { width: 0, anchor: \"l\" }\n    \n    local devtoolsArea @= rwl.area.copy(area)\n    switch devtoolsData.anchor (\n      case \"l\"\n        contentArea[1] += devtoolsData.width\n        devtoolsArea[3] = contentArea[1]\n        break\n      case \"r\"\n        contentArea[3] -= devtoolsData.width\n        devtoolsArea[1] = contentArea[3]\n        break\n    )\n  \n    devtoolsArea[1] += 5\n  )\n  \n  if layouts.shared.state.currentDocument != null (\n    void layouts.shared.state.currentDocument.checkResp()\n    void layouts.shared.state.currentDocument.render(contentArea)\n  )\n  \n  if devtools.main != null (\n    void devtools.main.alwaysUpdate()\n  )\n  if devtools.main.open (\n    void devtools.main.update(devtoolsArea, area)\n  )\n)\n",""]],""],[".folder","chromeLike",[[".osl","main","\ndef init() (\n  void shared.document.init()\n  void layouts.shared.state.init()\n)\n\ndef update() (\n  void shared.theme.load()\n  void shared.input.update()\n\n  window.show()\n  window_colour = shared.theme.back\n  \n  void layouts.shared.state.resetDragbox()\n\n  local btns @= layouts.shared.topbar.defaultButtons\n  void layouts.shared.topbar.winButtons(btns, false)\n  \n  void layouts.chromeLike.topbar.tabs()\n  \n  void layouts.shared.urlbar.update([\n    window.left,\n    window.top - 45 - 30,\n    window.right,\n    window.top - 44\n  ])\n  \n  void layouts.shared.view.render([\n    window.left,\n    window.bottom,\n    window.right,\n    window.top - 45 - 32.5\n  ])\n  \n  void layouts.shared.state.applyDragbox()\n)\n",""],[".osl","topbar","\ndef tabs() (\n  local space = window.width - 100 - 17.5 - 15\n  \n  local hovered = false\n  \n  local x = 0\n  local tabMax = space / layouts.shared.state.tabs.len - 5\n  for i layouts.shared.state.tabs.len (\n    local tab @= layouts.shared.state.tabs[i]\n    \n    local title = tab.document.getTitle()\n    local icon = tab.document.getIcon()\n    \n    local pad = 15 + 27.5\n    if icon != null (\n      pad += 20\n    )\n    //local width = title.len * 9 + pad\n    local width = 200\n    //width = max(width, 200)\n    width = min(width, tabMax)\n    \n    local lx = x\n    x += 2.5 + (width / 2)\n    \n    loc 2 2 x + (width / 2) - 17.5 -20\n    square 15 15 0 0 1\n    local close_touching = mouse_touching\n    \n    loc 2 2 x -20\n    \n    square width - 17.5 17.5 15 0 1\n    c mouse_touching ? shared.theme.seco shared.theme.prim\n    if layouts.shared.state.currentTab == i (\n      c shared.theme.tert\n    )\n    square width - 17.5 17.5 15\n    \n    if mouse_touching and !close_touching (\n      layouts.shared.state.dragbox @= [\n        [2, 2, lx, 0],\n        [2, 2, lx + width, -20]\n      ]\n      hovered = true\n      \n      cursor \"pointer\"\n      if onclick (\n        void layouts.shared.state.selectTab(i)\n      )\n    )\n    \n    square width - 17.5 17.5 10 : c#shared.theme.prim\n    \n    if icon != null (\n      lx += 20\n      loc 2 2 lx -20\n      icon icon .9 : c#user.theme.text\n      lx += 5\n    )\n    lx += 10\n    \n    loc 2 2 lx -20\n    text title.trimText(width - pad / 9) 9 : c#shared.theme.text tooltip#title\n    \n    lx += 5\n    loc 2 2 x + (width / 2) - 17.5 -20\n    square 15 15 0 0 1\n    if mouse_touching (\n      cursor \"pointer\"\n      if onclick (\n        void layouts.shared.state.closeTab(i)\n        i --\n      )\n    )\n    icon \"close\" .5\n    \n    x += 2.5 + (width / 2)\n  )\n  \n  x += 17.5\n  loc 2 2 x -20\n  square 17.5 17.5 15 : c#shared.theme.prim hover_c#shared.theme.seco\n  if mouse_touching (\n    cursor \"pointer\"\n    if onclick (\n      void layouts.shared.state.openEmptyTab()\n    )\n  )\n  icon \"add\" .6 : c#user.theme.text\n  x += 20\n  \n  loc -2 2 -90 -20\n  line 0 -20 0 20 : c#shared.theme.prim w#1\n  \n  if !hovered (\n    layouts.shared.state.dragbox[1][3] += x\n  )\n)\n",""]],""],[".folder","summit",[[".osl","main","\ndef init() (\n  void shared.document.init()\n  void layouts.shared.state.init()\n)\n\ndef update() (\n  void shared.theme.load()\n  void shared.input.update()\n  \n  window.show()\n  window_colour = #000\n  \n  glass:frame window.left window.top window.right window.bottom; frame \"clear\"\n  \n  void layouts.shared.state.resetDragbox()\n  \n  layouts.shared.state.dragbox[1][3] = max(layouts.summit.sidebar.width, 30)\n  \n  void layouts.summit.sidebar.update([\n    window.left + layouts.summit.sidebar.width - layouts.summit.sidebar.open_width,\n    window.bottom,\n    window.left + layouts.summit.sidebar.width,\n    window.top\n  ])\n  \n  void layouts.summit.topbar.update([\n    window.left + layouts.summit.sidebar.width,\n    window.top - 37.5,\n    window.right - 5,\n    window.top - 5\n  ])\n  \n  void layouts.shared.view.render([\n    window.left + layouts.summit.sidebar.width,\n    window.bottom + 5,\n    window.right - 5,\n    window.top - 42.5\n  ])\n  \n  void layouts.shared.state.applyDragbox()\n)\n",""],[".osl","sidebar","\nopen_width = 250\n\nwidth = 200\ntar_width = open_width\nopen = true\n\ndef update(array area) (\n  goto rwl.area.centerX(area) rwl.area.centerY(area)\n  square rwl.area.width(area) - 20 rwl.area.height(area) - 20 10 : c#shared.theme.back\n  \n  frame area[1] + 10 area[4] - 10 area[3] - 10 area[4] - 35 (\n    //square 1000 1000 1000 : c#fff\n    goto frame.right - 12.5 0\n    square 20 20 0 0 1 : c#fff\n    if mouse_touching (\n      cursor \"pointer\"\n      if onclick (\n        self.open = false\n      )\n    )\n    goto frame.right - 12.5 0\n    icon \"left\" .6 : c#shared.theme.text\n    \n    goto frame.left + 12.5 0\n    square 20 20 0 0 1 : c#fff\n    if mouse_touching (\n      cursor \"pointer\"\n      if onclick (\n        void layouts.shared.state.openEmptyTab()\n      )\n    )\n    icon \"add\" .6 : c#shared.theme.text\n  )\n  \n  void layouts.shared.urlbar.update([\n    area[1] + 10,\n    area[4] - 40 - 32.5,\n    area[3] - 10,\n    area[4] - 40 - 2.5\n  ])\n  \n  c shared.theme.prim\n  frame area[1] + 5 area[4] - 40 - 35 area[3] - 5 area[2] + 5 self.height \"browser_sidebar\" (\n    local y = frame.top + frame.scroll\n    local startY = y\n    \n    for i layouts.shared.state.tabs.len (\n      local tab @= layouts.shared.state.tabs[i]\n      \n      local title = tab.document.getTitle()\n      local icon = tab.document.getIcon()\n      y -= 20\n      \n      local close_touching = false\n      \n      goto frame.right - 22.5 y\n      square 15 15 0 0 1\n      local close_touching = mouse_touching\n      \n      goto 0 y\n      c layouts.shared.state.currentTab == i ? shared.theme.seco shared.theme.prim\n      square frame.width - 25 20 15 : hover_c#shared.theme.tert\n      if mouse_touching and !close_touching (\n        cursor \"pointer\"\n        if onclick (\n          void layouts.shared.state.selectTab(i)\n        )\n      )\n      square frame.width - 25 20 10 : c#shared.theme.back\n      \n      goto frame.left + 15 y\n      if icon != null (\n        icon icon .9 : c#user.theme.text chx#7.5\n        change_x 15\n      )\n      text title.trimText(frame.right - x_position / 9 - 4) 9 : c#shared.theme.text tooltip#title\n      \n      goto frame.right - 22.5 y\n      square 15 15 0 0 1\n      if mouse_touching (\n        cursor \"pointer\"\n        if onclick (\n          void layouts.shared.state.closeTab(i)\n          i --\n        )\n      )\n      icon \"close\" .5\n      \n      y -= 20\n    )\n  )\n  self.height = startY - y - 7.5\n  \n  // clicking on the left side of the window opens the sidebar\n  if self.width < 25 (\n    goto window.left 0\n    square 20 window.height 0 0 1\n    if mouse_touching (\n      cursor \"pointer\"\n      if onclick (\n        self.open = true\n      )\n    )\n  )\n  \n  self.tar_width = self.open ? self.open_width 5\n  self.width += self.tar_width - self.width * min(delta_time, 0.02) * 10\n)\n",""],[".osl","topbar","\ndef update(array area) (\n  goto rwl.area.centerX(area) rwl.area.centerY(area)\n  square rwl.area.width(area) - 10 rwl.area.height(area) - 10 10 : c#shared.theme.back\n  \n  local btns @= layouts.shared.topbar.defaultButtons\n  void layouts.shared.topbar.winButtons(btns, false)\n  \n  local titlebarX = max(area[1], window.left + 30)\n  goto titlebarX + 10 rwl.area.centerY(area)\n  if layouts.shared.state.currentDocument != null (\n    local icn = layouts.shared.state.currentDocument.getIcon()\n    if icn != null (\n      icon icn 1 : c#fff chx#7.5\n      change_x 17.5\n    )\n    text layouts.shared.state.currentDocument.getTitle() 10 : c#shared.theme.text\n  )\n  \n  frame area[1] area[4] titlebarX area[2] (\n    goto 0 0\n    square frame.width - 5 25 0 0 1\n    if mouse_touching (\n      cursor \"pointer\"\n      if onclick (\n        layouts.summit.sidebar.open = true\n      )\n    )\n    icon \"right\" .6 : c#shared.theme.text chx#5\n  )\n)\n",""]],""]],""],[".folder","assets",[[".rwl","empty","root {\n  \"grahhh\"\n}",""],[".rwl","home","root {\n  \"hi\"\n}",""],[".rwl","settings","root {\n  frame [Horizontal, color=theme:prim] {\n    section [id=\"sidebar\", size=150] {\n      \n    },\n    section {\n      frame [Vertical] {\n        section [size=40, padding=10] {\n          \"loading...\" [\n            id=\"location\",\n            color=theme:text,\n            size=12, anchor=\"l\"\n          ]\n        },\n        section [color=theme:back, rounding_tl=10] {\n          \n        }\n      }\n    }\n  },\n  \n  script {\n    event(onload) {\n      setLocation := (text) ~ {\n        document.getElement(\"location\").text = text;\n      };\n      setLocation(\"bleh\");\n      \n      sidebar := document.getElement(\"sidebar\");\n      \n      categories := $$brwsr.settings.getCategories();\n      i := 0;\n      for (category, categories) {\n        i += 1;\n        buttonElem := document.createContainer(\"button\");\n        \n        buttonElem.margin = 7.5;\n        if (i == 1) {\n          buttonElem.anchor = \"tl\";\n          buttonElem.margin_t = 10;\n        } else {\n          buttonElem.margin_t = 0;\n        }\n        buttonElem.height = 35;\n        buttonElem.rounding = 10;\n        buttonElem.hover_color = theme.seco;\n        buttonElem.id = \"cat_\" + category;\n        \n        titleElem := document.createTextElement(toTitle(category));\n        titleElem.color = theme.text;\n        titleElem.size = 11;\n        \n        buttonElem.addChild(titleElem);\n        script := document.createScript(join(\n          \"setLocation := (text) ~ {document.getElement(\\\"location\\\").text = text;};\\n\",\n          \"event(#\" + buttonElem.id + \":click) {\\n\",\n          \"  setLocation(\\\"\" + buttonElem.id + \"\\\");\\n\",\n          \"}\\n\"\n        ));\n        buttonElem.addChild(script);\n        \n        sidebar.addChild(buttonElem);\n      }\n    }\n  }\n}",""]],""],[".folder","net",[[".osl","fetch","\ndef url(object url) (\n  if url.scheme == \"local\" (\n    //local f @= open(url.domain_name).toStr()\n    // fpp import instead (goes into output)\n    local f @= import(url.domain_name).toStr()\n    local r @= net.response.ValidResponse(url)\n    r.fetch @= def() -> (\n      self.content = self.f\n      self.isFinished = true\n    )\n    r.f @= f\n    return r\n  )\n  if url.scheme == shared.config.url.browser_scheme (\n    local r @= net.response.ValidResponse(url)\n    local page @= browserPages[url.domain_name]\n    if typeof(page) == \"string\" (\n      r.fetch @= def() -> (\n        self.content = self.data\n        self.isFinished = true\n      )\n      r.data @= page\n    ) else (\n      r.fetch @= page ?? (() -> ())\n    )\n    return r\n  )\n\n  local servers @= shared.config.net.servers\n  local server @= servers[url.scheme]\n  \n  if server == null (\n    local r @= net.response.NoResponse(url, \"scheme '\" ++ url.scheme ++ \"' not found\")\n    return r\n  )\n  \n  local resource = url.domain_top\n  resource ++= \"/\"\n  if url.domain_sub != null (\n    resource ++= url.domain_sub\n    resource ++= \".\"\n  )\n  resource ++= url.domain_name\n  if url.resource != null (\n    resource ++= \"/\"\n    resource ++= url.resource\n  )\n  \n  local tld = server.tlds[url.domain_top]\n  \n  if tld == null (\n    local r @= net.response.NoResponse(url, \"tld '\" ++ url.domain_top ++ \"' not found\")\n    return r\n  )\n  \n  local realUrl = tld ++ \"/\" ++ resource\n  \n  local r @= net.response.ValidResponse(url)\n  r.fetch @= def() -> (\n    local o = self.realUrl.getAsync()\n    if o != \"Loading\" and o != \"404: Not Found\" (\n      self.content = o\n      self.isFinished = true\n    )\n  )\n  r.realUrl = realUrl\n  \n  return r\n)\n",""],[".osl","response","\nclass Response (\n  isValid = false\n  \n  def init(object url, string content) (\n    self.url @= url\n    self.content = content\n    \n    self.isFinished = true\n  )\n)\n\nclass NoResponse extends Response (\n  \n)\n\nclass ValidResponse extends Response (\n  isValid = true\n  \n  def init(object url) (\n    self.url @= url\n    \n    self.isFinished = false\n  )\n  \n  def update() (\n    if self.isFinished (\n      return\n    )\n    local out @= self.fetch()\n    if out != null (\n      self.isFinished = true\n      self.content @= out\n    )\n  )\n)\n",""]],""],[".folder","devtools",[[".folder","menus",[[".osl","elements","\nnumber indent = 20\n\nnumber x = 0\nnumber y = 0\n\nnumber maxX = 0\n\ndef drawElements(array elements) (\n  for i elements.len (\n    if elements[i] != null (\n      drawElement(elements[i])\n    )\n    if i < elements.len (\n      text \",\" 10\n    )\n  )\n)\n\ndef drawElement(object element) (\n  if element.children != null or element.kind == \"script\" (\n    self.y -= 15\n    goto 0 self.y\n    \n    element.dvt_open ??= false or true\n    \n    goto self.x self.y\n    square 20 20 0 0 1 : c#fff\n    if mouse_touching (\n      cursor \"pointer\"\n      if onclick (\n        element.dvt_open = !element.dvt_open\n      )\n    )\n    icon element.dvt_open ? \"down\" \"right\" .5 : c#shared.theme.text\n    \n    text element.blockName ?? element.name 10 : chx#15\n    if mouse_touching (\n      cursor \"pointer\"\n      devtools.main.hoveredElement = element.elemI\n      if onclick (\n        element.dvt_open = !element.dvt_open\n      )\n    )\n    \n    drawHeader(element.header)\n    \n    self.y -= 15\n    \n    if element.dvt_open (\n      text \"{\" 10 : chx#10\n      self.maxX = max(self.maxX, x_position)\n      self.x += self.indent\n      \n      if element.kind == \"script\" (\n        local content = element.body\n        local lines @= content.split(\"\\n\")\n        local line_height = 25\n        local height = lines.len - 1 * line_height + 5\n        \n        local cy = self.y - 2.5\n        self.y -= height\n        \n        for i lines.len (\n          cy -= line_height / 2\n          \n          goto self.x cy\n          \n          //self.maxX = max(self.maxX, x_position + (lines[i].len * 10))\n          //text lines[i].trimText(frame.right - x_position - 17.5 / 8) 10 : c#shared.theme.text\n          text lines[i] 10 : c#shared.theme.text\n          \n          cy -= line_height / 2\n        )\n      ) else (\n        drawElements(element.children)\n      )\n      \n      self.x -= self.indent\n      \n      self.y -= 15\n      goto self.x - 5 self.y\n      text \"}\" 10\n      self.y -= 15\n    ) else (\n      if element.kind == \"script\" (\n        text \"{\" 10 : chx#10\n        drawTooLong() : chx#10\n        text \"}\" 10 : chx#10\n      ) else (\n        text \"{\" 10 : chx#10\n        drawMiniChildren(element.children) : chx#10\n        text \"}\" 10 : chx#10\n      )\n      self.maxX = max(self.maxX, x_position)\n    )\n  ) else if element.kind == \"element\" (\n    self.y -= 15\n    goto self.x self.y\n    drawValue(element.value)\n    drawHeader(element.header)\n    local s = x_position\n    self.maxX = max(self.maxX, x_position)\n    local w = x_position - self.x\n    goto x_position + self.x / 2 self.y\n    square w 20 0 0 1\n    if mouse_touching (\n      devtools.main.hoveredElement = element.elemI\n    )\n    goto s self.y\n    self.y -= 15\n  ) else if element.kind == \"icon\" (\n    self.y -= 15\n    goto self.x self.y\n    text \"Icon\" 10\n    drawHeader(element.header)\n    self.maxX = max(self.maxX, x_position)\n    self.y -= 15\n  )\n)\n\ndef drawHeader(object header) (\n  if header.flags.len == 0 and header.pairs.len == 0 (\n    return\n  )\n  \n  change_x 7.5\n  text \"[\" 10\n  for i header.flags.len (\n    local flag = header.flags[i]\n    text flag 8\n    if i < header.flags.len or header.pairs.len > 0 (\n      text \", \" 8\n    )\n  )\n  \n  for i header.pairs.len (\n    local pair @= header.pairs[i]\n    text pair[1] 10\n    text \"=\" 8\n    drawValue(pair[2])\n    if i < header.pairs.len (\n      text \", \" 8\n    )\n  )\n  text \"]\" 10\n)\n\ndef drawValue(object value) (\n  switch value.type (\n    case \"str\"\n      text value.value.JsonStringify() 10\n      break\n    case \"num\"; case \"color\"\n      text value.value 10\n      break\n    case \"percentage\"\n      text value.value.toStr() ++ \"%\" 10\n      break\n  )\n)\n\ndef drawMiniChildren(array children) (\n  if children.len == 0 (\n    change_x -20\n    return\n  )\n  \n  change_x 5\n  for i children.len (\n    drawMiniChild(children[i])\n    if i < children.len (\n      text \", \" 8\n    )\n  )\n  change_x 5\n  \n  change_x -20\n)\n\ndef drawMiniChild(object element) (\n  if element.children != null or element.kind == \"script\" (\n    text element.blockName ?? element.name 7\n    text \"{\" 7 : chx#10\n    drawTooLong()\n    text \"}\" 7 : chx#20\n  ) else (\n    text \"Element\" 7\n  )\n)\n\ndef drawTooLong() (\n  text \"...\" 8 : chx#5\n  change_x -15\n)\n\ndef update() (\n  local document @= layouts.shared.state.currentDocument\n  local elements @= document.rwlInst.elements\n  if typeof(elements) != \"array\" (\n    elements @= []\n  )\n  \n  local s = frame.scroll_h * -1\n  self.x = frame.left + s + 15\n  local startX = self.x\n  self.y = frame.top + frame.scroll\n  local startY = self.y\n  \n  self.width = 0\n  self.maxX = 0\n  \n  if elements != null (\n    drawElements(elements)\n  )\n  \n  //self.width = self.maxX - startX\n  self.width = self.maxX - startX\n  self.height = startY - self.y + 5\n)\n",""],[".osl","console","\ndef getInst() (\n  return layouts.shared.state.currentDocument.rtrInst\n)\n\ndef topbar() (\n  local inst @= self.getInst()\n  \n  goto frame.left + 10 0\n  square 15 15 0 0 1\n  if inst != null (\n    if mouse_touching (\n      cursor \"pointer\"\n      if onclick (\n        inst.console @= []\n      )\n    )\n    c shared.theme.text\n  ) else (\n    if mouse_touching (\n      cursor \"not-allowed\"\n    )\n    c shared.theme.seco\n  )\n  icon \"w 2.5 cutcircle 0 0 10 0 180 line -6 -6 6 6\" .7\n)\n\ndef update() (\n  local inst @= self.getInst()\n  \n  local y = frame.top + frame.scroll\n  local start = y\n  \n  for ii inst.console.len (\n    local item @= inst.console[ii]\n    local lines @= item[2].wrapText(frame.width - 10 / 10).split(\"\\n\")\n    local height = lines.len * 20\n    \n    local col = null\n    if item[1] == \"err\" or item[1] == \"repl-err\" (\n      col = #f00\n    )\n    \n    local ly = y\n    local sy = y\n    \n    y -= 5\n    y -= height\n    y -= 5\n    \n    if col != null (\n      frame frame.left y frame.right ly (\n        c col\n        pen \"opacity\" 20\n        pen \"size\" 10000\n        pen \"down\"\n        pen \"up\"\n      )\n    )\n    \n    local offsetX = 5\n    \n    if item[1].startsWith(\"repl\") (\n      goto frame.left + offsetX + 5 ly - 15\n      \n      if item[1] == \"repl-in\" (\n        icon \"right\" .5 : c#shared.theme.text\n      )\n      if item[1] == \"repl-ret\" (\n        icon \"left\" .5 : c#shared.theme.text\n      )\n      if item[1] == \"repl-err\" (\n        icon \"left\" .5 : c#shared.theme.text\n      )\n      offsetX += 20\n    )\n    \n    c shared.theme.text\n    for i lines.len (\n      ly -= 10\n      goto frame.left + offsetX ly - 5\n      text lines[i] 10\n      ly -= 10\n    )\n    \n    pen \"size\" 2 : c#shared.theme.prim\n    \n    goto 0 sy\n    line frame.left 0 frame.right 0\n    \n    goto 0 y\n    line frame.left 0 frame.right 0\n  )\n  \n  // repl\n  y -= 15\n  goto frame.left + 12.5 y\n  icon \"right\" .5 : c#shared.theme.text\n  \n  local inputId = \"devtools_repl_\" ++ inst.ouid\n  goto 12.5 y\n  input frame.width - 35 30 inputId null 0 shared.theme.text : c#shared.theme.back\n  \n  if \"enter\".onKeyDown() and inputs.selected.id == inputId (\n    local inp = inputs[inputId]\n    \n    void inst.console.append([\"repl-in\", inp])\n    \n    promiseData = inp\n    promiseData2 @= inst\n    self.runPromise @= Promise.new(def() -> (\n      local parser @= rtr.ast.Parser(\"event(onload){return(\" ++ promiseData ++ \");}\")\n      self.ast @= parser.parse()\n      self.mod @= rtr.main.Module(self.ast)\n      void rtr.apis.main.addToMod(layouts.shared.state.currentDocument, self.mod)\n      void promiseData2.addModule(self.mod)\n      local ret @= mod.runEventRaw({\n        name: \"onload\"\n      }, {})\n      return ret\n    ))\n    \n    inputs[inputId] = \"\"\n  )\n  \n  if self.runPromise != null (\n    local ret @= self.runPromise.worker.return\n    if ret != null (\n      void inst.console.append([\"repl-ret\", ret.stringify(true)])\n      self.runPromise = null\n    )\n  )\n  \n  y -= 15\n  \n  self.height = start - y - 10\n)\n",""],[".osl","network","",""],[".osl","storage","",""],[".osl","compiled","\nnumber offsetX = 0\nboolean exit = false\nselectedCode = null\n\nobject highlighting = {\n  program_flow: {\n    color: #ff4b19,\n    names: [\n      \"label\",\n      \n      \"jump\",\n      \"jumpIf\",\n      \"jumpNotIf\"\n    ]\n  },\n  operations: {\n    color: #ff8119,\n    names: [\n      \"call\",\n      \"unary\",\n      \"binary\",\n      \"prop\",\n      \"len\",\n      \n      \"asivar\",\n      \"asiprop\"\n    ]\n  },\n  values: {\n    color: #52e342,\n    names: [\n      \"null\",\n      \"str\",\n      \"bool\",\n      \"num\",\n      \"func\",\n      \"arr\",\n      \"obj\",\n      \"color\"\n    ]\n  },\n  scope: {\n    color: #00edb6,\n    names: [\n      \"get\",\n      \"decl\",\n      \n      \"newScope\",\n      \"popScope\"\n    ]\n  },\n  stack: {\n    color: #cd27e3,\n    names: [\n      \"pop\",\n      \"dupe\"\n    ]\n  }\n}\n\nobject colors = {\n  label: #34eb9b,\n  str: #eba434,\n  num: #34eb3a,\n  bool: #537aed,\n  col: #73a7f0,\n  var: #cf8846\n}\n\ndef getInst() (\n  return layouts.shared.state.currentDocument.rtrInst\n)\n\ndef topbar() (\n  if self.selectedCode == null (\n    self.topbarHeight = -1\n  ) else (\n    self.topbarHeight = null\n    \n    goto frame.left + 10 0\n    square 15 15 0 0 1\n    if mouse_touching (\n      cursor \"pointer\"\n      if onclick (\n        self.exit = true\n        self.topbarHeight = -1\n      )\n    )\n    icon \"left\" .5 : c#shared.theme.text\n    \n    change_x 15\n    \n    c shared.theme.prim\n    pen \"size\" 2\n    change_y 11\n    pen \"down\"\n    change_y -22\n    pen \"up\"\n    change_y 11\n    \n    change_x 7.5\n    drawLoc(self.selectedCode)\n  )\n)\n\ndef update() (\n  if !shared.config.browser.phosphorus.useCompiler (\n    goto 0 0\n    centext \"compiler disabled\" 10 : c#shared.theme.prim\n    return\n  )\n  \n  local inst @= self.getInst()\n  \n  if self.selectedCode == null (\n    // selector screen\n    local y = frame.top\n    \n    if inst.compiled != null (\n      for i inst.compiled.len (\n        local comp @= inst.compiled[i]\n        \n        y -= 15\n        goto frame.left + 7.5 y\n        \n        drawLoc(comp)\n        \n        goto frame.right + 16 y\n        square 10 10 12 : chx#-30 c#shared.theme.prim hover_c#shared.theme.seco\n        if mouse_touching (\n          cursor \"pointer\"\n          if onclick (\n            self.selectedCode @= comp\n          )\n        )\n        icon \"open\" .6 : c#shared.theme.text\n        \n        y -= 15\n        goto 0 y\n        pen \"size\" 2\n        line frame.left 0 frame.right 0 : c#shared.theme.prim\n      )\n    ) else (\n      goto 0 0\n      centext \"nothing compiled\" 10 : c#shared.theme.prim\n    )\n  ) else (\n    self.y = frame.top + frame.scroll\n    local start = self.y\n    self.offsetX = 0\n    drawInstructions(self.selectedCode.body, frame.left + 15)\n    self.height = start - self.y - 10\n  )\n  if self.exit (\n    self.exit = false\n    self.selectedCode = null\n  )\n)\n\ndef drawLoc(object comp) (\n  local txt = comp.start.loc ?? \"unknown\"\n  txt += comp.start.ln\n  txt ++= \":\"\n  txt ++= comp.start.char\n  txt += \"-\"\n  txt += comp.end.ln\n  txt ++= \":\"\n  txt ++= comp.end.char\n  text txt 10 : c#shared.theme.text\n)\n\ndef drawInstructions(array instructions, number x) (\n  for i instructions.len (\n    if instructions[i] != null (\n      drawInstruction(instructions[i], x, instructions, i)\n    )\n  )\n)\n\ndef drawInstruction(object instruction, number x, array instructions, number i) (\n  local height = 25\n  instruction.editorX = x\n  \n  self.y -= height / 2\n  instruction.editorY = self.y\n  \n  if instruction.kind == \"popScope\" (\n    self.offsetX -= 10\n  )\n  \n  if !(self.y - height > frame.top or self.y < frame.bottom) (\n    local fromleft = x + self.offsetX - frame.left\n    goto fromleft / 2 self.y\n    square frame.width - fromleft height 0 0 1\n    if mouse_touching (\n      change_x -2.5\n      square frame.width - fromleft - 15 height - 15 10 : c#shared.theme.prim\n    \n      local corresponding = self.getCorresponding(instructions, i)\n      if corresponding != null (\n        // \"arrow\" | \"point\"\n        local look = \"arrow\"\n        c shared.theme.tert\n        goto x + self.offsetX self.y\n        if look == \"point\" (\n          pen \"size\" 7.5\n          pen \"down\"\n          pen \"up\"\n        )\n        pen \"size\" 2.5\n        pen \"down\"\n        goto x + self.offsetX - 7.5 self.y\n        goto x + self.offsetX - 7.5 corresponding.editorY\n        goto x + self.offsetX corresponding.editorY\n        pen \"up\"\n        if look == \"point\" (\n          pen \"size\" 7.5\n          pen \"down\"\n          pen \"up\"\n        )\n        if look == \"arrow\" (\n          change_x 2\n          pen \"down\"\n          change -4 4\n          change 4 -4\n          change -4 -4\n          pen \"up\"\n        )\n      )\n    )\n    \n    goto x + 5 + self.offsetX self.y\n    \n    c shared.theme.text\n    local categories @= self.highlighting.getValues()\n    for i categories.len (\n      if categories[i].names.contains(instruction.kind) (\n        c categories[i].color\n      )\n    )\n    \n    text instruction.kind 9\n    \n    void self.drawData(instruction)\n  )\n  \n  self.y -= height / 2\n  \n  if instruction.kind == \"func\" (\n    drawInstructions(instruction.body, x + 20)\n  )\n  \n  if instruction.kind == \"newScope\" (\n    self.offsetX += 10\n  )\n)\n\ndef drawData(object instruction) (\n  switch instruction.kind (\n    case \"label\"\n      drawLabel(instruction.name)\n      break\n    case \"jump\"; case \"jumpIf\"; case \"jumpNotIf\";\n      drawLabel(instruction.label)\n      break\n    \n    case \"call\"\n      drawArgName(\"args\")\n      drawNum(instruction.args)\n      break\n    case \"unary\"; case \"binary\"\n      drawStr(instruction.op)\n      break\n    \n    case \"str\"\n      drawStr(instruction.data)\n      break\n    case \"num\"\n      drawNum(instruction.data)\n      break\n    case \"bool\"\n      drawBool(instruction.data)\n      break\n    case \"func\"\n      drawArgs(instruction.args)\n      break\n    case \"arr\"\n      drawArgName(\"elems\")\n      drawNum(instruction.elems)\n      break\n    case \"obj\"\n      drawArr(instruction.keys)\n      break\n    case \"color\"\n      drawColor(instruction.data)\n      break\n    \n    case \"get\"\n      drawVar(instruction.name)\n      break\n    case \"decl\"\n      drawVar(instruction.name)\n      break\n    \n    case \"asivar\"\n      if instruction.op != null (\n        drawStr(instruction.op)\n      )\n      drawVar(instruction.name)\n      break\n    case \"asiprop\"\n      if instruction.op != null (\n        drawStr(instruction.op)\n      )\n      break\n    \n    case \"dupe\"\n      drawArgName(\"idx\")\n      drawNum(instruction.i)\n      break\n  )\n)\n\ndef drawArgName(string name) (\n  text name 9 : c#shared.theme.text chx#7.5\n  text \"=\" 9 : chx#5\n  change_x -2.5\n)\n\ndef drawStr(string str) (\n  text str.JsonStringify() 9 : c#self.colors.str chx#7.5\n)\ndef drawNum(number num) (\n  text num 9 : c#self.colors.num chx#7.5\n)\ndef drawBool(boolean bool) (\n  text bool.toStr() 9 : c#self.colors.bool chx#7.5\n)\ndef drawColor(string col) (\n  text col 9 : c#self.colors.col chx#7.5\n)\ndef drawArr(array arr) (\n  text arr.join(\" \") 9 : c#shared.theme.text chx#7.5\n)\ndef drawArgs(array args) (\n  text args.map(a -> \"@\" ++ a.name).join(\" \") 9 : c#self.colors.var chx#7.5\n)\ndef drawVar(string name) (\n  text \"@\" ++ name 9 : c#self.colors.var chx#7.5\n)\ndef drawLabel(string name) (\n  text \"#\" ++ name 9 : c#self.colors.label chx#7.5\n)\n\ndef getCorresponding(array instructions, number i) (\n  local cur @= instructions[i]\n  \n  if cur.kind == \"newScope\" (\n    local depth = 0\n    while i < instructions.len (\n      i ++\n      local instruction @= instructions[i]\n      if instruction.kind == \"newScope\" (\n        depth ++\n      )\n      if instruction.kind == \"popScope\" (\n        if depth == 0 (\n          return instruction\n        )\n        depth --\n      )\n    )\n  )\n  if cur.kind == \"popScope\" (\n    local depth = 0\n    while i > 0 (\n      i --\n      local instruction @= instructions[i]\n      if instruction.kind == \"newScope\" (\n        if depth == 0 (\n          return instruction\n        )\n        depth ++\n      )\n      if instruction.kind == \"popScope\" (\n        depth --\n      )\n    )\n  )\n  \n  if [\"jump\",\"jumpIf\",\"jumpNotIf\"].contains(cur.kind) (\n    for i instructions.len (\n      local instruction @= instructions[i]\n      if instruction.kind == \"label\" (\n        if instruction.name == cur.label (\n          return instruction\n        )\n      )\n    )\n  )\n)\n",""]],""],[".osl","main","\nstring anchor = \"r\"\nnumber width = 350\nboolean open = false\n\nnumber saveWidth = 350\nnumber resizingEdge = 0\n\nhoveredElement = 0\n\nstring menu = \"console\"\n\ndef alwaysUpdate() (\n  self.hoveredElement = 0\n)\n\ndef update(array area, array rawArea) (\n  goto rwl.area.centerX(area) rwl.area.centerY(area)\n  square rwl.area.width(area) - 10 rwl.area.height(area) - 10 10 : c#shared.theme.back\n  \n  local h = 25\n  frame area[1] area[4] area[3] area[4] - h (\n    goto 0 -5\n    square frame.width - 10 frame.height 10 : c#shared.theme.prim\n    \n    goto frame.right - 12.5 0\n    icon \"more-vertical\" .5 : c#shared.theme.text\n    if mouse_touching (\n      cursor \"pointer\"\n      if onclick (\n        local p @= Promise.new(() -> (\n          while mouse_down (\n            defer\n          )\n          open_rightclick devtools.rightclick.topbar_more\n        ))\n      )\n    )\n  )\n  frame area[1] area[4] area[3] - 25 area[4] - h (\n    void devtools.topbar.update()\n  )\n  \n  if mouse_y > area[2] and mouse_y < area[4] (\n    if anchor == \"r\" and abs(mouse_x - area[1]) < 5 (\n      cursor \"col-resize\"\n      goto mouse_x mouse_y\n      square 100 100 0 0 1\n      if onclick (\n        self.resizingEdge = 1\n      )\n    )\n    if anchor == \"l\" and abs(mouse_x - area[3]) < 5 (\n      cursor \"col-resize\"\n      goto mouse_x mouse_y\n      square 100 100 0 0 1\n      if onclick (\n        self.resizingEdge = 3\n      )\n    )\n  )\n  \n  if !mouse_down (\n    self.resizingEdge = 0\n  )\n  \n  if self.resizingEdge != 0 (\n    self.width = abs(mouse_x - area[4 - self.resizingEdge])\n  )\n  self.width = min(self.width, rwl.area.width(rawArea) - 200)\n  self.width = max(self.width, 200)\n  \n  local menu @= devtools.menus[self.menu]\n  \n  c shared.theme.prim\n  local topbarH = 0\n  if menu.topbar != null (\n    topbarH = menu.topbarHeight ?? 25\n    frame area[1] area[4] - h area[3] area[4] - h - topbarH (\n      void menu.topbar()\n    )\n    local w = rwl.area.width(area)\n    goto rwl.area.centerX(area) area[4] - h - topbarH\n    pen \"size\" 2\n    line w / -2 -1 w / 2 -1 : c#shared.theme.prim\n    topbarH += 1\n  )\n  \n  c shared.theme.prim\n  local bottombarH = 0\n  if menu.bottombar != null (\n    bottombarH = menu.bottombarHeight ?? 25\n    frame area[1] area[4] - h area[3] area[4] - h - bottombarH (\n      void menu.bottombar()\n    )\n    local w = rwl.area.width(area)\n    goto rwl.area.centerX(area) area[2] + bottombarH\n    pen \"size\" 2\n    line w / -2 1 w / 2 1 : c#shared.theme.prim\n    bottombarH += 1\n  )\n  \n  c shared.theme.prim\n  frame area[1] area[4] - h - topbarH area[3] area[2] + bottombarH [menu.width,menu.height] \"devtools_\" ++ self.menu (\n    if menu != null (\n      if menu.update != null (\n        void menu.update()\n      )\n    ) else (\n      goto 0 0\n      centext \"no open devtools menu\" 9 : c#shared.theme.prim\n    )\n  )\n)\n",""],[".osl","topbar","\ntabs_scroll = 0\ntabs_width = 0\n\ndef update() (\n  square frame.width frame.height 0 0 1\n  if mouse_touching (\n    self.tabs_scroll += scroll.x.velocity + scroll.y.velocity * -1.5 * scroll.multiplier\n  )\n  \n  self.tabs_scroll = min(self.tabs_scroll, self.tabs_width - frame.width)\n  self.tabs_scroll = max(self.tabs_scroll, 0)\n  \n  local x = frame.left - self.tabs_scroll\n  local start = x\n  local menus @= devtools.menus.getEntries()\n  for i menus.len (\n    local menu @= menus[i]\n    \n    local title = menu[1].toTitle()\n    local w = title.len * 8 + 10\n    \n    x += w / 2\n    \n    goto x 0\n    square w - 10 10 10 0 1\n    c devtools.main.menu == menu[1] ? shared.theme.seco shared.theme.prim\n    if mouse_touching (\n      c shared.theme.tert\n      cursor \"pointer\"\n      if onclick (\n        void shared.settings.set(\"devtools\", \"menu\", menu[1])\n      )\n    )\n    pen \"size\" 2\n    line w / -2 -11 w / 2 -11\n    centext title 8 : c#shared.theme.text\n    \n    x += w / 2\n  )\n  self.tabs_width = x - start\n)\n",""],[".osl","rightclick","\narray topbar_more = [\n  [\"Dock\",\n    {\"left\": def() -> (\n      void shared.settings.set(\"devtools\", \"dockside\", \"l\")\n    )},\n    {\"right\": def() -> (\n      void shared.settings.set(\"devtools\", \"dockside\", \"r\")\n    )}\n  ]\n]\n",""]],"c #6c2d7b square 0 2 10 4 c #bd64e9 square -8 6 2 2 line -5 7 3 0 square 0 -1 10 5 w 8 square 0 -0.5 5 0"]],"c #0f5c3d square 0 2 10 4 c #1fd18a square -8 6 2 2 line -5 7 3 0 square 0 -1 10 5 w 8 square 0 -0.5 5 0"],[".folder","scripts",[[".osl","opal_chromeLike","file \"goto_dir\" terminal.pwd\n\nlocal data @= open(terminal.pwd ++ \"/opal.json\").JsonParse()\n\ndata.phosphorus.layout = \"chromeLike\"\n\nfile \"set_file\" \"opal.json\" data.JsonFormat()",""],[".osl","opal_summit","file \"goto_dir\" terminal.pwd\n\nlocal data @= open(terminal.pwd ++ \"/opal.json\").JsonParse()\n\ndata.phosphorus.layout = \"summit\"\ndata.name = \"summit\"\n\nfile \"set_file\" \"opal.json\" data.JsonFormat()",""],[".osl","opal_reset","file \"goto_dir\" terminal.pwd\n\nlocal data @= open(terminal.pwd ++ \"/opal.json\").JsonParse()\n\ndata.name = \"phosphorus\"\n\nfile \"set_file\" \"opal.json\" data.JsonFormat()",""]],"c #6e6410 square 0 2 10 4 c #dbc714 square -8 6 2 2 line -5 7 3 0 square 0 -1 10 5 w 8 square 0 -0.5 5 0"],[".json","opal","{\"name\": \"phosphorus\", \"version\": \"1.0.0a\", \"description\": \"rotur web engine\", \"main\": \"script.osl\", \"dependencies\": {}, \"tags\": [], \"include\": [\"./main.rwl\", \"./test.rwl\", \"./sidebartest.rwl\"], \"phosphorus\": {\"layout\": \"chromeLike\", \"hasDevtools\": true}, \"scripts\": {\"opaljson-summit\": \"osl ./scripts/opal_summit.osl\", \"opaljson-chromeLike\": \"osl ./scripts/opal_chromeLike.osl\", \"opaljson-reset\": \"osl ./scripts/opal_reset.osl\", \"build-summit\": [\"fpp script opaljson-summit\", \"fpp build\", \"rm build/script-summit.osl\", \"mv build/script.osl build/script-summit.osl\", \"echo \\\"summit build complete!\\\"\"], \"build-chromeLike\": [\"fpp script opaljson-chromeLike\", \"fpp build\", \"rm build/script-chromeLike.osl\", \"mv build/script.osl build/script-chromeLike.osl\", \"echo \\\"chromeLike build complete!\\\"\"], \"build\": [\"fpp script build-summit\", \"fpp script build-chromeLike\", \"fpp script opaljson-reset\"]}}",""],[".osl","script","import as \"glass\" from \"packages\"\n\n// fpp boilerplate\n__import @= import;import @= i -> (i.endsWith(\".osl\") ? __import(i) open(i))\nbuild ??= { built: false, package: import(\"./opal.json\").JsonParse() }\n\nobject rwl @= {\n  main: import(\"./src/rwl/main.osl\"),\n  config: import(\"./src/rwl/config.osl\"),\n  area: import(\"./src/rwl/area.osl\"),\n  error: import(\"./src/rwl/error.osl\"),\n  value: import(\"./src/rwl/value.osl\"),\n  debug: import(\"./src/rwl/debug.osl\"),\n  ast: import(\"./src/rwl/ast.osl\")\n}\n\nobject rtr @= {\n  main: import(\"./src/rtr/main.osl\"),\n  ast: import(\"./src/rtr/ast.osl\"),\n  error: import(\"./src/rtr/error.osl\"),\n  value: import(\"./src/rtr/value.osl\"),\n  compiler: import(\"./src/rtr/compiler.osl\"),\n  instruction: import(\"./src/rtr/instruction.osl\"),\n  apis: {}\n}\n\n// make them load after\nrtr.apis @= {\n  main: import(\"./src/rtr/apis/main.osl\"),\n  rwl: import(\"./src/rtr/apis/rwl.osl\"),\n  browser: import(\"./src/rtr/apis/browser.osl\")\n}\n\nobject shared @= {\n  graphics: import(\"./src/shared/graphics.osl\"),\n  utils: import(\"./src/shared/utils.osl\"),\n  document: import(\"./src/shared/document.osl\"),\n  tab: import(\"./src/shared/tab.osl\"),\n  url: import(\"./src/shared/url.osl\"),\n  theme: import(\"./src/shared/theme.osl\"),\n  config: import(\"./src/shared/config.osl\"),\n  tab_worker: import(\"./src/shared/tab_worker.osl\"),\n  input: import(\"./src/shared/input.osl\"),\n  settings: import(\"./src/shared/settings.osl\"),\n  save: import(\"./src/shared/save.osl\")\n}\n\nobject layouts @= {\n  shared: {\n    state: import(\"./src/layouts/shared/state.osl\"),\n    utils: import(\"./src/layouts/shared/utils.osl\"),\n    topbar: import(\"./src/layouts/shared/topbar.osl\"),\n    urlbar: import(\"./src/layouts/shared/urlbar.osl\"),\n    view: import(\"./src/layouts/shared/view.osl\")\n  },\n  chromeLike: {\n    main: import(\"./src/layouts/chromeLike/main.osl\"),\n    topbar: import(\"./src/layouts/chromeLike/topbar.osl\")\n  },\n  summit: {\n    main: import(\"./src/layouts/summit/main.osl\"),\n    sidebar: import(\"./src/layouts/summit/sidebar.osl\"),\n    topbar: import(\"./src/layouts/summit/topbar.osl\")\n  }\n}\n\nobject net @= {\n  fetch: import(\"./src/net/fetch.osl\"),\n  response: import(\"./src/net/response.osl\")\n}\n\nif build.package.phosphorus.hasDevtools ?? true (\n  object devtools @= {\n    main: import(\"./src/devtools/main.osl\"),\n    topbar: import(\"./src/devtools/topbar.osl\"),\n    rightclick: import(\"./src/devtools/rightclick.osl\"),\n    \n    menus: {\n      elements: import(\"./src/devtools/menus/elements.osl\"),\n      console: import(\"./src/devtools/menus/console.osl\"),\n      network: import(\"./src/devtools/menus/network.osl\"),\n      storage: import(\"./src/devtools/menus/storage.osl\"),\n      compiled: import(\"./src/devtools/menus/compiled.osl\")\n    }\n  }\n)\n\nobject browserPages @= {\n  empty: import(\"./src/assets/empty.rwl\"),\n  home: import(\"./src/assets/home.rwl\"),\n  settings: () -> import(\"./src/assets/settings.rwl\")\n}\n\nvoid shared.settings.load()\nvoid shared.config.net.refresh()\n\nvoid layouts.chromeLike.main.init()\n\nif !build.built (\n  // debug tabs\n  local document @= shared.document.Document()\n  void document.loadUrl(shared.url.Url(\"phos://settings\"))\n  //void document.loadUrl(shared.url.Url(\"local://./main.rwl\"))\n  void layouts.shared.state.openTabDocument(document)\n  \n  local document2 @= shared.document.Document()\n  void document2.loadUrl(shared.url.Url(\"local://./test.rwl\"))\n  void layouts.shared.state.openTabDocument(document2)\n  \n  local document3 @= shared.document.Document()\n  void document3.loadUrl(shared.url.Url(\"local://./sidebartest.rwl\"))\n  void layouts.shared.state.openTabDocument(document3)\n) else (\n  local document3 @= shared.document.Document()\n  void document3.loadUrl(shared.url.Url(shared.config.url.browser_scheme ++ \"://home\"))\n  void layouts.shared.state.openTabDocument(document3)\n)\n\nvoid layouts.shared.state.selectTab(1)\n\nvoid window.resize(900,500)\n\ncurrentLayout = build.package.phosphorus.layout ?? \"chromeLike\"\n\nif !build.built (\n  currentLayout = \"summit\"\n)\n\nmainloop:\n  void layouts[currentLayout].main.update()\n  //void layouts.chromeLike.main.update()\n  //void layouts.summit.main.update()\n  \n  // file dropping\n  if file_dropped != 0 (\n    local data @= open(file_dropped,[3,2,1])\n    local path = data[1] ++ \"/\" ++ data[2] ++ data[3]\n    local document @= shared.document.Document()\n    void document.loadUrl(shared.url.Url(\"local://\" ++ path))\n    void layouts.shared.state.openTabDocument(document)\n    file_dropped = 0\n  )",""],[".rwl","sidebartest","root {\n  frame [Horizontal, id=\"bleh\"] {\n    section [\n      id=\"sidebar\",\n      size=150, color=theme:prim,\n      rounding_tr=17.5, rounding_br=17.5,\n      padding=10\n    ] {},\n    section {\n    }\n  },\n  \n  script {\n    event(onload) {\n      i := 0;\n      createSidebarButton := (name) ~ {\n        i = i + 1;\n        elem := document.createContainer(\"button\");\n        elem.height = 35;\n        elem.padding = 10;\n        elem.color = theme.seco;\n        elem.hover_color = theme.tert;\n        elem.rounding = 10;\n        elem.id = \"btn\" + i;\n        if (i == 1)\n          elem.anchor = \"t\";\n        elem.margin_b = 10;\n        document.getElement(\"sidebar\").addChild(elem);\n        \n        script := document.createScript(\"event(#\" + elem.id + \":click) {\\n  log(\\\"\" + name + \" clicked!\\\");\\n}\\n\");\n        document.root.addChild(script);\n        \n        text := document.createTextElement(name);\n        text.color = theme.text;\n        elem.addChild(text);\n      };\n      \n      btns := [\n        \"hi\",\n        \"wow\",\n        \"blehh\",\n        \"fr\"\n      ];\n      \n      for (btn, btns) {\n        log(btn);\n        createSidebarButton(btn);\n      }\n    }\n  }\n}",""],[".rwl","main","\nroot {\n  script {\n    event (onload) {\n      log(\"hi\");\n    }\n  }\n}\n",""],[".rwl","test","root [color=theme:prim] {\n  frame [Horizontal] {\n    section [size=100, rounding_tr=20, rounding_br=20] {\n      \"fr\" [color=theme:seco]\n    },\n    section {\n      frame [Vertical] {\n        section [size=50] {\n          \"maybe?\" [color=theme:text, anchor=\"l\", margin=10, size=15]\n        },\n        section [color=theme:back, rounding=20, margin_r=10, margin_b=10, padding=20] {\n          \"blehhh\" [color=theme:text],\n          \"fr\",\n          button [color=theme:prim,padding=5,rounding=5] {\n            \"hi\"\n          },\n          \":P\" [anchor=\"bl\",size=5]\n        }\n      }\n    }\n  },\n  script {\n    event(onload) {\n      log(\"blehh\");\n      \n      document.title = \"gay\";\n      document.icon = \"flag-progress\";\n    }\n  }\n}",""]],"c #6c2d7b square 0 2 10 4 c #bd64e9 square -8 6 2 2 line -5 7 3 0 square 0 -1 10 5 w 8 square 0 -0.5 5 0"]